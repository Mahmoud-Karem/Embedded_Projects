
FreeRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003596  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000008  00800060  00003596  0000362a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000031b  00800068  00800068  00003632  2**0
                  ALLOC
  3 .stab         000051d8  00000000  00000000  00003634  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002eca  00000000  00000000  0000880c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 3b 0f 	jmp	0x1e76	; 0x1e76 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 e9       	ldi	r30, 0x96	; 150
      68:	f5 e3       	ldi	r31, 0x35	; 53
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 36       	cpi	r26, 0x68	; 104
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	a8 e6       	ldi	r26, 0x68	; 104
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 38       	cpi	r26, 0x83	; 131
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 ea 0b 	call	0x17d4	; 0x17d4 <main>
      8a:	0c 94 c9 1a 	jmp	0x3592	; 0x3592 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_enumSetPinDirection>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	cd b7       	in	r28, 0x3d	; 61
      98:	de b7       	in	r29, 0x3e	; 62
      9a:	28 97       	sbiw	r28, 0x08	; 8
      9c:	0f b6       	in	r0, 0x3f	; 63
      9e:	f8 94       	cli
      a0:	de bf       	out	0x3e, r29	; 62
      a2:	0f be       	out	0x3f, r0	; 63
      a4:	cd bf       	out	0x3d, r28	; 61
      a6:	8a 83       	std	Y+2, r24	; 0x02
      a8:	6b 83       	std	Y+3, r22	; 0x03
      aa:	4c 83       	std	Y+4, r20	; 0x04
      ac:	81 e0       	ldi	r24, 0x01	; 1
      ae:	89 83       	std	Y+1, r24	; 0x01
      b0:	8a 81       	ldd	r24, Y+2	; 0x02
      b2:	84 30       	cpi	r24, 0x04	; 4
      b4:	08 f0       	brcs	.+2      	; 0xb8 <DIO_enumSetPinDirection+0x26>
      b6:	f1 c0       	rjmp	.+482    	; 0x29a <DIO_enumSetPinDirection+0x208>
      b8:	8b 81       	ldd	r24, Y+3	; 0x03
      ba:	88 30       	cpi	r24, 0x08	; 8
      bc:	08 f0       	brcs	.+2      	; 0xc0 <DIO_enumSetPinDirection+0x2e>
      be:	ed c0       	rjmp	.+474    	; 0x29a <DIO_enumSetPinDirection+0x208>
      c0:	8c 81       	ldd	r24, Y+4	; 0x04
      c2:	81 30       	cpi	r24, 0x01	; 1
      c4:	09 f0       	breq	.+2      	; 0xc8 <DIO_enumSetPinDirection+0x36>
      c6:	6f c0       	rjmp	.+222    	; 0x1a6 <DIO_enumSetPinDirection+0x114>
      c8:	8a 81       	ldd	r24, Y+2	; 0x02
      ca:	28 2f       	mov	r18, r24
      cc:	30 e0       	ldi	r19, 0x00	; 0
      ce:	38 87       	std	Y+8, r19	; 0x08
      d0:	2f 83       	std	Y+7, r18	; 0x07
      d2:	8f 81       	ldd	r24, Y+7	; 0x07
      d4:	98 85       	ldd	r25, Y+8	; 0x08
      d6:	81 30       	cpi	r24, 0x01	; 1
      d8:	91 05       	cpc	r25, r1
      da:	49 f1       	breq	.+82     	; 0x12e <DIO_enumSetPinDirection+0x9c>
      dc:	2f 81       	ldd	r18, Y+7	; 0x07
      de:	38 85       	ldd	r19, Y+8	; 0x08
      e0:	22 30       	cpi	r18, 0x02	; 2
      e2:	31 05       	cpc	r19, r1
      e4:	2c f4       	brge	.+10     	; 0xf0 <DIO_enumSetPinDirection+0x5e>
      e6:	8f 81       	ldd	r24, Y+7	; 0x07
      e8:	98 85       	ldd	r25, Y+8	; 0x08
      ea:	00 97       	sbiw	r24, 0x00	; 0
      ec:	61 f0       	breq	.+24     	; 0x106 <DIO_enumSetPinDirection+0x74>
      ee:	d6 c0       	rjmp	.+428    	; 0x29c <DIO_enumSetPinDirection+0x20a>
      f0:	2f 81       	ldd	r18, Y+7	; 0x07
      f2:	38 85       	ldd	r19, Y+8	; 0x08
      f4:	22 30       	cpi	r18, 0x02	; 2
      f6:	31 05       	cpc	r19, r1
      f8:	71 f1       	breq	.+92     	; 0x156 <DIO_enumSetPinDirection+0xc4>
      fa:	8f 81       	ldd	r24, Y+7	; 0x07
      fc:	98 85       	ldd	r25, Y+8	; 0x08
      fe:	83 30       	cpi	r24, 0x03	; 3
     100:	91 05       	cpc	r25, r1
     102:	e9 f1       	breq	.+122    	; 0x17e <DIO_enumSetPinDirection+0xec>
     104:	cb c0       	rjmp	.+406    	; 0x29c <DIO_enumSetPinDirection+0x20a>
     106:	aa e3       	ldi	r26, 0x3A	; 58
     108:	b0 e0       	ldi	r27, 0x00	; 0
     10a:	ea e3       	ldi	r30, 0x3A	; 58
     10c:	f0 e0       	ldi	r31, 0x00	; 0
     10e:	80 81       	ld	r24, Z
     110:	48 2f       	mov	r20, r24
     112:	8b 81       	ldd	r24, Y+3	; 0x03
     114:	28 2f       	mov	r18, r24
     116:	30 e0       	ldi	r19, 0x00	; 0
     118:	81 e0       	ldi	r24, 0x01	; 1
     11a:	90 e0       	ldi	r25, 0x00	; 0
     11c:	02 2e       	mov	r0, r18
     11e:	02 c0       	rjmp	.+4      	; 0x124 <DIO_enumSetPinDirection+0x92>
     120:	88 0f       	add	r24, r24
     122:	99 1f       	adc	r25, r25
     124:	0a 94       	dec	r0
     126:	e2 f7       	brpl	.-8      	; 0x120 <DIO_enumSetPinDirection+0x8e>
     128:	84 2b       	or	r24, r20
     12a:	8c 93       	st	X, r24
     12c:	b7 c0       	rjmp	.+366    	; 0x29c <DIO_enumSetPinDirection+0x20a>
     12e:	a7 e3       	ldi	r26, 0x37	; 55
     130:	b0 e0       	ldi	r27, 0x00	; 0
     132:	e7 e3       	ldi	r30, 0x37	; 55
     134:	f0 e0       	ldi	r31, 0x00	; 0
     136:	80 81       	ld	r24, Z
     138:	48 2f       	mov	r20, r24
     13a:	8b 81       	ldd	r24, Y+3	; 0x03
     13c:	28 2f       	mov	r18, r24
     13e:	30 e0       	ldi	r19, 0x00	; 0
     140:	81 e0       	ldi	r24, 0x01	; 1
     142:	90 e0       	ldi	r25, 0x00	; 0
     144:	02 2e       	mov	r0, r18
     146:	02 c0       	rjmp	.+4      	; 0x14c <DIO_enumSetPinDirection+0xba>
     148:	88 0f       	add	r24, r24
     14a:	99 1f       	adc	r25, r25
     14c:	0a 94       	dec	r0
     14e:	e2 f7       	brpl	.-8      	; 0x148 <DIO_enumSetPinDirection+0xb6>
     150:	84 2b       	or	r24, r20
     152:	8c 93       	st	X, r24
     154:	a3 c0       	rjmp	.+326    	; 0x29c <DIO_enumSetPinDirection+0x20a>
     156:	a4 e3       	ldi	r26, 0x34	; 52
     158:	b0 e0       	ldi	r27, 0x00	; 0
     15a:	e4 e3       	ldi	r30, 0x34	; 52
     15c:	f0 e0       	ldi	r31, 0x00	; 0
     15e:	80 81       	ld	r24, Z
     160:	48 2f       	mov	r20, r24
     162:	8b 81       	ldd	r24, Y+3	; 0x03
     164:	28 2f       	mov	r18, r24
     166:	30 e0       	ldi	r19, 0x00	; 0
     168:	81 e0       	ldi	r24, 0x01	; 1
     16a:	90 e0       	ldi	r25, 0x00	; 0
     16c:	02 2e       	mov	r0, r18
     16e:	02 c0       	rjmp	.+4      	; 0x174 <DIO_enumSetPinDirection+0xe2>
     170:	88 0f       	add	r24, r24
     172:	99 1f       	adc	r25, r25
     174:	0a 94       	dec	r0
     176:	e2 f7       	brpl	.-8      	; 0x170 <DIO_enumSetPinDirection+0xde>
     178:	84 2b       	or	r24, r20
     17a:	8c 93       	st	X, r24
     17c:	8f c0       	rjmp	.+286    	; 0x29c <DIO_enumSetPinDirection+0x20a>
     17e:	a1 e3       	ldi	r26, 0x31	; 49
     180:	b0 e0       	ldi	r27, 0x00	; 0
     182:	e1 e3       	ldi	r30, 0x31	; 49
     184:	f0 e0       	ldi	r31, 0x00	; 0
     186:	80 81       	ld	r24, Z
     188:	48 2f       	mov	r20, r24
     18a:	8b 81       	ldd	r24, Y+3	; 0x03
     18c:	28 2f       	mov	r18, r24
     18e:	30 e0       	ldi	r19, 0x00	; 0
     190:	81 e0       	ldi	r24, 0x01	; 1
     192:	90 e0       	ldi	r25, 0x00	; 0
     194:	02 2e       	mov	r0, r18
     196:	02 c0       	rjmp	.+4      	; 0x19c <DIO_enumSetPinDirection+0x10a>
     198:	88 0f       	add	r24, r24
     19a:	99 1f       	adc	r25, r25
     19c:	0a 94       	dec	r0
     19e:	e2 f7       	brpl	.-8      	; 0x198 <DIO_enumSetPinDirection+0x106>
     1a0:	84 2b       	or	r24, r20
     1a2:	8c 93       	st	X, r24
     1a4:	7b c0       	rjmp	.+246    	; 0x29c <DIO_enumSetPinDirection+0x20a>
     1a6:	8c 81       	ldd	r24, Y+4	; 0x04
     1a8:	88 23       	and	r24, r24
     1aa:	09 f0       	breq	.+2      	; 0x1ae <DIO_enumSetPinDirection+0x11c>
     1ac:	74 c0       	rjmp	.+232    	; 0x296 <DIO_enumSetPinDirection+0x204>
     1ae:	8a 81       	ldd	r24, Y+2	; 0x02
     1b0:	28 2f       	mov	r18, r24
     1b2:	30 e0       	ldi	r19, 0x00	; 0
     1b4:	3e 83       	std	Y+6, r19	; 0x06
     1b6:	2d 83       	std	Y+5, r18	; 0x05
     1b8:	8d 81       	ldd	r24, Y+5	; 0x05
     1ba:	9e 81       	ldd	r25, Y+6	; 0x06
     1bc:	81 30       	cpi	r24, 0x01	; 1
     1be:	91 05       	cpc	r25, r1
     1c0:	59 f1       	breq	.+86     	; 0x218 <DIO_enumSetPinDirection+0x186>
     1c2:	2d 81       	ldd	r18, Y+5	; 0x05
     1c4:	3e 81       	ldd	r19, Y+6	; 0x06
     1c6:	22 30       	cpi	r18, 0x02	; 2
     1c8:	31 05       	cpc	r19, r1
     1ca:	2c f4       	brge	.+10     	; 0x1d6 <DIO_enumSetPinDirection+0x144>
     1cc:	8d 81       	ldd	r24, Y+5	; 0x05
     1ce:	9e 81       	ldd	r25, Y+6	; 0x06
     1d0:	00 97       	sbiw	r24, 0x00	; 0
     1d2:	69 f0       	breq	.+26     	; 0x1ee <DIO_enumSetPinDirection+0x15c>
     1d4:	63 c0       	rjmp	.+198    	; 0x29c <DIO_enumSetPinDirection+0x20a>
     1d6:	2d 81       	ldd	r18, Y+5	; 0x05
     1d8:	3e 81       	ldd	r19, Y+6	; 0x06
     1da:	22 30       	cpi	r18, 0x02	; 2
     1dc:	31 05       	cpc	r19, r1
     1de:	89 f1       	breq	.+98     	; 0x242 <DIO_enumSetPinDirection+0x1b0>
     1e0:	8d 81       	ldd	r24, Y+5	; 0x05
     1e2:	9e 81       	ldd	r25, Y+6	; 0x06
     1e4:	83 30       	cpi	r24, 0x03	; 3
     1e6:	91 05       	cpc	r25, r1
     1e8:	09 f4       	brne	.+2      	; 0x1ec <DIO_enumSetPinDirection+0x15a>
     1ea:	40 c0       	rjmp	.+128    	; 0x26c <DIO_enumSetPinDirection+0x1da>
     1ec:	57 c0       	rjmp	.+174    	; 0x29c <DIO_enumSetPinDirection+0x20a>
     1ee:	aa e3       	ldi	r26, 0x3A	; 58
     1f0:	b0 e0       	ldi	r27, 0x00	; 0
     1f2:	ea e3       	ldi	r30, 0x3A	; 58
     1f4:	f0 e0       	ldi	r31, 0x00	; 0
     1f6:	80 81       	ld	r24, Z
     1f8:	48 2f       	mov	r20, r24
     1fa:	8b 81       	ldd	r24, Y+3	; 0x03
     1fc:	28 2f       	mov	r18, r24
     1fe:	30 e0       	ldi	r19, 0x00	; 0
     200:	81 e0       	ldi	r24, 0x01	; 1
     202:	90 e0       	ldi	r25, 0x00	; 0
     204:	02 2e       	mov	r0, r18
     206:	02 c0       	rjmp	.+4      	; 0x20c <DIO_enumSetPinDirection+0x17a>
     208:	88 0f       	add	r24, r24
     20a:	99 1f       	adc	r25, r25
     20c:	0a 94       	dec	r0
     20e:	e2 f7       	brpl	.-8      	; 0x208 <DIO_enumSetPinDirection+0x176>
     210:	80 95       	com	r24
     212:	84 23       	and	r24, r20
     214:	8c 93       	st	X, r24
     216:	42 c0       	rjmp	.+132    	; 0x29c <DIO_enumSetPinDirection+0x20a>
     218:	a7 e3       	ldi	r26, 0x37	; 55
     21a:	b0 e0       	ldi	r27, 0x00	; 0
     21c:	e7 e3       	ldi	r30, 0x37	; 55
     21e:	f0 e0       	ldi	r31, 0x00	; 0
     220:	80 81       	ld	r24, Z
     222:	48 2f       	mov	r20, r24
     224:	8b 81       	ldd	r24, Y+3	; 0x03
     226:	28 2f       	mov	r18, r24
     228:	30 e0       	ldi	r19, 0x00	; 0
     22a:	81 e0       	ldi	r24, 0x01	; 1
     22c:	90 e0       	ldi	r25, 0x00	; 0
     22e:	02 2e       	mov	r0, r18
     230:	02 c0       	rjmp	.+4      	; 0x236 <DIO_enumSetPinDirection+0x1a4>
     232:	88 0f       	add	r24, r24
     234:	99 1f       	adc	r25, r25
     236:	0a 94       	dec	r0
     238:	e2 f7       	brpl	.-8      	; 0x232 <DIO_enumSetPinDirection+0x1a0>
     23a:	80 95       	com	r24
     23c:	84 23       	and	r24, r20
     23e:	8c 93       	st	X, r24
     240:	2d c0       	rjmp	.+90     	; 0x29c <DIO_enumSetPinDirection+0x20a>
     242:	a4 e3       	ldi	r26, 0x34	; 52
     244:	b0 e0       	ldi	r27, 0x00	; 0
     246:	e4 e3       	ldi	r30, 0x34	; 52
     248:	f0 e0       	ldi	r31, 0x00	; 0
     24a:	80 81       	ld	r24, Z
     24c:	48 2f       	mov	r20, r24
     24e:	8b 81       	ldd	r24, Y+3	; 0x03
     250:	28 2f       	mov	r18, r24
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	81 e0       	ldi	r24, 0x01	; 1
     256:	90 e0       	ldi	r25, 0x00	; 0
     258:	02 2e       	mov	r0, r18
     25a:	02 c0       	rjmp	.+4      	; 0x260 <DIO_enumSetPinDirection+0x1ce>
     25c:	88 0f       	add	r24, r24
     25e:	99 1f       	adc	r25, r25
     260:	0a 94       	dec	r0
     262:	e2 f7       	brpl	.-8      	; 0x25c <DIO_enumSetPinDirection+0x1ca>
     264:	80 95       	com	r24
     266:	84 23       	and	r24, r20
     268:	8c 93       	st	X, r24
     26a:	18 c0       	rjmp	.+48     	; 0x29c <DIO_enumSetPinDirection+0x20a>
     26c:	a1 e3       	ldi	r26, 0x31	; 49
     26e:	b0 e0       	ldi	r27, 0x00	; 0
     270:	e1 e3       	ldi	r30, 0x31	; 49
     272:	f0 e0       	ldi	r31, 0x00	; 0
     274:	80 81       	ld	r24, Z
     276:	48 2f       	mov	r20, r24
     278:	8b 81       	ldd	r24, Y+3	; 0x03
     27a:	28 2f       	mov	r18, r24
     27c:	30 e0       	ldi	r19, 0x00	; 0
     27e:	81 e0       	ldi	r24, 0x01	; 1
     280:	90 e0       	ldi	r25, 0x00	; 0
     282:	02 2e       	mov	r0, r18
     284:	02 c0       	rjmp	.+4      	; 0x28a <DIO_enumSetPinDirection+0x1f8>
     286:	88 0f       	add	r24, r24
     288:	99 1f       	adc	r25, r25
     28a:	0a 94       	dec	r0
     28c:	e2 f7       	brpl	.-8      	; 0x286 <DIO_enumSetPinDirection+0x1f4>
     28e:	80 95       	com	r24
     290:	84 23       	and	r24, r20
     292:	8c 93       	st	X, r24
     294:	03 c0       	rjmp	.+6      	; 0x29c <DIO_enumSetPinDirection+0x20a>
     296:	19 82       	std	Y+1, r1	; 0x01
     298:	01 c0       	rjmp	.+2      	; 0x29c <DIO_enumSetPinDirection+0x20a>
     29a:	19 82       	std	Y+1, r1	; 0x01
     29c:	89 81       	ldd	r24, Y+1	; 0x01
     29e:	28 96       	adiw	r28, 0x08	; 8
     2a0:	0f b6       	in	r0, 0x3f	; 63
     2a2:	f8 94       	cli
     2a4:	de bf       	out	0x3e, r29	; 62
     2a6:	0f be       	out	0x3f, r0	; 63
     2a8:	cd bf       	out	0x3d, r28	; 61
     2aa:	cf 91       	pop	r28
     2ac:	df 91       	pop	r29
     2ae:	08 95       	ret

000002b0 <DIO_enumSetPinValue>:
  	  =>Copy_u8PIN  --> Pin Number [ DIO_PIN0 , DIO_PIN1 , DIO_PIN2 , DIO_PIN3 , DIO_PIN4 , DIO_PIN5 , DIO_PIN6 , DIO_PIN7 ]
  	  =>Copy_u8Value --> Pin Direction [ DIO_PIN_HIGH , DIO_PIN_LOW ]
 * return : its status
 */
DIO_ErrorStatus DIO_enumSetPinValue      (u8 Copy_u8PORT , u8 Copy_u8PIN , u8 Copy_u8Value ) 
{
     2b0:	df 93       	push	r29
     2b2:	cf 93       	push	r28
     2b4:	cd b7       	in	r28, 0x3d	; 61
     2b6:	de b7       	in	r29, 0x3e	; 62
     2b8:	28 97       	sbiw	r28, 0x08	; 8
     2ba:	0f b6       	in	r0, 0x3f	; 63
     2bc:	f8 94       	cli
     2be:	de bf       	out	0x3e, r29	; 62
     2c0:	0f be       	out	0x3f, r0	; 63
     2c2:	cd bf       	out	0x3d, r28	; 61
     2c4:	8a 83       	std	Y+2, r24	; 0x02
     2c6:	6b 83       	std	Y+3, r22	; 0x03
     2c8:	4c 83       	std	Y+4, r20	; 0x04

	DIO_ErrorStatus LOC_enumState = DIO_OK ;
     2ca:	81 e0       	ldi	r24, 0x01	; 1
     2cc:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure that the Port ID and Pin ID are in the valid range */
	if ((Copy_u8PORT <= DIO_PORTD) && (Copy_u8PIN <= DIO_PIN7))
     2ce:	8a 81       	ldd	r24, Y+2	; 0x02
     2d0:	84 30       	cpi	r24, 0x04	; 4
     2d2:	08 f0       	brcs	.+2      	; 0x2d6 <DIO_enumSetPinValue+0x26>
     2d4:	f1 c0       	rjmp	.+482    	; 0x4b8 <DIO_enumSetPinValue+0x208>
     2d6:	8b 81       	ldd	r24, Y+3	; 0x03
     2d8:	88 30       	cpi	r24, 0x08	; 8
     2da:	08 f0       	brcs	.+2      	; 0x2de <DIO_enumSetPinValue+0x2e>
     2dc:	ed c0       	rjmp	.+474    	; 0x4b8 <DIO_enumSetPinValue+0x208>
	{
		if (Copy_u8Value == DIO_PIN_HIGH)
     2de:	8c 81       	ldd	r24, Y+4	; 0x04
     2e0:	81 30       	cpi	r24, 0x01	; 1
     2e2:	09 f0       	breq	.+2      	; 0x2e6 <DIO_enumSetPinValue+0x36>
     2e4:	6f c0       	rjmp	.+222    	; 0x3c4 <DIO_enumSetPinValue+0x114>
		{
			/* Check on the Required PORT Number */
			switch (Copy_u8PORT)
     2e6:	8a 81       	ldd	r24, Y+2	; 0x02
     2e8:	28 2f       	mov	r18, r24
     2ea:	30 e0       	ldi	r19, 0x00	; 0
     2ec:	38 87       	std	Y+8, r19	; 0x08
     2ee:	2f 83       	std	Y+7, r18	; 0x07
     2f0:	8f 81       	ldd	r24, Y+7	; 0x07
     2f2:	98 85       	ldd	r25, Y+8	; 0x08
     2f4:	81 30       	cpi	r24, 0x01	; 1
     2f6:	91 05       	cpc	r25, r1
     2f8:	49 f1       	breq	.+82     	; 0x34c <DIO_enumSetPinValue+0x9c>
     2fa:	2f 81       	ldd	r18, Y+7	; 0x07
     2fc:	38 85       	ldd	r19, Y+8	; 0x08
     2fe:	22 30       	cpi	r18, 0x02	; 2
     300:	31 05       	cpc	r19, r1
     302:	2c f4       	brge	.+10     	; 0x30e <DIO_enumSetPinValue+0x5e>
     304:	8f 81       	ldd	r24, Y+7	; 0x07
     306:	98 85       	ldd	r25, Y+8	; 0x08
     308:	00 97       	sbiw	r24, 0x00	; 0
     30a:	61 f0       	breq	.+24     	; 0x324 <DIO_enumSetPinValue+0x74>
     30c:	d6 c0       	rjmp	.+428    	; 0x4ba <DIO_enumSetPinValue+0x20a>
     30e:	2f 81       	ldd	r18, Y+7	; 0x07
     310:	38 85       	ldd	r19, Y+8	; 0x08
     312:	22 30       	cpi	r18, 0x02	; 2
     314:	31 05       	cpc	r19, r1
     316:	71 f1       	breq	.+92     	; 0x374 <DIO_enumSetPinValue+0xc4>
     318:	8f 81       	ldd	r24, Y+7	; 0x07
     31a:	98 85       	ldd	r25, Y+8	; 0x08
     31c:	83 30       	cpi	r24, 0x03	; 3
     31e:	91 05       	cpc	r25, r1
     320:	e9 f1       	breq	.+122    	; 0x39c <DIO_enumSetPinValue+0xec>
     322:	cb c0       	rjmp	.+406    	; 0x4ba <DIO_enumSetPinValue+0x20a>
			{
			case DIO_PORTA: SET_BIT(PORTA_Register,Copy_u8PIN); break;
     324:	ab e3       	ldi	r26, 0x3B	; 59
     326:	b0 e0       	ldi	r27, 0x00	; 0
     328:	eb e3       	ldi	r30, 0x3B	; 59
     32a:	f0 e0       	ldi	r31, 0x00	; 0
     32c:	80 81       	ld	r24, Z
     32e:	48 2f       	mov	r20, r24
     330:	8b 81       	ldd	r24, Y+3	; 0x03
     332:	28 2f       	mov	r18, r24
     334:	30 e0       	ldi	r19, 0x00	; 0
     336:	81 e0       	ldi	r24, 0x01	; 1
     338:	90 e0       	ldi	r25, 0x00	; 0
     33a:	02 2e       	mov	r0, r18
     33c:	02 c0       	rjmp	.+4      	; 0x342 <DIO_enumSetPinValue+0x92>
     33e:	88 0f       	add	r24, r24
     340:	99 1f       	adc	r25, r25
     342:	0a 94       	dec	r0
     344:	e2 f7       	brpl	.-8      	; 0x33e <DIO_enumSetPinValue+0x8e>
     346:	84 2b       	or	r24, r20
     348:	8c 93       	st	X, r24
     34a:	b7 c0       	rjmp	.+366    	; 0x4ba <DIO_enumSetPinValue+0x20a>
			case DIO_PORTB: SET_BIT(PORTB_Register,Copy_u8PIN); break;
     34c:	a8 e3       	ldi	r26, 0x38	; 56
     34e:	b0 e0       	ldi	r27, 0x00	; 0
     350:	e8 e3       	ldi	r30, 0x38	; 56
     352:	f0 e0       	ldi	r31, 0x00	; 0
     354:	80 81       	ld	r24, Z
     356:	48 2f       	mov	r20, r24
     358:	8b 81       	ldd	r24, Y+3	; 0x03
     35a:	28 2f       	mov	r18, r24
     35c:	30 e0       	ldi	r19, 0x00	; 0
     35e:	81 e0       	ldi	r24, 0x01	; 1
     360:	90 e0       	ldi	r25, 0x00	; 0
     362:	02 2e       	mov	r0, r18
     364:	02 c0       	rjmp	.+4      	; 0x36a <DIO_enumSetPinValue+0xba>
     366:	88 0f       	add	r24, r24
     368:	99 1f       	adc	r25, r25
     36a:	0a 94       	dec	r0
     36c:	e2 f7       	brpl	.-8      	; 0x366 <DIO_enumSetPinValue+0xb6>
     36e:	84 2b       	or	r24, r20
     370:	8c 93       	st	X, r24
     372:	a3 c0       	rjmp	.+326    	; 0x4ba <DIO_enumSetPinValue+0x20a>
			case DIO_PORTC: SET_BIT(PORTC_Register,Copy_u8PIN); break;
     374:	a5 e3       	ldi	r26, 0x35	; 53
     376:	b0 e0       	ldi	r27, 0x00	; 0
     378:	e5 e3       	ldi	r30, 0x35	; 53
     37a:	f0 e0       	ldi	r31, 0x00	; 0
     37c:	80 81       	ld	r24, Z
     37e:	48 2f       	mov	r20, r24
     380:	8b 81       	ldd	r24, Y+3	; 0x03
     382:	28 2f       	mov	r18, r24
     384:	30 e0       	ldi	r19, 0x00	; 0
     386:	81 e0       	ldi	r24, 0x01	; 1
     388:	90 e0       	ldi	r25, 0x00	; 0
     38a:	02 2e       	mov	r0, r18
     38c:	02 c0       	rjmp	.+4      	; 0x392 <DIO_enumSetPinValue+0xe2>
     38e:	88 0f       	add	r24, r24
     390:	99 1f       	adc	r25, r25
     392:	0a 94       	dec	r0
     394:	e2 f7       	brpl	.-8      	; 0x38e <DIO_enumSetPinValue+0xde>
     396:	84 2b       	or	r24, r20
     398:	8c 93       	st	X, r24
     39a:	8f c0       	rjmp	.+286    	; 0x4ba <DIO_enumSetPinValue+0x20a>
			case DIO_PORTD: SET_BIT(PORTD_Register,Copy_u8PIN); break;
     39c:	a2 e3       	ldi	r26, 0x32	; 50
     39e:	b0 e0       	ldi	r27, 0x00	; 0
     3a0:	e2 e3       	ldi	r30, 0x32	; 50
     3a2:	f0 e0       	ldi	r31, 0x00	; 0
     3a4:	80 81       	ld	r24, Z
     3a6:	48 2f       	mov	r20, r24
     3a8:	8b 81       	ldd	r24, Y+3	; 0x03
     3aa:	28 2f       	mov	r18, r24
     3ac:	30 e0       	ldi	r19, 0x00	; 0
     3ae:	81 e0       	ldi	r24, 0x01	; 1
     3b0:	90 e0       	ldi	r25, 0x00	; 0
     3b2:	02 2e       	mov	r0, r18
     3b4:	02 c0       	rjmp	.+4      	; 0x3ba <DIO_enumSetPinValue+0x10a>
     3b6:	88 0f       	add	r24, r24
     3b8:	99 1f       	adc	r25, r25
     3ba:	0a 94       	dec	r0
     3bc:	e2 f7       	brpl	.-8      	; 0x3b6 <DIO_enumSetPinValue+0x106>
     3be:	84 2b       	or	r24, r20
     3c0:	8c 93       	st	X, r24
     3c2:	7b c0       	rjmp	.+246    	; 0x4ba <DIO_enumSetPinValue+0x20a>
			}

		}

		else if (Copy_u8Value == DIO_PIN_LOW)
     3c4:	8c 81       	ldd	r24, Y+4	; 0x04
     3c6:	88 23       	and	r24, r24
     3c8:	09 f0       	breq	.+2      	; 0x3cc <DIO_enumSetPinValue+0x11c>
     3ca:	74 c0       	rjmp	.+232    	; 0x4b4 <DIO_enumSetPinValue+0x204>
		{
			/* Check on the Required PORT Number */
			switch (Copy_u8PORT)
     3cc:	8a 81       	ldd	r24, Y+2	; 0x02
     3ce:	28 2f       	mov	r18, r24
     3d0:	30 e0       	ldi	r19, 0x00	; 0
     3d2:	3e 83       	std	Y+6, r19	; 0x06
     3d4:	2d 83       	std	Y+5, r18	; 0x05
     3d6:	8d 81       	ldd	r24, Y+5	; 0x05
     3d8:	9e 81       	ldd	r25, Y+6	; 0x06
     3da:	81 30       	cpi	r24, 0x01	; 1
     3dc:	91 05       	cpc	r25, r1
     3de:	59 f1       	breq	.+86     	; 0x436 <DIO_enumSetPinValue+0x186>
     3e0:	2d 81       	ldd	r18, Y+5	; 0x05
     3e2:	3e 81       	ldd	r19, Y+6	; 0x06
     3e4:	22 30       	cpi	r18, 0x02	; 2
     3e6:	31 05       	cpc	r19, r1
     3e8:	2c f4       	brge	.+10     	; 0x3f4 <DIO_enumSetPinValue+0x144>
     3ea:	8d 81       	ldd	r24, Y+5	; 0x05
     3ec:	9e 81       	ldd	r25, Y+6	; 0x06
     3ee:	00 97       	sbiw	r24, 0x00	; 0
     3f0:	69 f0       	breq	.+26     	; 0x40c <DIO_enumSetPinValue+0x15c>
     3f2:	63 c0       	rjmp	.+198    	; 0x4ba <DIO_enumSetPinValue+0x20a>
     3f4:	2d 81       	ldd	r18, Y+5	; 0x05
     3f6:	3e 81       	ldd	r19, Y+6	; 0x06
     3f8:	22 30       	cpi	r18, 0x02	; 2
     3fa:	31 05       	cpc	r19, r1
     3fc:	89 f1       	breq	.+98     	; 0x460 <DIO_enumSetPinValue+0x1b0>
     3fe:	8d 81       	ldd	r24, Y+5	; 0x05
     400:	9e 81       	ldd	r25, Y+6	; 0x06
     402:	83 30       	cpi	r24, 0x03	; 3
     404:	91 05       	cpc	r25, r1
     406:	09 f4       	brne	.+2      	; 0x40a <DIO_enumSetPinValue+0x15a>
     408:	40 c0       	rjmp	.+128    	; 0x48a <DIO_enumSetPinValue+0x1da>
     40a:	57 c0       	rjmp	.+174    	; 0x4ba <DIO_enumSetPinValue+0x20a>
			{
			case DIO_PORTA: CLR_BIT(PORTA_Register,Copy_u8PIN); break;
     40c:	ab e3       	ldi	r26, 0x3B	; 59
     40e:	b0 e0       	ldi	r27, 0x00	; 0
     410:	eb e3       	ldi	r30, 0x3B	; 59
     412:	f0 e0       	ldi	r31, 0x00	; 0
     414:	80 81       	ld	r24, Z
     416:	48 2f       	mov	r20, r24
     418:	8b 81       	ldd	r24, Y+3	; 0x03
     41a:	28 2f       	mov	r18, r24
     41c:	30 e0       	ldi	r19, 0x00	; 0
     41e:	81 e0       	ldi	r24, 0x01	; 1
     420:	90 e0       	ldi	r25, 0x00	; 0
     422:	02 2e       	mov	r0, r18
     424:	02 c0       	rjmp	.+4      	; 0x42a <DIO_enumSetPinValue+0x17a>
     426:	88 0f       	add	r24, r24
     428:	99 1f       	adc	r25, r25
     42a:	0a 94       	dec	r0
     42c:	e2 f7       	brpl	.-8      	; 0x426 <DIO_enumSetPinValue+0x176>
     42e:	80 95       	com	r24
     430:	84 23       	and	r24, r20
     432:	8c 93       	st	X, r24
     434:	42 c0       	rjmp	.+132    	; 0x4ba <DIO_enumSetPinValue+0x20a>
			case DIO_PORTB: CLR_BIT(PORTB_Register,Copy_u8PIN); break;
     436:	a8 e3       	ldi	r26, 0x38	; 56
     438:	b0 e0       	ldi	r27, 0x00	; 0
     43a:	e8 e3       	ldi	r30, 0x38	; 56
     43c:	f0 e0       	ldi	r31, 0x00	; 0
     43e:	80 81       	ld	r24, Z
     440:	48 2f       	mov	r20, r24
     442:	8b 81       	ldd	r24, Y+3	; 0x03
     444:	28 2f       	mov	r18, r24
     446:	30 e0       	ldi	r19, 0x00	; 0
     448:	81 e0       	ldi	r24, 0x01	; 1
     44a:	90 e0       	ldi	r25, 0x00	; 0
     44c:	02 2e       	mov	r0, r18
     44e:	02 c0       	rjmp	.+4      	; 0x454 <DIO_enumSetPinValue+0x1a4>
     450:	88 0f       	add	r24, r24
     452:	99 1f       	adc	r25, r25
     454:	0a 94       	dec	r0
     456:	e2 f7       	brpl	.-8      	; 0x450 <DIO_enumSetPinValue+0x1a0>
     458:	80 95       	com	r24
     45a:	84 23       	and	r24, r20
     45c:	8c 93       	st	X, r24
     45e:	2d c0       	rjmp	.+90     	; 0x4ba <DIO_enumSetPinValue+0x20a>
			case DIO_PORTC: CLR_BIT(PORTC_Register,Copy_u8PIN); break;
     460:	a5 e3       	ldi	r26, 0x35	; 53
     462:	b0 e0       	ldi	r27, 0x00	; 0
     464:	e5 e3       	ldi	r30, 0x35	; 53
     466:	f0 e0       	ldi	r31, 0x00	; 0
     468:	80 81       	ld	r24, Z
     46a:	48 2f       	mov	r20, r24
     46c:	8b 81       	ldd	r24, Y+3	; 0x03
     46e:	28 2f       	mov	r18, r24
     470:	30 e0       	ldi	r19, 0x00	; 0
     472:	81 e0       	ldi	r24, 0x01	; 1
     474:	90 e0       	ldi	r25, 0x00	; 0
     476:	02 2e       	mov	r0, r18
     478:	02 c0       	rjmp	.+4      	; 0x47e <DIO_enumSetPinValue+0x1ce>
     47a:	88 0f       	add	r24, r24
     47c:	99 1f       	adc	r25, r25
     47e:	0a 94       	dec	r0
     480:	e2 f7       	brpl	.-8      	; 0x47a <DIO_enumSetPinValue+0x1ca>
     482:	80 95       	com	r24
     484:	84 23       	and	r24, r20
     486:	8c 93       	st	X, r24
     488:	18 c0       	rjmp	.+48     	; 0x4ba <DIO_enumSetPinValue+0x20a>
			case DIO_PORTD: CLR_BIT(PORTD_Register,Copy_u8PIN); break;
     48a:	a2 e3       	ldi	r26, 0x32	; 50
     48c:	b0 e0       	ldi	r27, 0x00	; 0
     48e:	e2 e3       	ldi	r30, 0x32	; 50
     490:	f0 e0       	ldi	r31, 0x00	; 0
     492:	80 81       	ld	r24, Z
     494:	48 2f       	mov	r20, r24
     496:	8b 81       	ldd	r24, Y+3	; 0x03
     498:	28 2f       	mov	r18, r24
     49a:	30 e0       	ldi	r19, 0x00	; 0
     49c:	81 e0       	ldi	r24, 0x01	; 1
     49e:	90 e0       	ldi	r25, 0x00	; 0
     4a0:	02 2e       	mov	r0, r18
     4a2:	02 c0       	rjmp	.+4      	; 0x4a8 <DIO_enumSetPinValue+0x1f8>
     4a4:	88 0f       	add	r24, r24
     4a6:	99 1f       	adc	r25, r25
     4a8:	0a 94       	dec	r0
     4aa:	e2 f7       	brpl	.-8      	; 0x4a4 <DIO_enumSetPinValue+0x1f4>
     4ac:	80 95       	com	r24
     4ae:	84 23       	and	r24, r20
     4b0:	8c 93       	st	X, r24
     4b2:	03 c0       	rjmp	.+6      	; 0x4ba <DIO_enumSetPinValue+0x20a>
			}
		}

		else
		{
			LOC_enumState = DIO_NOK ;
     4b4:	19 82       	std	Y+1, r1	; 0x01
     4b6:	01 c0       	rjmp	.+2      	; 0x4ba <DIO_enumSetPinValue+0x20a>
		}
	}

	else
	{
		LOC_enumState = DIO_NOK ;
     4b8:	19 82       	std	Y+1, r1	; 0x01
	}

	return LOC_enumState ;
     4ba:	89 81       	ldd	r24, Y+1	; 0x01

}
     4bc:	28 96       	adiw	r28, 0x08	; 8
     4be:	0f b6       	in	r0, 0x3f	; 63
     4c0:	f8 94       	cli
     4c2:	de bf       	out	0x3e, r29	; 62
     4c4:	0f be       	out	0x3f, r0	; 63
     4c6:	cd bf       	out	0x3d, r28	; 61
     4c8:	cf 91       	pop	r28
     4ca:	df 91       	pop	r29
     4cc:	08 95       	ret

000004ce <DIO_enumGetPinValue>:
  	  => *Copy_PtrData  --> pointer to recieve the pin value
 * return : its status and recieve Pin Value in pointer
 */

DIO_ErrorStatus DIO_enumGetPinValue          (u8 Copy_u8PORT, u8 Copy_u8PIN, u8 * Copy_PtrData   )
{
     4ce:	df 93       	push	r29
     4d0:	cf 93       	push	r28
     4d2:	cd b7       	in	r28, 0x3d	; 61
     4d4:	de b7       	in	r29, 0x3e	; 62
     4d6:	27 97       	sbiw	r28, 0x07	; 7
     4d8:	0f b6       	in	r0, 0x3f	; 63
     4da:	f8 94       	cli
     4dc:	de bf       	out	0x3e, r29	; 62
     4de:	0f be       	out	0x3f, r0	; 63
     4e0:	cd bf       	out	0x3d, r28	; 61
     4e2:	8a 83       	std	Y+2, r24	; 0x02
     4e4:	6b 83       	std	Y+3, r22	; 0x03
     4e6:	5d 83       	std	Y+5, r21	; 0x05
     4e8:	4c 83       	std	Y+4, r20	; 0x04

	DIO_ErrorStatus LOC_enumState = DIO_OK ;
     4ea:	81 e0       	ldi	r24, 0x01	; 1
     4ec:	89 83       	std	Y+1, r24	; 0x01

	if ((Copy_u8PORT <= DIO_PORTD) && (Copy_u8PIN <= DIO_PIN7))
     4ee:	8a 81       	ldd	r24, Y+2	; 0x02
     4f0:	84 30       	cpi	r24, 0x04	; 4
     4f2:	08 f0       	brcs	.+2      	; 0x4f6 <DIO_enumGetPinValue+0x28>
     4f4:	a6 c0       	rjmp	.+332    	; 0x642 <DIO_enumGetPinValue+0x174>
     4f6:	8b 81       	ldd	r24, Y+3	; 0x03
     4f8:	88 30       	cpi	r24, 0x08	; 8
     4fa:	08 f0       	brcs	.+2      	; 0x4fe <DIO_enumGetPinValue+0x30>
     4fc:	a2 c0       	rjmp	.+324    	; 0x642 <DIO_enumGetPinValue+0x174>
	{
		/* Check on the Required PORT Number */
		switch (Copy_u8PORT)
     4fe:	8a 81       	ldd	r24, Y+2	; 0x02
     500:	28 2f       	mov	r18, r24
     502:	30 e0       	ldi	r19, 0x00	; 0
     504:	3f 83       	std	Y+7, r19	; 0x07
     506:	2e 83       	std	Y+6, r18	; 0x06
     508:	4e 81       	ldd	r20, Y+6	; 0x06
     50a:	5f 81       	ldd	r21, Y+7	; 0x07
     50c:	41 30       	cpi	r20, 0x01	; 1
     50e:	51 05       	cpc	r21, r1
     510:	c1 f1       	breq	.+112    	; 0x582 <DIO_enumGetPinValue+0xb4>
     512:	8e 81       	ldd	r24, Y+6	; 0x06
     514:	9f 81       	ldd	r25, Y+7	; 0x07
     516:	82 30       	cpi	r24, 0x02	; 2
     518:	91 05       	cpc	r25, r1
     51a:	34 f4       	brge	.+12     	; 0x528 <DIO_enumGetPinValue+0x5a>
     51c:	2e 81       	ldd	r18, Y+6	; 0x06
     51e:	3f 81       	ldd	r19, Y+7	; 0x07
     520:	21 15       	cp	r18, r1
     522:	31 05       	cpc	r19, r1
     524:	71 f0       	breq	.+28     	; 0x542 <DIO_enumGetPinValue+0x74>
     526:	8e c0       	rjmp	.+284    	; 0x644 <DIO_enumGetPinValue+0x176>
     528:	4e 81       	ldd	r20, Y+6	; 0x06
     52a:	5f 81       	ldd	r21, Y+7	; 0x07
     52c:	42 30       	cpi	r20, 0x02	; 2
     52e:	51 05       	cpc	r21, r1
     530:	09 f4       	brne	.+2      	; 0x534 <DIO_enumGetPinValue+0x66>
     532:	47 c0       	rjmp	.+142    	; 0x5c2 <DIO_enumGetPinValue+0xf4>
     534:	8e 81       	ldd	r24, Y+6	; 0x06
     536:	9f 81       	ldd	r25, Y+7	; 0x07
     538:	83 30       	cpi	r24, 0x03	; 3
     53a:	91 05       	cpc	r25, r1
     53c:	09 f4       	brne	.+2      	; 0x540 <DIO_enumGetPinValue+0x72>
     53e:	61 c0       	rjmp	.+194    	; 0x602 <DIO_enumGetPinValue+0x134>
     540:	81 c0       	rjmp	.+258    	; 0x644 <DIO_enumGetPinValue+0x176>
		{
		case DIO_PORTA: * Copy_PtrData = GET_BIT(PINA_Register,Copy_u8PIN); break;
     542:	e9 e3       	ldi	r30, 0x39	; 57
     544:	f0 e0       	ldi	r31, 0x00	; 0
     546:	80 81       	ld	r24, Z
     548:	48 2f       	mov	r20, r24
     54a:	50 e0       	ldi	r21, 0x00	; 0
     54c:	8b 81       	ldd	r24, Y+3	; 0x03
     54e:	28 2f       	mov	r18, r24
     550:	30 e0       	ldi	r19, 0x00	; 0
     552:	81 e0       	ldi	r24, 0x01	; 1
     554:	90 e0       	ldi	r25, 0x00	; 0
     556:	02 c0       	rjmp	.+4      	; 0x55c <DIO_enumGetPinValue+0x8e>
     558:	88 0f       	add	r24, r24
     55a:	99 1f       	adc	r25, r25
     55c:	2a 95       	dec	r18
     55e:	e2 f7       	brpl	.-8      	; 0x558 <DIO_enumGetPinValue+0x8a>
     560:	9a 01       	movw	r18, r20
     562:	28 23       	and	r18, r24
     564:	39 23       	and	r19, r25
     566:	8b 81       	ldd	r24, Y+3	; 0x03
     568:	88 2f       	mov	r24, r24
     56a:	90 e0       	ldi	r25, 0x00	; 0
     56c:	a9 01       	movw	r20, r18
     56e:	02 c0       	rjmp	.+4      	; 0x574 <DIO_enumGetPinValue+0xa6>
     570:	55 95       	asr	r21
     572:	47 95       	ror	r20
     574:	8a 95       	dec	r24
     576:	e2 f7       	brpl	.-8      	; 0x570 <DIO_enumGetPinValue+0xa2>
     578:	ca 01       	movw	r24, r20
     57a:	ec 81       	ldd	r30, Y+4	; 0x04
     57c:	fd 81       	ldd	r31, Y+5	; 0x05
     57e:	80 83       	st	Z, r24
     580:	61 c0       	rjmp	.+194    	; 0x644 <DIO_enumGetPinValue+0x176>
		case DIO_PORTB: * Copy_PtrData = GET_BIT(PINB_Register,Copy_u8PIN); break;
     582:	e6 e3       	ldi	r30, 0x36	; 54
     584:	f0 e0       	ldi	r31, 0x00	; 0
     586:	80 81       	ld	r24, Z
     588:	48 2f       	mov	r20, r24
     58a:	50 e0       	ldi	r21, 0x00	; 0
     58c:	8b 81       	ldd	r24, Y+3	; 0x03
     58e:	28 2f       	mov	r18, r24
     590:	30 e0       	ldi	r19, 0x00	; 0
     592:	81 e0       	ldi	r24, 0x01	; 1
     594:	90 e0       	ldi	r25, 0x00	; 0
     596:	02 c0       	rjmp	.+4      	; 0x59c <DIO_enumGetPinValue+0xce>
     598:	88 0f       	add	r24, r24
     59a:	99 1f       	adc	r25, r25
     59c:	2a 95       	dec	r18
     59e:	e2 f7       	brpl	.-8      	; 0x598 <DIO_enumGetPinValue+0xca>
     5a0:	9a 01       	movw	r18, r20
     5a2:	28 23       	and	r18, r24
     5a4:	39 23       	and	r19, r25
     5a6:	8b 81       	ldd	r24, Y+3	; 0x03
     5a8:	88 2f       	mov	r24, r24
     5aa:	90 e0       	ldi	r25, 0x00	; 0
     5ac:	a9 01       	movw	r20, r18
     5ae:	02 c0       	rjmp	.+4      	; 0x5b4 <DIO_enumGetPinValue+0xe6>
     5b0:	55 95       	asr	r21
     5b2:	47 95       	ror	r20
     5b4:	8a 95       	dec	r24
     5b6:	e2 f7       	brpl	.-8      	; 0x5b0 <DIO_enumGetPinValue+0xe2>
     5b8:	ca 01       	movw	r24, r20
     5ba:	ec 81       	ldd	r30, Y+4	; 0x04
     5bc:	fd 81       	ldd	r31, Y+5	; 0x05
     5be:	80 83       	st	Z, r24
     5c0:	41 c0       	rjmp	.+130    	; 0x644 <DIO_enumGetPinValue+0x176>
		case DIO_PORTC: * Copy_PtrData = GET_BIT(PINC_Register,Copy_u8PIN); break;
     5c2:	e3 e3       	ldi	r30, 0x33	; 51
     5c4:	f0 e0       	ldi	r31, 0x00	; 0
     5c6:	80 81       	ld	r24, Z
     5c8:	48 2f       	mov	r20, r24
     5ca:	50 e0       	ldi	r21, 0x00	; 0
     5cc:	8b 81       	ldd	r24, Y+3	; 0x03
     5ce:	28 2f       	mov	r18, r24
     5d0:	30 e0       	ldi	r19, 0x00	; 0
     5d2:	81 e0       	ldi	r24, 0x01	; 1
     5d4:	90 e0       	ldi	r25, 0x00	; 0
     5d6:	02 c0       	rjmp	.+4      	; 0x5dc <DIO_enumGetPinValue+0x10e>
     5d8:	88 0f       	add	r24, r24
     5da:	99 1f       	adc	r25, r25
     5dc:	2a 95       	dec	r18
     5de:	e2 f7       	brpl	.-8      	; 0x5d8 <DIO_enumGetPinValue+0x10a>
     5e0:	9a 01       	movw	r18, r20
     5e2:	28 23       	and	r18, r24
     5e4:	39 23       	and	r19, r25
     5e6:	8b 81       	ldd	r24, Y+3	; 0x03
     5e8:	88 2f       	mov	r24, r24
     5ea:	90 e0       	ldi	r25, 0x00	; 0
     5ec:	a9 01       	movw	r20, r18
     5ee:	02 c0       	rjmp	.+4      	; 0x5f4 <DIO_enumGetPinValue+0x126>
     5f0:	55 95       	asr	r21
     5f2:	47 95       	ror	r20
     5f4:	8a 95       	dec	r24
     5f6:	e2 f7       	brpl	.-8      	; 0x5f0 <DIO_enumGetPinValue+0x122>
     5f8:	ca 01       	movw	r24, r20
     5fa:	ec 81       	ldd	r30, Y+4	; 0x04
     5fc:	fd 81       	ldd	r31, Y+5	; 0x05
     5fe:	80 83       	st	Z, r24
     600:	21 c0       	rjmp	.+66     	; 0x644 <DIO_enumGetPinValue+0x176>
		case DIO_PORTD: * Copy_PtrData = GET_BIT(PIND_Register,Copy_u8PIN); break;
     602:	e0 e3       	ldi	r30, 0x30	; 48
     604:	f0 e0       	ldi	r31, 0x00	; 0
     606:	80 81       	ld	r24, Z
     608:	48 2f       	mov	r20, r24
     60a:	50 e0       	ldi	r21, 0x00	; 0
     60c:	8b 81       	ldd	r24, Y+3	; 0x03
     60e:	28 2f       	mov	r18, r24
     610:	30 e0       	ldi	r19, 0x00	; 0
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	90 e0       	ldi	r25, 0x00	; 0
     616:	02 c0       	rjmp	.+4      	; 0x61c <DIO_enumGetPinValue+0x14e>
     618:	88 0f       	add	r24, r24
     61a:	99 1f       	adc	r25, r25
     61c:	2a 95       	dec	r18
     61e:	e2 f7       	brpl	.-8      	; 0x618 <DIO_enumGetPinValue+0x14a>
     620:	9a 01       	movw	r18, r20
     622:	28 23       	and	r18, r24
     624:	39 23       	and	r19, r25
     626:	8b 81       	ldd	r24, Y+3	; 0x03
     628:	88 2f       	mov	r24, r24
     62a:	90 e0       	ldi	r25, 0x00	; 0
     62c:	a9 01       	movw	r20, r18
     62e:	02 c0       	rjmp	.+4      	; 0x634 <DIO_enumGetPinValue+0x166>
     630:	55 95       	asr	r21
     632:	47 95       	ror	r20
     634:	8a 95       	dec	r24
     636:	e2 f7       	brpl	.-8      	; 0x630 <DIO_enumGetPinValue+0x162>
     638:	ca 01       	movw	r24, r20
     63a:	ec 81       	ldd	r30, Y+4	; 0x04
     63c:	fd 81       	ldd	r31, Y+5	; 0x05
     63e:	80 83       	st	Z, r24
     640:	01 c0       	rjmp	.+2      	; 0x644 <DIO_enumGetPinValue+0x176>
	}

	else
	{
		/* in case of error in the Pin ID or PORT ID */
		LOC_enumState = DIO_NOK ;
     642:	19 82       	std	Y+1, r1	; 0x01
	}

	return LOC_enumState;
     644:	89 81       	ldd	r24, Y+1	; 0x01
}
     646:	27 96       	adiw	r28, 0x07	; 7
     648:	0f b6       	in	r0, 0x3f	; 63
     64a:	f8 94       	cli
     64c:	de bf       	out	0x3e, r29	; 62
     64e:	0f be       	out	0x3f, r0	; 63
     650:	cd bf       	out	0x3d, r28	; 61
     652:	cf 91       	pop	r28
     654:	df 91       	pop	r29
     656:	08 95       	ret

00000658 <DIO_enumTogglePinValue>:
  	  =>Copy_u8PORT --> Port Name [ DIO_PORTA ,	DIO_PORTB , DIO_PORTC , DIO_PORTD ]
  	  =>Copy_u8PIN  --> Pin Number [ DIO_PIN0 , DIO_PIN1 , DIO_PIN2 , DIO_PIN3 , DIO_PIN4 , DIO_PIN5 , DIO_PIN6 , DIO_PIN7 ]
 * return : its status
 */
DIO_ErrorStatus DIO_enumTogglePinValue  ( u8 Copy_u8PORT, u8 Copy_u8PIN )
{
     658:	df 93       	push	r29
     65a:	cf 93       	push	r28
     65c:	00 d0       	rcall	.+0      	; 0x65e <DIO_enumTogglePinValue+0x6>
     65e:	00 d0       	rcall	.+0      	; 0x660 <DIO_enumTogglePinValue+0x8>
     660:	0f 92       	push	r0
     662:	cd b7       	in	r28, 0x3d	; 61
     664:	de b7       	in	r29, 0x3e	; 62
     666:	8a 83       	std	Y+2, r24	; 0x02
     668:	6b 83       	std	Y+3, r22	; 0x03
	DIO_ErrorStatus LOC_enumState = DIO_OK ;
     66a:	81 e0       	ldi	r24, 0x01	; 1
     66c:	89 83       	std	Y+1, r24	; 0x01

	if (Copy_u8PIN <= DIO_PIN7)
     66e:	8b 81       	ldd	r24, Y+3	; 0x03
     670:	88 30       	cpi	r24, 0x08	; 8
     672:	08 f0       	brcs	.+2      	; 0x676 <DIO_enumTogglePinValue+0x1e>
     674:	6f c0       	rjmp	.+222    	; 0x754 <DIO_enumTogglePinValue+0xfc>
	{
		switch (Copy_u8PORT)
     676:	8a 81       	ldd	r24, Y+2	; 0x02
     678:	28 2f       	mov	r18, r24
     67a:	30 e0       	ldi	r19, 0x00	; 0
     67c:	3d 83       	std	Y+5, r19	; 0x05
     67e:	2c 83       	std	Y+4, r18	; 0x04
     680:	8c 81       	ldd	r24, Y+4	; 0x04
     682:	9d 81       	ldd	r25, Y+5	; 0x05
     684:	81 30       	cpi	r24, 0x01	; 1
     686:	91 05       	cpc	r25, r1
     688:	49 f1       	breq	.+82     	; 0x6dc <DIO_enumTogglePinValue+0x84>
     68a:	2c 81       	ldd	r18, Y+4	; 0x04
     68c:	3d 81       	ldd	r19, Y+5	; 0x05
     68e:	22 30       	cpi	r18, 0x02	; 2
     690:	31 05       	cpc	r19, r1
     692:	2c f4       	brge	.+10     	; 0x69e <DIO_enumTogglePinValue+0x46>
     694:	8c 81       	ldd	r24, Y+4	; 0x04
     696:	9d 81       	ldd	r25, Y+5	; 0x05
     698:	00 97       	sbiw	r24, 0x00	; 0
     69a:	61 f0       	breq	.+24     	; 0x6b4 <DIO_enumTogglePinValue+0x5c>
     69c:	5c c0       	rjmp	.+184    	; 0x756 <DIO_enumTogglePinValue+0xfe>
     69e:	2c 81       	ldd	r18, Y+4	; 0x04
     6a0:	3d 81       	ldd	r19, Y+5	; 0x05
     6a2:	22 30       	cpi	r18, 0x02	; 2
     6a4:	31 05       	cpc	r19, r1
     6a6:	71 f1       	breq	.+92     	; 0x704 <DIO_enumTogglePinValue+0xac>
     6a8:	8c 81       	ldd	r24, Y+4	; 0x04
     6aa:	9d 81       	ldd	r25, Y+5	; 0x05
     6ac:	83 30       	cpi	r24, 0x03	; 3
     6ae:	91 05       	cpc	r25, r1
     6b0:	e9 f1       	breq	.+122    	; 0x72c <DIO_enumTogglePinValue+0xd4>
     6b2:	51 c0       	rjmp	.+162    	; 0x756 <DIO_enumTogglePinValue+0xfe>
		{
		case DIO_PORTA : TOG_BIT(PORTA_Register,Copy_u8PIN);
     6b4:	ab e3       	ldi	r26, 0x3B	; 59
     6b6:	b0 e0       	ldi	r27, 0x00	; 0
     6b8:	eb e3       	ldi	r30, 0x3B	; 59
     6ba:	f0 e0       	ldi	r31, 0x00	; 0
     6bc:	80 81       	ld	r24, Z
     6be:	48 2f       	mov	r20, r24
     6c0:	8b 81       	ldd	r24, Y+3	; 0x03
     6c2:	28 2f       	mov	r18, r24
     6c4:	30 e0       	ldi	r19, 0x00	; 0
     6c6:	81 e0       	ldi	r24, 0x01	; 1
     6c8:	90 e0       	ldi	r25, 0x00	; 0
     6ca:	02 2e       	mov	r0, r18
     6cc:	02 c0       	rjmp	.+4      	; 0x6d2 <DIO_enumTogglePinValue+0x7a>
     6ce:	88 0f       	add	r24, r24
     6d0:	99 1f       	adc	r25, r25
     6d2:	0a 94       	dec	r0
     6d4:	e2 f7       	brpl	.-8      	; 0x6ce <DIO_enumTogglePinValue+0x76>
     6d6:	84 27       	eor	r24, r20
     6d8:	8c 93       	st	X, r24
     6da:	3d c0       	rjmp	.+122    	; 0x756 <DIO_enumTogglePinValue+0xfe>
		break ;
		case DIO_PORTB : TOG_BIT(PORTB_Register,Copy_u8PIN);
     6dc:	a8 e3       	ldi	r26, 0x38	; 56
     6de:	b0 e0       	ldi	r27, 0x00	; 0
     6e0:	e8 e3       	ldi	r30, 0x38	; 56
     6e2:	f0 e0       	ldi	r31, 0x00	; 0
     6e4:	80 81       	ld	r24, Z
     6e6:	48 2f       	mov	r20, r24
     6e8:	8b 81       	ldd	r24, Y+3	; 0x03
     6ea:	28 2f       	mov	r18, r24
     6ec:	30 e0       	ldi	r19, 0x00	; 0
     6ee:	81 e0       	ldi	r24, 0x01	; 1
     6f0:	90 e0       	ldi	r25, 0x00	; 0
     6f2:	02 2e       	mov	r0, r18
     6f4:	02 c0       	rjmp	.+4      	; 0x6fa <DIO_enumTogglePinValue+0xa2>
     6f6:	88 0f       	add	r24, r24
     6f8:	99 1f       	adc	r25, r25
     6fa:	0a 94       	dec	r0
     6fc:	e2 f7       	brpl	.-8      	; 0x6f6 <DIO_enumTogglePinValue+0x9e>
     6fe:	84 27       	eor	r24, r20
     700:	8c 93       	st	X, r24
     702:	29 c0       	rjmp	.+82     	; 0x756 <DIO_enumTogglePinValue+0xfe>
		break ;
		case DIO_PORTC : TOG_BIT(PORTC_Register,Copy_u8PIN);
     704:	a5 e3       	ldi	r26, 0x35	; 53
     706:	b0 e0       	ldi	r27, 0x00	; 0
     708:	e5 e3       	ldi	r30, 0x35	; 53
     70a:	f0 e0       	ldi	r31, 0x00	; 0
     70c:	80 81       	ld	r24, Z
     70e:	48 2f       	mov	r20, r24
     710:	8b 81       	ldd	r24, Y+3	; 0x03
     712:	28 2f       	mov	r18, r24
     714:	30 e0       	ldi	r19, 0x00	; 0
     716:	81 e0       	ldi	r24, 0x01	; 1
     718:	90 e0       	ldi	r25, 0x00	; 0
     71a:	02 2e       	mov	r0, r18
     71c:	02 c0       	rjmp	.+4      	; 0x722 <DIO_enumTogglePinValue+0xca>
     71e:	88 0f       	add	r24, r24
     720:	99 1f       	adc	r25, r25
     722:	0a 94       	dec	r0
     724:	e2 f7       	brpl	.-8      	; 0x71e <DIO_enumTogglePinValue+0xc6>
     726:	84 27       	eor	r24, r20
     728:	8c 93       	st	X, r24
     72a:	15 c0       	rjmp	.+42     	; 0x756 <DIO_enumTogglePinValue+0xfe>
		break ;
		case DIO_PORTD : TOG_BIT(PORTD_Register,Copy_u8PIN);
     72c:	a2 e3       	ldi	r26, 0x32	; 50
     72e:	b0 e0       	ldi	r27, 0x00	; 0
     730:	e2 e3       	ldi	r30, 0x32	; 50
     732:	f0 e0       	ldi	r31, 0x00	; 0
     734:	80 81       	ld	r24, Z
     736:	48 2f       	mov	r20, r24
     738:	8b 81       	ldd	r24, Y+3	; 0x03
     73a:	28 2f       	mov	r18, r24
     73c:	30 e0       	ldi	r19, 0x00	; 0
     73e:	81 e0       	ldi	r24, 0x01	; 1
     740:	90 e0       	ldi	r25, 0x00	; 0
     742:	02 2e       	mov	r0, r18
     744:	02 c0       	rjmp	.+4      	; 0x74a <DIO_enumTogglePinValue+0xf2>
     746:	88 0f       	add	r24, r24
     748:	99 1f       	adc	r25, r25
     74a:	0a 94       	dec	r0
     74c:	e2 f7       	brpl	.-8      	; 0x746 <DIO_enumTogglePinValue+0xee>
     74e:	84 27       	eor	r24, r20
     750:	8c 93       	st	X, r24
     752:	01 c0       	rjmp	.+2      	; 0x756 <DIO_enumTogglePinValue+0xfe>

	}
	else
	{
		/* in case of error in the Pin ID or PORT ID */
		LOC_enumState = DIO_NOK ;
     754:	19 82       	std	Y+1, r1	; 0x01
	}

	return LOC_enumState;
     756:	89 81       	ldd	r24, Y+1	; 0x01
}
     758:	0f 90       	pop	r0
     75a:	0f 90       	pop	r0
     75c:	0f 90       	pop	r0
     75e:	0f 90       	pop	r0
     760:	0f 90       	pop	r0
     762:	cf 91       	pop	r28
     764:	df 91       	pop	r29
     766:	08 95       	ret

00000768 <DIO_enumConnectPullup>:
  	  =>Copy_u8PIN  --> Pin Number [ DIO_PIN0 , DIO_PIN1 , DIO_PIN2 , DIO_PIN3 , DIO_PIN4 , DIO_PIN5 , DIO_PIN6 , DIO_PIN7 ]
 	  =>Copy_u8ConnectPullup --> [DIO_PIN_HIGH , DIO_PIN_LOW ]
 * return : its status
 */
DIO_ErrorStatus DIO_enumConnectPullup (u8 Copy_u8PORT ,u8 Copy_u8PIN, u8 Copy_u8ConnectPullup)
{
     768:	df 93       	push	r29
     76a:	cf 93       	push	r28
     76c:	00 d0       	rcall	.+0      	; 0x76e <DIO_enumConnectPullup+0x6>
     76e:	00 d0       	rcall	.+0      	; 0x770 <DIO_enumConnectPullup+0x8>
     770:	00 d0       	rcall	.+0      	; 0x772 <DIO_enumConnectPullup+0xa>
     772:	cd b7       	in	r28, 0x3d	; 61
     774:	de b7       	in	r29, 0x3e	; 62
     776:	8a 83       	std	Y+2, r24	; 0x02
     778:	6b 83       	std	Y+3, r22	; 0x03
     77a:	4c 83       	std	Y+4, r20	; 0x04

	DIO_ErrorStatus LOC_enumState = DIO_OK ;
     77c:	81 e0       	ldi	r24, 0x01	; 1
     77e:	89 83       	std	Y+1, r24	; 0x01

	if ((Copy_u8PORT <= DIO_PORTD) && (Copy_u8PIN <= DIO_PIN7))
     780:	8a 81       	ldd	r24, Y+2	; 0x02
     782:	84 30       	cpi	r24, 0x04	; 4
     784:	08 f0       	brcs	.+2      	; 0x788 <DIO_enumConnectPullup+0x20>
     786:	3e c1       	rjmp	.+636    	; 0xa04 <__stack+0x1a5>
     788:	8b 81       	ldd	r24, Y+3	; 0x03
     78a:	88 30       	cpi	r24, 0x08	; 8
     78c:	08 f0       	brcs	.+2      	; 0x790 <DIO_enumConnectPullup+0x28>
     78e:	3a c1       	rjmp	.+628    	; 0xa04 <__stack+0x1a5>
	{
		switch(Copy_u8PORT)
     790:	8a 81       	ldd	r24, Y+2	; 0x02
     792:	28 2f       	mov	r18, r24
     794:	30 e0       	ldi	r19, 0x00	; 0
     796:	3e 83       	std	Y+6, r19	; 0x06
     798:	2d 83       	std	Y+5, r18	; 0x05
     79a:	8d 81       	ldd	r24, Y+5	; 0x05
     79c:	9e 81       	ldd	r25, Y+6	; 0x06
     79e:	81 30       	cpi	r24, 0x01	; 1
     7a0:	91 05       	cpc	r25, r1
     7a2:	09 f4       	brne	.+2      	; 0x7a6 <DIO_enumConnectPullup+0x3e>
     7a4:	5d c0       	rjmp	.+186    	; 0x860 <__stack+0x1>
     7a6:	2d 81       	ldd	r18, Y+5	; 0x05
     7a8:	3e 81       	ldd	r19, Y+6	; 0x06
     7aa:	22 30       	cpi	r18, 0x02	; 2
     7ac:	31 05       	cpc	r19, r1
     7ae:	2c f4       	brge	.+10     	; 0x7ba <DIO_enumConnectPullup+0x52>
     7b0:	8d 81       	ldd	r24, Y+5	; 0x05
     7b2:	9e 81       	ldd	r25, Y+6	; 0x06
     7b4:	00 97       	sbiw	r24, 0x00	; 0
     7b6:	71 f0       	breq	.+28     	; 0x7d4 <DIO_enumConnectPullup+0x6c>
     7b8:	26 c1       	rjmp	.+588    	; 0xa06 <__stack+0x1a7>
     7ba:	2d 81       	ldd	r18, Y+5	; 0x05
     7bc:	3e 81       	ldd	r19, Y+6	; 0x06
     7be:	22 30       	cpi	r18, 0x02	; 2
     7c0:	31 05       	cpc	r19, r1
     7c2:	09 f4       	brne	.+2      	; 0x7c6 <DIO_enumConnectPullup+0x5e>
     7c4:	93 c0       	rjmp	.+294    	; 0x8ec <__stack+0x8d>
     7c6:	8d 81       	ldd	r24, Y+5	; 0x05
     7c8:	9e 81       	ldd	r25, Y+6	; 0x06
     7ca:	83 30       	cpi	r24, 0x03	; 3
     7cc:	91 05       	cpc	r25, r1
     7ce:	09 f4       	brne	.+2      	; 0x7d2 <DIO_enumConnectPullup+0x6a>
     7d0:	d3 c0       	rjmp	.+422    	; 0x978 <__stack+0x119>
     7d2:	19 c1       	rjmp	.+562    	; 0xa06 <__stack+0x1a7>
		{
		/* Connect or disconnect the pull up resistance to the given pin in port A */
		case DIO_PORTA:
			if(Copy_u8ConnectPullup==DIO_PIN_HIGH)
     7d4:	8c 81       	ldd	r24, Y+4	; 0x04
     7d6:	81 30       	cpi	r24, 0x01	; 1
     7d8:	71 f5       	brne	.+92     	; 0x836 <DIO_enumConnectPullup+0xce>
			{
				CLR_BIT(SFIOR,PUD);
     7da:	a0 e5       	ldi	r26, 0x50	; 80
     7dc:	b0 e0       	ldi	r27, 0x00	; 0
     7de:	e0 e5       	ldi	r30, 0x50	; 80
     7e0:	f0 e0       	ldi	r31, 0x00	; 0
     7e2:	80 81       	ld	r24, Z
     7e4:	8b 7f       	andi	r24, 0xFB	; 251
     7e6:	8c 93       	st	X, r24
				CLR_BIT(DDRA_Register,Copy_u8PIN);
     7e8:	aa e3       	ldi	r26, 0x3A	; 58
     7ea:	b0 e0       	ldi	r27, 0x00	; 0
     7ec:	ea e3       	ldi	r30, 0x3A	; 58
     7ee:	f0 e0       	ldi	r31, 0x00	; 0
     7f0:	80 81       	ld	r24, Z
     7f2:	48 2f       	mov	r20, r24
     7f4:	8b 81       	ldd	r24, Y+3	; 0x03
     7f6:	28 2f       	mov	r18, r24
     7f8:	30 e0       	ldi	r19, 0x00	; 0
     7fa:	81 e0       	ldi	r24, 0x01	; 1
     7fc:	90 e0       	ldi	r25, 0x00	; 0
     7fe:	02 c0       	rjmp	.+4      	; 0x804 <DIO_enumConnectPullup+0x9c>
     800:	88 0f       	add	r24, r24
     802:	99 1f       	adc	r25, r25
     804:	2a 95       	dec	r18
     806:	e2 f7       	brpl	.-8      	; 0x800 <DIO_enumConnectPullup+0x98>
     808:	80 95       	com	r24
     80a:	84 23       	and	r24, r20
     80c:	8c 93       	st	X, r24
				SET_BIT(PORTA_Register,Copy_u8PIN);
     80e:	ab e3       	ldi	r26, 0x3B	; 59
     810:	b0 e0       	ldi	r27, 0x00	; 0
     812:	eb e3       	ldi	r30, 0x3B	; 59
     814:	f0 e0       	ldi	r31, 0x00	; 0
     816:	80 81       	ld	r24, Z
     818:	48 2f       	mov	r20, r24
     81a:	8b 81       	ldd	r24, Y+3	; 0x03
     81c:	28 2f       	mov	r18, r24
     81e:	30 e0       	ldi	r19, 0x00	; 0
     820:	81 e0       	ldi	r24, 0x01	; 1
     822:	90 e0       	ldi	r25, 0x00	; 0
     824:	02 2e       	mov	r0, r18
     826:	02 c0       	rjmp	.+4      	; 0x82c <DIO_enumConnectPullup+0xc4>
     828:	88 0f       	add	r24, r24
     82a:	99 1f       	adc	r25, r25
     82c:	0a 94       	dec	r0
     82e:	e2 f7       	brpl	.-8      	; 0x828 <DIO_enumConnectPullup+0xc0>
     830:	84 2b       	or	r24, r20
     832:	8c 93       	st	X, r24
     834:	e8 c0       	rjmp	.+464    	; 0xa06 <__stack+0x1a7>
			}
			else
			{
				CLR_BIT(PORTA_Register,Copy_u8PIN);
     836:	ab e3       	ldi	r26, 0x3B	; 59
     838:	b0 e0       	ldi	r27, 0x00	; 0
     83a:	eb e3       	ldi	r30, 0x3B	; 59
     83c:	f0 e0       	ldi	r31, 0x00	; 0
     83e:	80 81       	ld	r24, Z
     840:	48 2f       	mov	r20, r24
     842:	8b 81       	ldd	r24, Y+3	; 0x03
     844:	28 2f       	mov	r18, r24
     846:	30 e0       	ldi	r19, 0x00	; 0
     848:	81 e0       	ldi	r24, 0x01	; 1
     84a:	90 e0       	ldi	r25, 0x00	; 0
     84c:	02 2e       	mov	r0, r18
     84e:	02 c0       	rjmp	.+4      	; 0x854 <DIO_enumConnectPullup+0xec>
     850:	88 0f       	add	r24, r24
     852:	99 1f       	adc	r25, r25
     854:	0a 94       	dec	r0
     856:	e2 f7       	brpl	.-8      	; 0x850 <DIO_enumConnectPullup+0xe8>
     858:	80 95       	com	r24
     85a:	84 23       	and	r24, r20
     85c:	8c 93       	st	X, r24
     85e:	d3 c0       	rjmp	.+422    	; 0xa06 <__stack+0x1a7>
			}
			break;
			/* Connect or disconnect the pull up resistance to the given pin in port B */
		case DIO_PORTB:
			if(Copy_u8ConnectPullup==DIO_PIN_HIGH)
     860:	8c 81       	ldd	r24, Y+4	; 0x04
     862:	81 30       	cpi	r24, 0x01	; 1
     864:	71 f5       	brne	.+92     	; 0x8c2 <__stack+0x63>
			{
				CLR_BIT(SFIOR,PUD);
     866:	a0 e5       	ldi	r26, 0x50	; 80
     868:	b0 e0       	ldi	r27, 0x00	; 0
     86a:	e0 e5       	ldi	r30, 0x50	; 80
     86c:	f0 e0       	ldi	r31, 0x00	; 0
     86e:	80 81       	ld	r24, Z
     870:	8b 7f       	andi	r24, 0xFB	; 251
     872:	8c 93       	st	X, r24
				CLR_BIT(DDRB_Register,Copy_u8PIN);
     874:	a7 e3       	ldi	r26, 0x37	; 55
     876:	b0 e0       	ldi	r27, 0x00	; 0
     878:	e7 e3       	ldi	r30, 0x37	; 55
     87a:	f0 e0       	ldi	r31, 0x00	; 0
     87c:	80 81       	ld	r24, Z
     87e:	48 2f       	mov	r20, r24
     880:	8b 81       	ldd	r24, Y+3	; 0x03
     882:	28 2f       	mov	r18, r24
     884:	30 e0       	ldi	r19, 0x00	; 0
     886:	81 e0       	ldi	r24, 0x01	; 1
     888:	90 e0       	ldi	r25, 0x00	; 0
     88a:	02 c0       	rjmp	.+4      	; 0x890 <__stack+0x31>
     88c:	88 0f       	add	r24, r24
     88e:	99 1f       	adc	r25, r25
     890:	2a 95       	dec	r18
     892:	e2 f7       	brpl	.-8      	; 0x88c <__stack+0x2d>
     894:	80 95       	com	r24
     896:	84 23       	and	r24, r20
     898:	8c 93       	st	X, r24
				SET_BIT(PORTB_Register,Copy_u8PIN);
     89a:	a8 e3       	ldi	r26, 0x38	; 56
     89c:	b0 e0       	ldi	r27, 0x00	; 0
     89e:	e8 e3       	ldi	r30, 0x38	; 56
     8a0:	f0 e0       	ldi	r31, 0x00	; 0
     8a2:	80 81       	ld	r24, Z
     8a4:	48 2f       	mov	r20, r24
     8a6:	8b 81       	ldd	r24, Y+3	; 0x03
     8a8:	28 2f       	mov	r18, r24
     8aa:	30 e0       	ldi	r19, 0x00	; 0
     8ac:	81 e0       	ldi	r24, 0x01	; 1
     8ae:	90 e0       	ldi	r25, 0x00	; 0
     8b0:	02 2e       	mov	r0, r18
     8b2:	02 c0       	rjmp	.+4      	; 0x8b8 <__stack+0x59>
     8b4:	88 0f       	add	r24, r24
     8b6:	99 1f       	adc	r25, r25
     8b8:	0a 94       	dec	r0
     8ba:	e2 f7       	brpl	.-8      	; 0x8b4 <__stack+0x55>
     8bc:	84 2b       	or	r24, r20
     8be:	8c 93       	st	X, r24
     8c0:	a2 c0       	rjmp	.+324    	; 0xa06 <__stack+0x1a7>
			}
			else
			{
				CLR_BIT(PORTB_Register,Copy_u8PIN);
     8c2:	a8 e3       	ldi	r26, 0x38	; 56
     8c4:	b0 e0       	ldi	r27, 0x00	; 0
     8c6:	e8 e3       	ldi	r30, 0x38	; 56
     8c8:	f0 e0       	ldi	r31, 0x00	; 0
     8ca:	80 81       	ld	r24, Z
     8cc:	48 2f       	mov	r20, r24
     8ce:	8b 81       	ldd	r24, Y+3	; 0x03
     8d0:	28 2f       	mov	r18, r24
     8d2:	30 e0       	ldi	r19, 0x00	; 0
     8d4:	81 e0       	ldi	r24, 0x01	; 1
     8d6:	90 e0       	ldi	r25, 0x00	; 0
     8d8:	02 2e       	mov	r0, r18
     8da:	02 c0       	rjmp	.+4      	; 0x8e0 <__stack+0x81>
     8dc:	88 0f       	add	r24, r24
     8de:	99 1f       	adc	r25, r25
     8e0:	0a 94       	dec	r0
     8e2:	e2 f7       	brpl	.-8      	; 0x8dc <__stack+0x7d>
     8e4:	80 95       	com	r24
     8e6:	84 23       	and	r24, r20
     8e8:	8c 93       	st	X, r24
     8ea:	8d c0       	rjmp	.+282    	; 0xa06 <__stack+0x1a7>
			}
			break;
			/* Connect or disconnect the pull up resistance to the given pin in port C */
		case DIO_PORTC:
			if(Copy_u8ConnectPullup==DIO_PIN_HIGH)
     8ec:	8c 81       	ldd	r24, Y+4	; 0x04
     8ee:	81 30       	cpi	r24, 0x01	; 1
     8f0:	71 f5       	brne	.+92     	; 0x94e <__stack+0xef>
			{
				CLR_BIT(SFIOR,PUD);
     8f2:	a0 e5       	ldi	r26, 0x50	; 80
     8f4:	b0 e0       	ldi	r27, 0x00	; 0
     8f6:	e0 e5       	ldi	r30, 0x50	; 80
     8f8:	f0 e0       	ldi	r31, 0x00	; 0
     8fa:	80 81       	ld	r24, Z
     8fc:	8b 7f       	andi	r24, 0xFB	; 251
     8fe:	8c 93       	st	X, r24
				CLR_BIT(DDRC_Register,Copy_u8PIN);
     900:	a4 e3       	ldi	r26, 0x34	; 52
     902:	b0 e0       	ldi	r27, 0x00	; 0
     904:	e4 e3       	ldi	r30, 0x34	; 52
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	80 81       	ld	r24, Z
     90a:	48 2f       	mov	r20, r24
     90c:	8b 81       	ldd	r24, Y+3	; 0x03
     90e:	28 2f       	mov	r18, r24
     910:	30 e0       	ldi	r19, 0x00	; 0
     912:	81 e0       	ldi	r24, 0x01	; 1
     914:	90 e0       	ldi	r25, 0x00	; 0
     916:	02 c0       	rjmp	.+4      	; 0x91c <__stack+0xbd>
     918:	88 0f       	add	r24, r24
     91a:	99 1f       	adc	r25, r25
     91c:	2a 95       	dec	r18
     91e:	e2 f7       	brpl	.-8      	; 0x918 <__stack+0xb9>
     920:	80 95       	com	r24
     922:	84 23       	and	r24, r20
     924:	8c 93       	st	X, r24
				SET_BIT(PORTC_Register,Copy_u8PIN);
     926:	a5 e3       	ldi	r26, 0x35	; 53
     928:	b0 e0       	ldi	r27, 0x00	; 0
     92a:	e5 e3       	ldi	r30, 0x35	; 53
     92c:	f0 e0       	ldi	r31, 0x00	; 0
     92e:	80 81       	ld	r24, Z
     930:	48 2f       	mov	r20, r24
     932:	8b 81       	ldd	r24, Y+3	; 0x03
     934:	28 2f       	mov	r18, r24
     936:	30 e0       	ldi	r19, 0x00	; 0
     938:	81 e0       	ldi	r24, 0x01	; 1
     93a:	90 e0       	ldi	r25, 0x00	; 0
     93c:	02 2e       	mov	r0, r18
     93e:	02 c0       	rjmp	.+4      	; 0x944 <__stack+0xe5>
     940:	88 0f       	add	r24, r24
     942:	99 1f       	adc	r25, r25
     944:	0a 94       	dec	r0
     946:	e2 f7       	brpl	.-8      	; 0x940 <__stack+0xe1>
     948:	84 2b       	or	r24, r20
     94a:	8c 93       	st	X, r24
     94c:	5c c0       	rjmp	.+184    	; 0xa06 <__stack+0x1a7>
			}
			else
			{
				CLR_BIT(PORTC_Register,Copy_u8PIN);
     94e:	a5 e3       	ldi	r26, 0x35	; 53
     950:	b0 e0       	ldi	r27, 0x00	; 0
     952:	e5 e3       	ldi	r30, 0x35	; 53
     954:	f0 e0       	ldi	r31, 0x00	; 0
     956:	80 81       	ld	r24, Z
     958:	48 2f       	mov	r20, r24
     95a:	8b 81       	ldd	r24, Y+3	; 0x03
     95c:	28 2f       	mov	r18, r24
     95e:	30 e0       	ldi	r19, 0x00	; 0
     960:	81 e0       	ldi	r24, 0x01	; 1
     962:	90 e0       	ldi	r25, 0x00	; 0
     964:	02 2e       	mov	r0, r18
     966:	02 c0       	rjmp	.+4      	; 0x96c <__stack+0x10d>
     968:	88 0f       	add	r24, r24
     96a:	99 1f       	adc	r25, r25
     96c:	0a 94       	dec	r0
     96e:	e2 f7       	brpl	.-8      	; 0x968 <__stack+0x109>
     970:	80 95       	com	r24
     972:	84 23       	and	r24, r20
     974:	8c 93       	st	X, r24
     976:	47 c0       	rjmp	.+142    	; 0xa06 <__stack+0x1a7>
			}
			break;
			/* Connect or disconnect the pull up resistance to the given pin in port D */
		case DIO_PORTD:
			if(Copy_u8ConnectPullup==DIO_PIN_HIGH)
     978:	8c 81       	ldd	r24, Y+4	; 0x04
     97a:	81 30       	cpi	r24, 0x01	; 1
     97c:	71 f5       	brne	.+92     	; 0x9da <__stack+0x17b>
			{
				CLR_BIT(SFIOR,PUD);
     97e:	a0 e5       	ldi	r26, 0x50	; 80
     980:	b0 e0       	ldi	r27, 0x00	; 0
     982:	e0 e5       	ldi	r30, 0x50	; 80
     984:	f0 e0       	ldi	r31, 0x00	; 0
     986:	80 81       	ld	r24, Z
     988:	8b 7f       	andi	r24, 0xFB	; 251
     98a:	8c 93       	st	X, r24
				CLR_BIT(DDRD_Register,Copy_u8PIN);
     98c:	a1 e3       	ldi	r26, 0x31	; 49
     98e:	b0 e0       	ldi	r27, 0x00	; 0
     990:	e1 e3       	ldi	r30, 0x31	; 49
     992:	f0 e0       	ldi	r31, 0x00	; 0
     994:	80 81       	ld	r24, Z
     996:	48 2f       	mov	r20, r24
     998:	8b 81       	ldd	r24, Y+3	; 0x03
     99a:	28 2f       	mov	r18, r24
     99c:	30 e0       	ldi	r19, 0x00	; 0
     99e:	81 e0       	ldi	r24, 0x01	; 1
     9a0:	90 e0       	ldi	r25, 0x00	; 0
     9a2:	02 c0       	rjmp	.+4      	; 0x9a8 <__stack+0x149>
     9a4:	88 0f       	add	r24, r24
     9a6:	99 1f       	adc	r25, r25
     9a8:	2a 95       	dec	r18
     9aa:	e2 f7       	brpl	.-8      	; 0x9a4 <__stack+0x145>
     9ac:	80 95       	com	r24
     9ae:	84 23       	and	r24, r20
     9b0:	8c 93       	st	X, r24
				SET_BIT(PORTD_Register,Copy_u8PIN);
     9b2:	a2 e3       	ldi	r26, 0x32	; 50
     9b4:	b0 e0       	ldi	r27, 0x00	; 0
     9b6:	e2 e3       	ldi	r30, 0x32	; 50
     9b8:	f0 e0       	ldi	r31, 0x00	; 0
     9ba:	80 81       	ld	r24, Z
     9bc:	48 2f       	mov	r20, r24
     9be:	8b 81       	ldd	r24, Y+3	; 0x03
     9c0:	28 2f       	mov	r18, r24
     9c2:	30 e0       	ldi	r19, 0x00	; 0
     9c4:	81 e0       	ldi	r24, 0x01	; 1
     9c6:	90 e0       	ldi	r25, 0x00	; 0
     9c8:	02 2e       	mov	r0, r18
     9ca:	02 c0       	rjmp	.+4      	; 0x9d0 <__stack+0x171>
     9cc:	88 0f       	add	r24, r24
     9ce:	99 1f       	adc	r25, r25
     9d0:	0a 94       	dec	r0
     9d2:	e2 f7       	brpl	.-8      	; 0x9cc <__stack+0x16d>
     9d4:	84 2b       	or	r24, r20
     9d6:	8c 93       	st	X, r24
     9d8:	16 c0       	rjmp	.+44     	; 0xa06 <__stack+0x1a7>
			}
			else
			{
				CLR_BIT(PORTD_Register,Copy_u8PIN);
     9da:	a2 e3       	ldi	r26, 0x32	; 50
     9dc:	b0 e0       	ldi	r27, 0x00	; 0
     9de:	e2 e3       	ldi	r30, 0x32	; 50
     9e0:	f0 e0       	ldi	r31, 0x00	; 0
     9e2:	80 81       	ld	r24, Z
     9e4:	48 2f       	mov	r20, r24
     9e6:	8b 81       	ldd	r24, Y+3	; 0x03
     9e8:	28 2f       	mov	r18, r24
     9ea:	30 e0       	ldi	r19, 0x00	; 0
     9ec:	81 e0       	ldi	r24, 0x01	; 1
     9ee:	90 e0       	ldi	r25, 0x00	; 0
     9f0:	02 2e       	mov	r0, r18
     9f2:	02 c0       	rjmp	.+4      	; 0x9f8 <__stack+0x199>
     9f4:	88 0f       	add	r24, r24
     9f6:	99 1f       	adc	r25, r25
     9f8:	0a 94       	dec	r0
     9fa:	e2 f7       	brpl	.-8      	; 0x9f4 <__stack+0x195>
     9fc:	80 95       	com	r24
     9fe:	84 23       	and	r24, r20
     a00:	8c 93       	st	X, r24
     a02:	01 c0       	rjmp	.+2      	; 0xa06 <__stack+0x1a7>
		}
	}

	else
	{
		LOC_enumState = DIO_NOK ;
     a04:	19 82       	std	Y+1, r1	; 0x01
	}

	return LOC_enumState ;
     a06:	89 81       	ldd	r24, Y+1	; 0x01


}
     a08:	26 96       	adiw	r28, 0x06	; 6
     a0a:	0f b6       	in	r0, 0x3f	; 63
     a0c:	f8 94       	cli
     a0e:	de bf       	out	0x3e, r29	; 62
     a10:	0f be       	out	0x3f, r0	; 63
     a12:	cd bf       	out	0x3d, r28	; 61
     a14:	cf 91       	pop	r28
     a16:	df 91       	pop	r29
     a18:	08 95       	ret

00000a1a <DIO_enumSetPortDirection>:
 	  =>Copy_u8PORT --> Port Name [ DIO_PORTA , DIO_PORTB , DIO_PORTC , DIO_PORTD ]
 	  =>Copy_u8Direction  --> Port direction [ DIO_PORT_OUTPUT , DIO_PORT_INPUT ]
 * return :  its status
 */
DIO_ErrorStatus DIO_enumSetPortDirection   (u8 Copy_u8PORT , u8 Copy_u8Direction ) 
{
     a1a:	df 93       	push	r29
     a1c:	cf 93       	push	r28
     a1e:	00 d0       	rcall	.+0      	; 0xa20 <DIO_enumSetPortDirection+0x6>
     a20:	00 d0       	rcall	.+0      	; 0xa22 <DIO_enumSetPortDirection+0x8>
     a22:	0f 92       	push	r0
     a24:	cd b7       	in	r28, 0x3d	; 61
     a26:	de b7       	in	r29, 0x3e	; 62
     a28:	8a 83       	std	Y+2, r24	; 0x02
     a2a:	6b 83       	std	Y+3, r22	; 0x03

	DIO_ErrorStatus LOC_enumState = DIO_OK ;
     a2c:	81 e0       	ldi	r24, 0x01	; 1
     a2e:	89 83       	std	Y+1, r24	; 0x01

	if ( (Copy_u8PORT <= DIO_PORTD) )
     a30:	8a 81       	ldd	r24, Y+2	; 0x02
     a32:	84 30       	cpi	r24, 0x04	; 4
     a34:	a8 f5       	brcc	.+106    	; 0xaa0 <DIO_enumSetPortDirection+0x86>
	{
		/* Check on the Required PORT Number */
		switch (Copy_u8PORT)
     a36:	8a 81       	ldd	r24, Y+2	; 0x02
     a38:	28 2f       	mov	r18, r24
     a3a:	30 e0       	ldi	r19, 0x00	; 0
     a3c:	3d 83       	std	Y+5, r19	; 0x05
     a3e:	2c 83       	std	Y+4, r18	; 0x04
     a40:	8c 81       	ldd	r24, Y+4	; 0x04
     a42:	9d 81       	ldd	r25, Y+5	; 0x05
     a44:	81 30       	cpi	r24, 0x01	; 1
     a46:	91 05       	cpc	r25, r1
     a48:	d1 f0       	breq	.+52     	; 0xa7e <DIO_enumSetPortDirection+0x64>
     a4a:	2c 81       	ldd	r18, Y+4	; 0x04
     a4c:	3d 81       	ldd	r19, Y+5	; 0x05
     a4e:	22 30       	cpi	r18, 0x02	; 2
     a50:	31 05       	cpc	r19, r1
     a52:	2c f4       	brge	.+10     	; 0xa5e <DIO_enumSetPortDirection+0x44>
     a54:	8c 81       	ldd	r24, Y+4	; 0x04
     a56:	9d 81       	ldd	r25, Y+5	; 0x05
     a58:	00 97       	sbiw	r24, 0x00	; 0
     a5a:	61 f0       	breq	.+24     	; 0xa74 <DIO_enumSetPortDirection+0x5a>
     a5c:	1f c0       	rjmp	.+62     	; 0xa9c <DIO_enumSetPortDirection+0x82>
     a5e:	2c 81       	ldd	r18, Y+4	; 0x04
     a60:	3d 81       	ldd	r19, Y+5	; 0x05
     a62:	22 30       	cpi	r18, 0x02	; 2
     a64:	31 05       	cpc	r19, r1
     a66:	81 f0       	breq	.+32     	; 0xa88 <DIO_enumSetPortDirection+0x6e>
     a68:	8c 81       	ldd	r24, Y+4	; 0x04
     a6a:	9d 81       	ldd	r25, Y+5	; 0x05
     a6c:	83 30       	cpi	r24, 0x03	; 3
     a6e:	91 05       	cpc	r25, r1
     a70:	81 f0       	breq	.+32     	; 0xa92 <DIO_enumSetPortDirection+0x78>
     a72:	14 c0       	rjmp	.+40     	; 0xa9c <DIO_enumSetPortDirection+0x82>
		{
		case     DIO_PORTA: DDRA_Register = Copy_u8Direction; break;
     a74:	ea e3       	ldi	r30, 0x3A	; 58
     a76:	f0 e0       	ldi	r31, 0x00	; 0
     a78:	8b 81       	ldd	r24, Y+3	; 0x03
     a7a:	80 83       	st	Z, r24
     a7c:	12 c0       	rjmp	.+36     	; 0xaa2 <DIO_enumSetPortDirection+0x88>
		case     DIO_PORTB: DDRB_Register = Copy_u8Direction; break;
     a7e:	e7 e3       	ldi	r30, 0x37	; 55
     a80:	f0 e0       	ldi	r31, 0x00	; 0
     a82:	8b 81       	ldd	r24, Y+3	; 0x03
     a84:	80 83       	st	Z, r24
     a86:	0d c0       	rjmp	.+26     	; 0xaa2 <DIO_enumSetPortDirection+0x88>
		case     DIO_PORTC: DDRC_Register = Copy_u8Direction; break;
     a88:	e4 e3       	ldi	r30, 0x34	; 52
     a8a:	f0 e0       	ldi	r31, 0x00	; 0
     a8c:	8b 81       	ldd	r24, Y+3	; 0x03
     a8e:	80 83       	st	Z, r24
     a90:	08 c0       	rjmp	.+16     	; 0xaa2 <DIO_enumSetPortDirection+0x88>
		case     DIO_PORTD: DDRD_Register = Copy_u8Direction; break;
     a92:	e1 e3       	ldi	r30, 0x31	; 49
     a94:	f0 e0       	ldi	r31, 0x00	; 0
     a96:	8b 81       	ldd	r24, Y+3	; 0x03
     a98:	80 83       	st	Z, r24
     a9a:	03 c0       	rjmp	.+6      	; 0xaa2 <DIO_enumSetPortDirection+0x88>
		default: LOC_enumState =  DIO_NOK;    break;
     a9c:	19 82       	std	Y+1, r1	; 0x01
     a9e:	01 c0       	rjmp	.+2      	; 0xaa2 <DIO_enumSetPortDirection+0x88>
		}	
	}
	else
	{
		LOC_enumState = DIO_NOK;
     aa0:	19 82       	std	Y+1, r1	; 0x01
	}
	return LOC_enumState ;
     aa2:	89 81       	ldd	r24, Y+1	; 0x01
}
     aa4:	0f 90       	pop	r0
     aa6:	0f 90       	pop	r0
     aa8:	0f 90       	pop	r0
     aaa:	0f 90       	pop	r0
     aac:	0f 90       	pop	r0
     aae:	cf 91       	pop	r28
     ab0:	df 91       	pop	r29
     ab2:	08 95       	ret

00000ab4 <DIO_enumSetPortValue>:
  	  =>Copy_u8PORT --> Port Name [ DIO_PORTA , DIO_PORTB , DIO_PORTC , DIO_PORTD ]
 	  =>Copy_u8Value  --> The Value  [DIO_PORT_HIGH , DIO_PORT_LOW , Another Value]
 * return : its status
 */
DIO_ErrorStatus DIO_enumSetPortValue       (u8 Copy_u8PORT , u8 Copy_u8Value )
{
     ab4:	df 93       	push	r29
     ab6:	cf 93       	push	r28
     ab8:	00 d0       	rcall	.+0      	; 0xaba <DIO_enumSetPortValue+0x6>
     aba:	00 d0       	rcall	.+0      	; 0xabc <DIO_enumSetPortValue+0x8>
     abc:	0f 92       	push	r0
     abe:	cd b7       	in	r28, 0x3d	; 61
     ac0:	de b7       	in	r29, 0x3e	; 62
     ac2:	8a 83       	std	Y+2, r24	; 0x02
     ac4:	6b 83       	std	Y+3, r22	; 0x03

	DIO_ErrorStatus LOC_enumState = DIO_OK ;
     ac6:	81 e0       	ldi	r24, 0x01	; 1
     ac8:	89 83       	std	Y+1, r24	; 0x01

	if ( (Copy_u8PORT <= DIO_PORTD) && ( (Copy_u8Value<=255) || (Copy_u8Value==DIO_PORT_LOW) || (Copy_u8Value==DIO_PORT_HIGH) ) )
     aca:	8a 81       	ldd	r24, Y+2	; 0x02
     acc:	84 30       	cpi	r24, 0x04	; 4
     ace:	a8 f5       	brcc	.+106    	; 0xb3a <DIO_enumSetPortValue+0x86>
	{
		/* Check on the Required PORT Number */
		switch (Copy_u8PORT)
     ad0:	8a 81       	ldd	r24, Y+2	; 0x02
     ad2:	28 2f       	mov	r18, r24
     ad4:	30 e0       	ldi	r19, 0x00	; 0
     ad6:	3d 83       	std	Y+5, r19	; 0x05
     ad8:	2c 83       	std	Y+4, r18	; 0x04
     ada:	8c 81       	ldd	r24, Y+4	; 0x04
     adc:	9d 81       	ldd	r25, Y+5	; 0x05
     ade:	81 30       	cpi	r24, 0x01	; 1
     ae0:	91 05       	cpc	r25, r1
     ae2:	d1 f0       	breq	.+52     	; 0xb18 <DIO_enumSetPortValue+0x64>
     ae4:	2c 81       	ldd	r18, Y+4	; 0x04
     ae6:	3d 81       	ldd	r19, Y+5	; 0x05
     ae8:	22 30       	cpi	r18, 0x02	; 2
     aea:	31 05       	cpc	r19, r1
     aec:	2c f4       	brge	.+10     	; 0xaf8 <DIO_enumSetPortValue+0x44>
     aee:	8c 81       	ldd	r24, Y+4	; 0x04
     af0:	9d 81       	ldd	r25, Y+5	; 0x05
     af2:	00 97       	sbiw	r24, 0x00	; 0
     af4:	61 f0       	breq	.+24     	; 0xb0e <DIO_enumSetPortValue+0x5a>
     af6:	1f c0       	rjmp	.+62     	; 0xb36 <DIO_enumSetPortValue+0x82>
     af8:	2c 81       	ldd	r18, Y+4	; 0x04
     afa:	3d 81       	ldd	r19, Y+5	; 0x05
     afc:	22 30       	cpi	r18, 0x02	; 2
     afe:	31 05       	cpc	r19, r1
     b00:	81 f0       	breq	.+32     	; 0xb22 <DIO_enumSetPortValue+0x6e>
     b02:	8c 81       	ldd	r24, Y+4	; 0x04
     b04:	9d 81       	ldd	r25, Y+5	; 0x05
     b06:	83 30       	cpi	r24, 0x03	; 3
     b08:	91 05       	cpc	r25, r1
     b0a:	81 f0       	breq	.+32     	; 0xb2c <DIO_enumSetPortValue+0x78>
     b0c:	14 c0       	rjmp	.+40     	; 0xb36 <DIO_enumSetPortValue+0x82>
		{
		case     DIO_PORTA: PORTA_Register = Copy_u8Value; break;
     b0e:	eb e3       	ldi	r30, 0x3B	; 59
     b10:	f0 e0       	ldi	r31, 0x00	; 0
     b12:	8b 81       	ldd	r24, Y+3	; 0x03
     b14:	80 83       	st	Z, r24
     b16:	12 c0       	rjmp	.+36     	; 0xb3c <DIO_enumSetPortValue+0x88>
		case     DIO_PORTB: PORTB_Register = Copy_u8Value; break;
     b18:	e8 e3       	ldi	r30, 0x38	; 56
     b1a:	f0 e0       	ldi	r31, 0x00	; 0
     b1c:	8b 81       	ldd	r24, Y+3	; 0x03
     b1e:	80 83       	st	Z, r24
     b20:	0d c0       	rjmp	.+26     	; 0xb3c <DIO_enumSetPortValue+0x88>
		case     DIO_PORTC: PORTC_Register = Copy_u8Value; break;
     b22:	e5 e3       	ldi	r30, 0x35	; 53
     b24:	f0 e0       	ldi	r31, 0x00	; 0
     b26:	8b 81       	ldd	r24, Y+3	; 0x03
     b28:	80 83       	st	Z, r24
     b2a:	08 c0       	rjmp	.+16     	; 0xb3c <DIO_enumSetPortValue+0x88>
		case     DIO_PORTD: PORTD_Register = Copy_u8Value; break;
     b2c:	e2 e3       	ldi	r30, 0x32	; 50
     b2e:	f0 e0       	ldi	r31, 0x00	; 0
     b30:	8b 81       	ldd	r24, Y+3	; 0x03
     b32:	80 83       	st	Z, r24
     b34:	03 c0       	rjmp	.+6      	; 0xb3c <DIO_enumSetPortValue+0x88>
		default: LOC_enumState = DIO_NOK;       break;
     b36:	19 82       	std	Y+1, r1	; 0x01
     b38:	01 c0       	rjmp	.+2      	; 0xb3c <DIO_enumSetPortValue+0x88>
		}	
	}
	else
	{
		LOC_enumState = DIO_NOK;
     b3a:	19 82       	std	Y+1, r1	; 0x01
	}
	return LOC_enumState ;
     b3c:	89 81       	ldd	r24, Y+1	; 0x01
}
     b3e:	0f 90       	pop	r0
     b40:	0f 90       	pop	r0
     b42:	0f 90       	pop	r0
     b44:	0f 90       	pop	r0
     b46:	0f 90       	pop	r0
     b48:	cf 91       	pop	r28
     b4a:	df 91       	pop	r29
     b4c:	08 95       	ret

00000b4e <DIO_enumTogglePortValue>:
 * Parameters :
 	  =>Copy_u8PORT --> Port Name [ DIO_PORTA , DIO_PORTB , DIO_PORTC , DIO_PORTD ]
 * return : its status
 */
DIO_ErrorStatus DIO_enumTogglePortValue      (u8 Copy_u8PORT                       )
{
     b4e:	df 93       	push	r29
     b50:	cf 93       	push	r28
     b52:	00 d0       	rcall	.+0      	; 0xb54 <DIO_enumTogglePortValue+0x6>
     b54:	00 d0       	rcall	.+0      	; 0xb56 <DIO_enumTogglePortValue+0x8>
     b56:	cd b7       	in	r28, 0x3d	; 61
     b58:	de b7       	in	r29, 0x3e	; 62
     b5a:	8a 83       	std	Y+2, r24	; 0x02
	DIO_ErrorStatus LOC_enumState = DIO_OK ;
     b5c:	81 e0       	ldi	r24, 0x01	; 1
     b5e:	89 83       	std	Y+1, r24	; 0x01

	if (Copy_u8PORT <= DIO_PORTD)
     b60:	8a 81       	ldd	r24, Y+2	; 0x02
     b62:	84 30       	cpi	r24, 0x04	; 4
     b64:	08 f0       	brcs	.+2      	; 0xb68 <DIO_enumTogglePortValue+0x1a>
     b66:	3f c0       	rjmp	.+126    	; 0xbe6 <DIO_enumTogglePortValue+0x98>
	{
		switch (Copy_u8PORT)
     b68:	8a 81       	ldd	r24, Y+2	; 0x02
     b6a:	28 2f       	mov	r18, r24
     b6c:	30 e0       	ldi	r19, 0x00	; 0
     b6e:	3c 83       	std	Y+4, r19	; 0x04
     b70:	2b 83       	std	Y+3, r18	; 0x03
     b72:	8b 81       	ldd	r24, Y+3	; 0x03
     b74:	9c 81       	ldd	r25, Y+4	; 0x04
     b76:	81 30       	cpi	r24, 0x01	; 1
     b78:	91 05       	cpc	r25, r1
     b7a:	e9 f0       	breq	.+58     	; 0xbb6 <DIO_enumTogglePortValue+0x68>
     b7c:	2b 81       	ldd	r18, Y+3	; 0x03
     b7e:	3c 81       	ldd	r19, Y+4	; 0x04
     b80:	22 30       	cpi	r18, 0x02	; 2
     b82:	31 05       	cpc	r19, r1
     b84:	2c f4       	brge	.+10     	; 0xb90 <DIO_enumTogglePortValue+0x42>
     b86:	8b 81       	ldd	r24, Y+3	; 0x03
     b88:	9c 81       	ldd	r25, Y+4	; 0x04
     b8a:	00 97       	sbiw	r24, 0x00	; 0
     b8c:	61 f0       	breq	.+24     	; 0xba6 <DIO_enumTogglePortValue+0x58>
     b8e:	2c c0       	rjmp	.+88     	; 0xbe8 <DIO_enumTogglePortValue+0x9a>
     b90:	2b 81       	ldd	r18, Y+3	; 0x03
     b92:	3c 81       	ldd	r19, Y+4	; 0x04
     b94:	22 30       	cpi	r18, 0x02	; 2
     b96:	31 05       	cpc	r19, r1
     b98:	b1 f0       	breq	.+44     	; 0xbc6 <DIO_enumTogglePortValue+0x78>
     b9a:	8b 81       	ldd	r24, Y+3	; 0x03
     b9c:	9c 81       	ldd	r25, Y+4	; 0x04
     b9e:	83 30       	cpi	r24, 0x03	; 3
     ba0:	91 05       	cpc	r25, r1
     ba2:	c9 f0       	breq	.+50     	; 0xbd6 <DIO_enumTogglePortValue+0x88>
     ba4:	21 c0       	rjmp	.+66     	; 0xbe8 <DIO_enumTogglePortValue+0x9a>
		{
		case DIO_PORTA : PORTA_Register = ~PORTA_Register ;
     ba6:	ab e3       	ldi	r26, 0x3B	; 59
     ba8:	b0 e0       	ldi	r27, 0x00	; 0
     baa:	eb e3       	ldi	r30, 0x3B	; 59
     bac:	f0 e0       	ldi	r31, 0x00	; 0
     bae:	80 81       	ld	r24, Z
     bb0:	80 95       	com	r24
     bb2:	8c 93       	st	X, r24
     bb4:	19 c0       	rjmp	.+50     	; 0xbe8 <DIO_enumTogglePortValue+0x9a>
		break ;
		case DIO_PORTB : PORTB_Register = ~PORTB_Register ;
     bb6:	a8 e3       	ldi	r26, 0x38	; 56
     bb8:	b0 e0       	ldi	r27, 0x00	; 0
     bba:	e8 e3       	ldi	r30, 0x38	; 56
     bbc:	f0 e0       	ldi	r31, 0x00	; 0
     bbe:	80 81       	ld	r24, Z
     bc0:	80 95       	com	r24
     bc2:	8c 93       	st	X, r24
     bc4:	11 c0       	rjmp	.+34     	; 0xbe8 <DIO_enumTogglePortValue+0x9a>
		break ;
		case DIO_PORTC : PORTC_Register = ~PORTC_Register ;
     bc6:	a5 e3       	ldi	r26, 0x35	; 53
     bc8:	b0 e0       	ldi	r27, 0x00	; 0
     bca:	e5 e3       	ldi	r30, 0x35	; 53
     bcc:	f0 e0       	ldi	r31, 0x00	; 0
     bce:	80 81       	ld	r24, Z
     bd0:	80 95       	com	r24
     bd2:	8c 93       	st	X, r24
     bd4:	09 c0       	rjmp	.+18     	; 0xbe8 <DIO_enumTogglePortValue+0x9a>
		break ;
		case DIO_PORTD : PORTD_Register = ~PORTD_Register ;
     bd6:	a2 e3       	ldi	r26, 0x32	; 50
     bd8:	b0 e0       	ldi	r27, 0x00	; 0
     bda:	e2 e3       	ldi	r30, 0x32	; 50
     bdc:	f0 e0       	ldi	r31, 0x00	; 0
     bde:	80 81       	ld	r24, Z
     be0:	80 95       	com	r24
     be2:	8c 93       	st	X, r24
     be4:	01 c0       	rjmp	.+2      	; 0xbe8 <DIO_enumTogglePortValue+0x9a>
		break ;
		}
	}
	else
	{
		LOC_enumState = DIO_NOK;
     be6:	19 82       	std	Y+1, r1	; 0x01
	}
	return LOC_enumState ;
     be8:	89 81       	ldd	r24, Y+1	; 0x01
}
     bea:	0f 90       	pop	r0
     bec:	0f 90       	pop	r0
     bee:	0f 90       	pop	r0
     bf0:	0f 90       	pop	r0
     bf2:	cf 91       	pop	r28
     bf4:	df 91       	pop	r29
     bf6:	08 95       	ret

00000bf8 <DIO_enumGetPortValue>:
 	  =>Copy_u8PORT --> Port Name [ DIO_PORTA , DIO_PORTB , DIO_PORTC , DIO_PORTD ]
 	  => *Copy_PtrData  --> pointer to recieve the port value
 * return : its status and recieve Port Value in pointer
 */
DIO_ErrorStatus   DIO_enumGetPortValue         ( u8 Copy_u8PORT  , u8 * Copy_PtrData )
{
     bf8:	df 93       	push	r29
     bfa:	cf 93       	push	r28
     bfc:	00 d0       	rcall	.+0      	; 0xbfe <DIO_enumGetPortValue+0x6>
     bfe:	00 d0       	rcall	.+0      	; 0xc00 <DIO_enumGetPortValue+0x8>
     c00:	00 d0       	rcall	.+0      	; 0xc02 <DIO_enumGetPortValue+0xa>
     c02:	cd b7       	in	r28, 0x3d	; 61
     c04:	de b7       	in	r29, 0x3e	; 62
     c06:	8a 83       	std	Y+2, r24	; 0x02
     c08:	7c 83       	std	Y+4, r23	; 0x04
     c0a:	6b 83       	std	Y+3, r22	; 0x03

	DIO_ErrorStatus LOC_enumState = DIO_OK ;
     c0c:	81 e0       	ldi	r24, 0x01	; 1
     c0e:	89 83       	std	Y+1, r24	; 0x01

	if ( (Copy_u8PORT <= DIO_PORTD))
     c10:	8a 81       	ldd	r24, Y+2	; 0x02
     c12:	84 30       	cpi	r24, 0x04	; 4
     c14:	e8 f5       	brcc	.+122    	; 0xc90 <DIO_enumGetPortValue+0x98>
	{
		switch (Copy_u8PORT)
     c16:	8a 81       	ldd	r24, Y+2	; 0x02
     c18:	28 2f       	mov	r18, r24
     c1a:	30 e0       	ldi	r19, 0x00	; 0
     c1c:	3e 83       	std	Y+6, r19	; 0x06
     c1e:	2d 83       	std	Y+5, r18	; 0x05
     c20:	8d 81       	ldd	r24, Y+5	; 0x05
     c22:	9e 81       	ldd	r25, Y+6	; 0x06
     c24:	81 30       	cpi	r24, 0x01	; 1
     c26:	91 05       	cpc	r25, r1
     c28:	e1 f0       	breq	.+56     	; 0xc62 <DIO_enumGetPortValue+0x6a>
     c2a:	2d 81       	ldd	r18, Y+5	; 0x05
     c2c:	3e 81       	ldd	r19, Y+6	; 0x06
     c2e:	22 30       	cpi	r18, 0x02	; 2
     c30:	31 05       	cpc	r19, r1
     c32:	2c f4       	brge	.+10     	; 0xc3e <DIO_enumGetPortValue+0x46>
     c34:	8d 81       	ldd	r24, Y+5	; 0x05
     c36:	9e 81       	ldd	r25, Y+6	; 0x06
     c38:	00 97       	sbiw	r24, 0x00	; 0
     c3a:	61 f0       	breq	.+24     	; 0xc54 <DIO_enumGetPortValue+0x5c>
     c3c:	27 c0       	rjmp	.+78     	; 0xc8c <DIO_enumGetPortValue+0x94>
     c3e:	2d 81       	ldd	r18, Y+5	; 0x05
     c40:	3e 81       	ldd	r19, Y+6	; 0x06
     c42:	22 30       	cpi	r18, 0x02	; 2
     c44:	31 05       	cpc	r19, r1
     c46:	a1 f0       	breq	.+40     	; 0xc70 <DIO_enumGetPortValue+0x78>
     c48:	8d 81       	ldd	r24, Y+5	; 0x05
     c4a:	9e 81       	ldd	r25, Y+6	; 0x06
     c4c:	83 30       	cpi	r24, 0x03	; 3
     c4e:	91 05       	cpc	r25, r1
     c50:	b1 f0       	breq	.+44     	; 0xc7e <DIO_enumGetPortValue+0x86>
     c52:	1c c0       	rjmp	.+56     	; 0xc8c <DIO_enumGetPortValue+0x94>
		{
		case DIO_PORTA :
			*Copy_PtrData = PINA_Register  ;
     c54:	e9 e3       	ldi	r30, 0x39	; 57
     c56:	f0 e0       	ldi	r31, 0x00	; 0
     c58:	80 81       	ld	r24, Z
     c5a:	eb 81       	ldd	r30, Y+3	; 0x03
     c5c:	fc 81       	ldd	r31, Y+4	; 0x04
     c5e:	80 83       	st	Z, r24
     c60:	18 c0       	rjmp	.+48     	; 0xc92 <DIO_enumGetPortValue+0x9a>
			break ;
		case DIO_PORTB :
			*Copy_PtrData = PINB_Register  ;
     c62:	e6 e3       	ldi	r30, 0x36	; 54
     c64:	f0 e0       	ldi	r31, 0x00	; 0
     c66:	80 81       	ld	r24, Z
     c68:	eb 81       	ldd	r30, Y+3	; 0x03
     c6a:	fc 81       	ldd	r31, Y+4	; 0x04
     c6c:	80 83       	st	Z, r24
     c6e:	11 c0       	rjmp	.+34     	; 0xc92 <DIO_enumGetPortValue+0x9a>
			break ;
		case DIO_PORTC :
			*Copy_PtrData = PINC_Register  ;
     c70:	e3 e3       	ldi	r30, 0x33	; 51
     c72:	f0 e0       	ldi	r31, 0x00	; 0
     c74:	80 81       	ld	r24, Z
     c76:	eb 81       	ldd	r30, Y+3	; 0x03
     c78:	fc 81       	ldd	r31, Y+4	; 0x04
     c7a:	80 83       	st	Z, r24
     c7c:	0a c0       	rjmp	.+20     	; 0xc92 <DIO_enumGetPortValue+0x9a>
			break ;
		case DIO_PORTD :
			*Copy_PtrData = PIND_Register  ;
     c7e:	e0 e3       	ldi	r30, 0x30	; 48
     c80:	f0 e0       	ldi	r31, 0x00	; 0
     c82:	80 81       	ld	r24, Z
     c84:	eb 81       	ldd	r30, Y+3	; 0x03
     c86:	fc 81       	ldd	r31, Y+4	; 0x04
     c88:	80 83       	st	Z, r24
     c8a:	03 c0       	rjmp	.+6      	; 0xc92 <DIO_enumGetPortValue+0x9a>
			break ;
		default : LOC_enumState = DIO_NOK ;
     c8c:	19 82       	std	Y+1, r1	; 0x01
     c8e:	01 c0       	rjmp	.+2      	; 0xc92 <DIO_enumGetPortValue+0x9a>
		break;
		}
	}
	else
	{
		LOC_enumState = DIO_NOK;
     c90:	19 82       	std	Y+1, r1	; 0x01
	}

	return LOC_enumState ;
     c92:	89 81       	ldd	r24, Y+1	; 0x01
}
     c94:	26 96       	adiw	r28, 0x06	; 6
     c96:	0f b6       	in	r0, 0x3f	; 63
     c98:	f8 94       	cli
     c9a:	de bf       	out	0x3e, r29	; 62
     c9c:	0f be       	out	0x3f, r0	; 63
     c9e:	cd bf       	out	0x3d, r28	; 61
     ca0:	cf 91       	pop	r28
     ca2:	df 91       	pop	r29
     ca4:	08 95       	ret

00000ca6 <DIO_voidWriteHighNibbles>:
 *Hint1 : High Nibbles = Most Pins [4:7]
 *Hint2 : This Function take the first 4 bits from the value (#) => xxxx#### AND put it in high nobbles
 *
 */
DIO_ErrorStatus DIO_voidWriteHighNibbles(u8 Copy_u8PORT,u8 Copy_u8value)
{
     ca6:	df 93       	push	r29
     ca8:	cf 93       	push	r28
     caa:	00 d0       	rcall	.+0      	; 0xcac <DIO_voidWriteHighNibbles+0x6>
     cac:	00 d0       	rcall	.+0      	; 0xcae <DIO_voidWriteHighNibbles+0x8>
     cae:	0f 92       	push	r0
     cb0:	cd b7       	in	r28, 0x3d	; 61
     cb2:	de b7       	in	r29, 0x3e	; 62
     cb4:	8a 83       	std	Y+2, r24	; 0x02
     cb6:	6b 83       	std	Y+3, r22	; 0x03

	DIO_ErrorStatus LOC_enumState = DIO_OK ;
     cb8:	81 e0       	ldi	r24, 0x01	; 1
     cba:	89 83       	std	Y+1, r24	; 0x01

	if ( (Copy_u8PORT <= DIO_PORTD))
     cbc:	8a 81       	ldd	r24, Y+2	; 0x02
     cbe:	84 30       	cpi	r24, 0x04	; 4
     cc0:	08 f0       	brcs	.+2      	; 0xcc4 <DIO_voidWriteHighNibbles+0x1e>
     cc2:	63 c0       	rjmp	.+198    	; 0xd8a <DIO_voidWriteHighNibbles+0xe4>
	{
		Copy_u8value = (Copy_u8value<<4) ;
     cc4:	8b 81       	ldd	r24, Y+3	; 0x03
     cc6:	82 95       	swap	r24
     cc8:	80 7f       	andi	r24, 0xF0	; 240
     cca:	8b 83       	std	Y+3, r24	; 0x03
		switch(Copy_u8PORT)
     ccc:	8a 81       	ldd	r24, Y+2	; 0x02
     cce:	28 2f       	mov	r18, r24
     cd0:	30 e0       	ldi	r19, 0x00	; 0
     cd2:	3d 83       	std	Y+5, r19	; 0x05
     cd4:	2c 83       	std	Y+4, r18	; 0x04
     cd6:	8c 81       	ldd	r24, Y+4	; 0x04
     cd8:	9d 81       	ldd	r25, Y+5	; 0x05
     cda:	81 30       	cpi	r24, 0x01	; 1
     cdc:	91 05       	cpc	r25, r1
     cde:	29 f1       	breq	.+74     	; 0xd2a <DIO_voidWriteHighNibbles+0x84>
     ce0:	2c 81       	ldd	r18, Y+4	; 0x04
     ce2:	3d 81       	ldd	r19, Y+5	; 0x05
     ce4:	22 30       	cpi	r18, 0x02	; 2
     ce6:	31 05       	cpc	r19, r1
     ce8:	2c f4       	brge	.+10     	; 0xcf4 <DIO_voidWriteHighNibbles+0x4e>
     cea:	8c 81       	ldd	r24, Y+4	; 0x04
     cec:	9d 81       	ldd	r25, Y+5	; 0x05
     cee:	00 97       	sbiw	r24, 0x00	; 0
     cf0:	61 f0       	breq	.+24     	; 0xd0a <DIO_voidWriteHighNibbles+0x64>
     cf2:	4c c0       	rjmp	.+152    	; 0xd8c <DIO_voidWriteHighNibbles+0xe6>
     cf4:	2c 81       	ldd	r18, Y+4	; 0x04
     cf6:	3d 81       	ldd	r19, Y+5	; 0x05
     cf8:	22 30       	cpi	r18, 0x02	; 2
     cfa:	31 05       	cpc	r19, r1
     cfc:	31 f1       	breq	.+76     	; 0xd4a <DIO_voidWriteHighNibbles+0xa4>
     cfe:	8c 81       	ldd	r24, Y+4	; 0x04
     d00:	9d 81       	ldd	r25, Y+5	; 0x05
     d02:	83 30       	cpi	r24, 0x03	; 3
     d04:	91 05       	cpc	r25, r1
     d06:	89 f1       	breq	.+98     	; 0xd6a <DIO_voidWriteHighNibbles+0xc4>
     d08:	41 c0       	rjmp	.+130    	; 0xd8c <DIO_voidWriteHighNibbles+0xe6>
		{
		case DIO_PORTA :
			PORTA_Register&=0x0f;                   // make sure the high bits = 0000
     d0a:	ab e3       	ldi	r26, 0x3B	; 59
     d0c:	b0 e0       	ldi	r27, 0x00	; 0
     d0e:	eb e3       	ldi	r30, 0x3B	; 59
     d10:	f0 e0       	ldi	r31, 0x00	; 0
     d12:	80 81       	ld	r24, Z
     d14:	8f 70       	andi	r24, 0x0F	; 15
     d16:	8c 93       	st	X, r24
			PORTA_Register|=Copy_u8value;			//Set only the high nibble of the port A by the given value
     d18:	ab e3       	ldi	r26, 0x3B	; 59
     d1a:	b0 e0       	ldi	r27, 0x00	; 0
     d1c:	eb e3       	ldi	r30, 0x3B	; 59
     d1e:	f0 e0       	ldi	r31, 0x00	; 0
     d20:	90 81       	ld	r25, Z
     d22:	8b 81       	ldd	r24, Y+3	; 0x03
     d24:	89 2b       	or	r24, r25
     d26:	8c 93       	st	X, r24
     d28:	31 c0       	rjmp	.+98     	; 0xd8c <DIO_voidWriteHighNibbles+0xe6>
			break ;
		case DIO_PORTB:
			PORTB_Register&=0x0f;                 //Set only the high nibble of the port B by the given value
     d2a:	a8 e3       	ldi	r26, 0x38	; 56
     d2c:	b0 e0       	ldi	r27, 0x00	; 0
     d2e:	e8 e3       	ldi	r30, 0x38	; 56
     d30:	f0 e0       	ldi	r31, 0x00	; 0
     d32:	80 81       	ld	r24, Z
     d34:	8f 70       	andi	r24, 0x0F	; 15
     d36:	8c 93       	st	X, r24
			PORTB_Register|=Copy_u8value;
     d38:	a8 e3       	ldi	r26, 0x38	; 56
     d3a:	b0 e0       	ldi	r27, 0x00	; 0
     d3c:	e8 e3       	ldi	r30, 0x38	; 56
     d3e:	f0 e0       	ldi	r31, 0x00	; 0
     d40:	90 81       	ld	r25, Z
     d42:	8b 81       	ldd	r24, Y+3	; 0x03
     d44:	89 2b       	or	r24, r25
     d46:	8c 93       	st	X, r24
     d48:	21 c0       	rjmp	.+66     	; 0xd8c <DIO_voidWriteHighNibbles+0xe6>
			break ;
		case DIO_PORTC :
			PORTC_Register&=0x0f;                 //Set only the high nibble of the port C by the given value
     d4a:	a5 e3       	ldi	r26, 0x35	; 53
     d4c:	b0 e0       	ldi	r27, 0x00	; 0
     d4e:	e5 e3       	ldi	r30, 0x35	; 53
     d50:	f0 e0       	ldi	r31, 0x00	; 0
     d52:	80 81       	ld	r24, Z
     d54:	8f 70       	andi	r24, 0x0F	; 15
     d56:	8c 93       	st	X, r24
			PORTC_Register|=Copy_u8value;
     d58:	a5 e3       	ldi	r26, 0x35	; 53
     d5a:	b0 e0       	ldi	r27, 0x00	; 0
     d5c:	e5 e3       	ldi	r30, 0x35	; 53
     d5e:	f0 e0       	ldi	r31, 0x00	; 0
     d60:	90 81       	ld	r25, Z
     d62:	8b 81       	ldd	r24, Y+3	; 0x03
     d64:	89 2b       	or	r24, r25
     d66:	8c 93       	st	X, r24
     d68:	11 c0       	rjmp	.+34     	; 0xd8c <DIO_voidWriteHighNibbles+0xe6>
			break ;
		case DIO_PORTD:
			PORTD_Register&=0x0f;                 //Set only the high nibble of the port D by the given value
     d6a:	a2 e3       	ldi	r26, 0x32	; 50
     d6c:	b0 e0       	ldi	r27, 0x00	; 0
     d6e:	e2 e3       	ldi	r30, 0x32	; 50
     d70:	f0 e0       	ldi	r31, 0x00	; 0
     d72:	80 81       	ld	r24, Z
     d74:	8f 70       	andi	r24, 0x0F	; 15
     d76:	8c 93       	st	X, r24
			PORTD_Register|=Copy_u8value;
     d78:	a2 e3       	ldi	r26, 0x32	; 50
     d7a:	b0 e0       	ldi	r27, 0x00	; 0
     d7c:	e2 e3       	ldi	r30, 0x32	; 50
     d7e:	f0 e0       	ldi	r31, 0x00	; 0
     d80:	90 81       	ld	r25, Z
     d82:	8b 81       	ldd	r24, Y+3	; 0x03
     d84:	89 2b       	or	r24, r25
     d86:	8c 93       	st	X, r24
     d88:	01 c0       	rjmp	.+2      	; 0xd8c <DIO_voidWriteHighNibbles+0xe6>

		}
	}
	else
	{
		LOC_enumState = DIO_NOK;
     d8a:	19 82       	std	Y+1, r1	; 0x01
	}

	return LOC_enumState ;
     d8c:	89 81       	ldd	r24, Y+1	; 0x01

}
     d8e:	0f 90       	pop	r0
     d90:	0f 90       	pop	r0
     d92:	0f 90       	pop	r0
     d94:	0f 90       	pop	r0
     d96:	0f 90       	pop	r0
     d98:	cf 91       	pop	r28
     d9a:	df 91       	pop	r29
     d9c:	08 95       	ret

00000d9e <DIO_voidWriteLowNibbles>:
 *Hint1 : Low Nibbles = Least Pins [0:3]
 *Hint2 : This Function also take the first 4 bits from the value (#) => xxxx#### AND put it in low nobbles
 *
 */
DIO_ErrorStatus DIO_voidWriteLowNibbles(u8 Copy_u8PORT,u8 Copy_u8value)
{
     d9e:	df 93       	push	r29
     da0:	cf 93       	push	r28
     da2:	00 d0       	rcall	.+0      	; 0xda4 <DIO_voidWriteLowNibbles+0x6>
     da4:	00 d0       	rcall	.+0      	; 0xda6 <DIO_voidWriteLowNibbles+0x8>
     da6:	0f 92       	push	r0
     da8:	cd b7       	in	r28, 0x3d	; 61
     daa:	de b7       	in	r29, 0x3e	; 62
     dac:	8a 83       	std	Y+2, r24	; 0x02
     dae:	6b 83       	std	Y+3, r22	; 0x03
	DIO_ErrorStatus LOC_enumState = DIO_OK ;
     db0:	81 e0       	ldi	r24, 0x01	; 1
     db2:	89 83       	std	Y+1, r24	; 0x01


	if ( (Copy_u8PORT <= DIO_PORTD))
     db4:	8a 81       	ldd	r24, Y+2	; 0x02
     db6:	84 30       	cpi	r24, 0x04	; 4
     db8:	08 f0       	brcs	.+2      	; 0xdbc <DIO_voidWriteLowNibbles+0x1e>
     dba:	62 c0       	rjmp	.+196    	; 0xe80 <DIO_voidWriteLowNibbles+0xe2>
	{
		Copy_u8value&=0x0f;
     dbc:	8b 81       	ldd	r24, Y+3	; 0x03
     dbe:	8f 70       	andi	r24, 0x0F	; 15
     dc0:	8b 83       	std	Y+3, r24	; 0x03
		switch(Copy_u8PORT)
     dc2:	8a 81       	ldd	r24, Y+2	; 0x02
     dc4:	28 2f       	mov	r18, r24
     dc6:	30 e0       	ldi	r19, 0x00	; 0
     dc8:	3d 83       	std	Y+5, r19	; 0x05
     dca:	2c 83       	std	Y+4, r18	; 0x04
     dcc:	8c 81       	ldd	r24, Y+4	; 0x04
     dce:	9d 81       	ldd	r25, Y+5	; 0x05
     dd0:	81 30       	cpi	r24, 0x01	; 1
     dd2:	91 05       	cpc	r25, r1
     dd4:	29 f1       	breq	.+74     	; 0xe20 <DIO_voidWriteLowNibbles+0x82>
     dd6:	2c 81       	ldd	r18, Y+4	; 0x04
     dd8:	3d 81       	ldd	r19, Y+5	; 0x05
     dda:	22 30       	cpi	r18, 0x02	; 2
     ddc:	31 05       	cpc	r19, r1
     dde:	2c f4       	brge	.+10     	; 0xdea <DIO_voidWriteLowNibbles+0x4c>
     de0:	8c 81       	ldd	r24, Y+4	; 0x04
     de2:	9d 81       	ldd	r25, Y+5	; 0x05
     de4:	00 97       	sbiw	r24, 0x00	; 0
     de6:	61 f0       	breq	.+24     	; 0xe00 <DIO_voidWriteLowNibbles+0x62>
     de8:	4c c0       	rjmp	.+152    	; 0xe82 <DIO_voidWriteLowNibbles+0xe4>
     dea:	2c 81       	ldd	r18, Y+4	; 0x04
     dec:	3d 81       	ldd	r19, Y+5	; 0x05
     dee:	22 30       	cpi	r18, 0x02	; 2
     df0:	31 05       	cpc	r19, r1
     df2:	31 f1       	breq	.+76     	; 0xe40 <DIO_voidWriteLowNibbles+0xa2>
     df4:	8c 81       	ldd	r24, Y+4	; 0x04
     df6:	9d 81       	ldd	r25, Y+5	; 0x05
     df8:	83 30       	cpi	r24, 0x03	; 3
     dfa:	91 05       	cpc	r25, r1
     dfc:	89 f1       	breq	.+98     	; 0xe60 <DIO_voidWriteLowNibbles+0xc2>
     dfe:	41 c0       	rjmp	.+130    	; 0xe82 <DIO_voidWriteLowNibbles+0xe4>
		{
		case DIO_PORTA :
			PORTA_Register &= 0xf0;                 //Set only the high nibble of the port A by the given value
     e00:	ab e3       	ldi	r26, 0x3B	; 59
     e02:	b0 e0       	ldi	r27, 0x00	; 0
     e04:	eb e3       	ldi	r30, 0x3B	; 59
     e06:	f0 e0       	ldi	r31, 0x00	; 0
     e08:	80 81       	ld	r24, Z
     e0a:	80 7f       	andi	r24, 0xF0	; 240
     e0c:	8c 93       	st	X, r24
			PORTA_Register |= Copy_u8value;
     e0e:	ab e3       	ldi	r26, 0x3B	; 59
     e10:	b0 e0       	ldi	r27, 0x00	; 0
     e12:	eb e3       	ldi	r30, 0x3B	; 59
     e14:	f0 e0       	ldi	r31, 0x00	; 0
     e16:	90 81       	ld	r25, Z
     e18:	8b 81       	ldd	r24, Y+3	; 0x03
     e1a:	89 2b       	or	r24, r25
     e1c:	8c 93       	st	X, r24
     e1e:	31 c0       	rjmp	.+98     	; 0xe82 <DIO_voidWriteLowNibbles+0xe4>
			break ;
		case DIO_PORTB:
			PORTB_Register &= 0xf0;                 //Set only the high nibble of the port B by the given value
     e20:	a8 e3       	ldi	r26, 0x38	; 56
     e22:	b0 e0       	ldi	r27, 0x00	; 0
     e24:	e8 e3       	ldi	r30, 0x38	; 56
     e26:	f0 e0       	ldi	r31, 0x00	; 0
     e28:	80 81       	ld	r24, Z
     e2a:	80 7f       	andi	r24, 0xF0	; 240
     e2c:	8c 93       	st	X, r24
			PORTB_Register |= Copy_u8value;
     e2e:	a8 e3       	ldi	r26, 0x38	; 56
     e30:	b0 e0       	ldi	r27, 0x00	; 0
     e32:	e8 e3       	ldi	r30, 0x38	; 56
     e34:	f0 e0       	ldi	r31, 0x00	; 0
     e36:	90 81       	ld	r25, Z
     e38:	8b 81       	ldd	r24, Y+3	; 0x03
     e3a:	89 2b       	or	r24, r25
     e3c:	8c 93       	st	X, r24
     e3e:	21 c0       	rjmp	.+66     	; 0xe82 <DIO_voidWriteLowNibbles+0xe4>
			break ;
		case DIO_PORTC :
			PORTC_Register &= 0xf0;                 //Set only the high nibble of the port C by the given value
     e40:	a5 e3       	ldi	r26, 0x35	; 53
     e42:	b0 e0       	ldi	r27, 0x00	; 0
     e44:	e5 e3       	ldi	r30, 0x35	; 53
     e46:	f0 e0       	ldi	r31, 0x00	; 0
     e48:	80 81       	ld	r24, Z
     e4a:	80 7f       	andi	r24, 0xF0	; 240
     e4c:	8c 93       	st	X, r24
			PORTC_Register |= Copy_u8value;
     e4e:	a5 e3       	ldi	r26, 0x35	; 53
     e50:	b0 e0       	ldi	r27, 0x00	; 0
     e52:	e5 e3       	ldi	r30, 0x35	; 53
     e54:	f0 e0       	ldi	r31, 0x00	; 0
     e56:	90 81       	ld	r25, Z
     e58:	8b 81       	ldd	r24, Y+3	; 0x03
     e5a:	89 2b       	or	r24, r25
     e5c:	8c 93       	st	X, r24
     e5e:	11 c0       	rjmp	.+34     	; 0xe82 <DIO_voidWriteLowNibbles+0xe4>
			break ;
		case DIO_PORTD:
			PORTD_Register &= 0xf0;                 //Set only the high nibble of the port D by the given value
     e60:	a2 e3       	ldi	r26, 0x32	; 50
     e62:	b0 e0       	ldi	r27, 0x00	; 0
     e64:	e2 e3       	ldi	r30, 0x32	; 50
     e66:	f0 e0       	ldi	r31, 0x00	; 0
     e68:	80 81       	ld	r24, Z
     e6a:	80 7f       	andi	r24, 0xF0	; 240
     e6c:	8c 93       	st	X, r24
			PORTD_Register |= Copy_u8value;
     e6e:	a2 e3       	ldi	r26, 0x32	; 50
     e70:	b0 e0       	ldi	r27, 0x00	; 0
     e72:	e2 e3       	ldi	r30, 0x32	; 50
     e74:	f0 e0       	ldi	r31, 0x00	; 0
     e76:	90 81       	ld	r25, Z
     e78:	8b 81       	ldd	r24, Y+3	; 0x03
     e7a:	89 2b       	or	r24, r25
     e7c:	8c 93       	st	X, r24
     e7e:	01 c0       	rjmp	.+2      	; 0xe82 <DIO_voidWriteLowNibbles+0xe4>


	}
	else
	{
		LOC_enumState = DIO_NOK;
     e80:	19 82       	std	Y+1, r1	; 0x01
	}

	return LOC_enumState ;
     e82:	89 81       	ldd	r24, Y+1	; 0x01

}
     e84:	0f 90       	pop	r0
     e86:	0f 90       	pop	r0
     e88:	0f 90       	pop	r0
     e8a:	0f 90       	pop	r0
     e8c:	0f 90       	pop	r0
     e8e:	cf 91       	pop	r28
     e90:	df 91       	pop	r29
     e92:	08 95       	ret

00000e94 <PORT_voidInit>:
#include "PORT_private.h"
#include "PORT_interface.h"
#include "PORT_register.h"

void PORT_voidInit(void)
{
     e94:	df 93       	push	r29
     e96:	cf 93       	push	r28
     e98:	cd b7       	in	r28, 0x3d	; 61
     e9a:	de b7       	in	r29, 0x3e	; 62
	DDRA= PORTA_DIR;
     e9c:	ea e3       	ldi	r30, 0x3A	; 58
     e9e:	f0 e0       	ldi	r31, 0x00	; 0
     ea0:	87 e0       	ldi	r24, 0x07	; 7
     ea2:	80 83       	st	Z, r24
	DDRB= PORTB_DIR;
     ea4:	e7 e3       	ldi	r30, 0x37	; 55
     ea6:	f0 e0       	ldi	r31, 0x00	; 0
     ea8:	10 82       	st	Z, r1
	DDRC= PORTC_DIR;
     eaa:	e4 e3       	ldi	r30, 0x34	; 52
     eac:	f0 e0       	ldi	r31, 0x00	; 0
     eae:	10 82       	st	Z, r1
	DDRD= PORTD_DIR;
     eb0:	e1 e3       	ldi	r30, 0x31	; 49
     eb2:	f0 e0       	ldi	r31, 0x00	; 0
     eb4:	10 82       	st	Z, r1
	
	PORTA=PORTA_INITIAL_VALUE;
     eb6:	eb e3       	ldi	r30, 0x3B	; 59
     eb8:	f0 e0       	ldi	r31, 0x00	; 0
     eba:	87 e0       	ldi	r24, 0x07	; 7
     ebc:	80 83       	st	Z, r24
	PORTB=PORTB_INITIAL_VALUE;
     ebe:	e8 e3       	ldi	r30, 0x38	; 56
     ec0:	f0 e0       	ldi	r31, 0x00	; 0
     ec2:	10 82       	st	Z, r1
	PORTC=PORTC_INITIAL_VALUE;
     ec4:	e5 e3       	ldi	r30, 0x35	; 53
     ec6:	f0 e0       	ldi	r31, 0x00	; 0
     ec8:	10 82       	st	Z, r1
	PORTD=PORTD_INITIAL_VALUE;
     eca:	e2 e3       	ldi	r30, 0x32	; 50
     ecc:	f0 e0       	ldi	r31, 0x00	; 0
     ece:	10 82       	st	Z, r1
     ed0:	cf 91       	pop	r28
     ed2:	df 91       	pop	r29
     ed4:	08 95       	ret

00000ed6 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     ed6:	df 93       	push	r29
     ed8:	cf 93       	push	r28
     eda:	cd b7       	in	r28, 0x3d	; 61
     edc:	de b7       	in	r29, 0x3e	; 62
     ede:	27 97       	sbiw	r28, 0x07	; 7
     ee0:	0f b6       	in	r0, 0x3f	; 63
     ee2:	f8 94       	cli
     ee4:	de bf       	out	0x3e, r29	; 62
     ee6:	0f be       	out	0x3f, r0	; 63
     ee8:	cd bf       	out	0x3d, r28	; 61
     eea:	9d 83       	std	Y+5, r25	; 0x05
     eec:	8c 83       	std	Y+4, r24	; 0x04
     eee:	6e 83       	std	Y+6, r22	; 0x06
     ef0:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     ef2:	8a e1       	ldi	r24, 0x1A	; 26
     ef4:	90 e0       	ldi	r25, 0x00	; 0
     ef6:	0e 94 43 0a 	call	0x1486	; 0x1486 <pvPortMalloc>
     efa:	9a 83       	std	Y+2, r25	; 0x02
     efc:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     efe:	89 81       	ldd	r24, Y+1	; 0x01
     f00:	9a 81       	ldd	r25, Y+2	; 0x02
     f02:	00 97       	sbiw	r24, 0x00	; 0
     f04:	09 f4       	brne	.+2      	; 0xf08 <xCoRoutineCreate+0x32>
     f06:	6f c0       	rjmp	.+222    	; 0xfe6 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     f08:	80 91 68 00 	lds	r24, 0x0068
     f0c:	90 91 69 00 	lds	r25, 0x0069
     f10:	00 97       	sbiw	r24, 0x00	; 0
     f12:	41 f4       	brne	.+16     	; 0xf24 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     f14:	89 81       	ldd	r24, Y+1	; 0x01
     f16:	9a 81       	ldd	r25, Y+2	; 0x02
     f18:	90 93 69 00 	sts	0x0069, r25
     f1c:	80 93 68 00 	sts	0x0068, r24
			prvInitialiseCoRoutineLists();
     f20:	0e 94 d2 09 	call	0x13a4	; 0x13a4 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     f24:	8e 81       	ldd	r24, Y+6	; 0x06
     f26:	82 30       	cpi	r24, 0x02	; 2
     f28:	10 f0       	brcs	.+4      	; 0xf2e <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     f2a:	81 e0       	ldi	r24, 0x01	; 1
     f2c:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     f2e:	e9 81       	ldd	r30, Y+1	; 0x01
     f30:	fa 81       	ldd	r31, Y+2	; 0x02
     f32:	11 8e       	std	Z+25, r1	; 0x19
     f34:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     f36:	e9 81       	ldd	r30, Y+1	; 0x01
     f38:	fa 81       	ldd	r31, Y+2	; 0x02
     f3a:	8e 81       	ldd	r24, Y+6	; 0x06
     f3c:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     f3e:	e9 81       	ldd	r30, Y+1	; 0x01
     f40:	fa 81       	ldd	r31, Y+2	; 0x02
     f42:	8f 81       	ldd	r24, Y+7	; 0x07
     f44:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     f46:	e9 81       	ldd	r30, Y+1	; 0x01
     f48:	fa 81       	ldd	r31, Y+2	; 0x02
     f4a:	8c 81       	ldd	r24, Y+4	; 0x04
     f4c:	9d 81       	ldd	r25, Y+5	; 0x05
     f4e:	91 83       	std	Z+1, r25	; 0x01
     f50:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     f52:	89 81       	ldd	r24, Y+1	; 0x01
     f54:	9a 81       	ldd	r25, Y+2	; 0x02
     f56:	02 96       	adiw	r24, 0x02	; 2
     f58:	0e 94 d9 0a 	call	0x15b2	; 0x15b2 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     f5c:	89 81       	ldd	r24, Y+1	; 0x01
     f5e:	9a 81       	ldd	r25, Y+2	; 0x02
     f60:	0c 96       	adiw	r24, 0x0c	; 12
     f62:	0e 94 d9 0a 	call	0x15b2	; 0x15b2 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     f66:	e9 81       	ldd	r30, Y+1	; 0x01
     f68:	fa 81       	ldd	r31, Y+2	; 0x02
     f6a:	89 81       	ldd	r24, Y+1	; 0x01
     f6c:	9a 81       	ldd	r25, Y+2	; 0x02
     f6e:	91 87       	std	Z+9, r25	; 0x09
     f70:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     f72:	e9 81       	ldd	r30, Y+1	; 0x01
     f74:	fa 81       	ldd	r31, Y+2	; 0x02
     f76:	89 81       	ldd	r24, Y+1	; 0x01
     f78:	9a 81       	ldd	r25, Y+2	; 0x02
     f7a:	93 8b       	std	Z+19, r25	; 0x13
     f7c:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     f7e:	8e 81       	ldd	r24, Y+6	; 0x06
     f80:	28 2f       	mov	r18, r24
     f82:	30 e0       	ldi	r19, 0x00	; 0
     f84:	89 e0       	ldi	r24, 0x09	; 9
     f86:	90 e0       	ldi	r25, 0x00	; 0
     f88:	82 1b       	sub	r24, r18
     f8a:	93 0b       	sbc	r25, r19
     f8c:	e9 81       	ldd	r30, Y+1	; 0x01
     f8e:	fa 81       	ldd	r31, Y+2	; 0x02
     f90:	95 87       	std	Z+13, r25	; 0x0d
     f92:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     f94:	e9 81       	ldd	r30, Y+1	; 0x01
     f96:	fa 81       	ldd	r31, Y+2	; 0x02
     f98:	96 89       	ldd	r25, Z+22	; 0x16
     f9a:	80 91 6a 00 	lds	r24, 0x006A
     f9e:	89 17       	cp	r24, r25
     fa0:	28 f4       	brcc	.+10     	; 0xfac <xCoRoutineCreate+0xd6>
     fa2:	e9 81       	ldd	r30, Y+1	; 0x01
     fa4:	fa 81       	ldd	r31, Y+2	; 0x02
     fa6:	86 89       	ldd	r24, Z+22	; 0x16
     fa8:	80 93 6a 00 	sts	0x006A, r24
     fac:	e9 81       	ldd	r30, Y+1	; 0x01
     fae:	fa 81       	ldd	r31, Y+2	; 0x02
     fb0:	86 89       	ldd	r24, Z+22	; 0x16
     fb2:	28 2f       	mov	r18, r24
     fb4:	30 e0       	ldi	r19, 0x00	; 0
     fb6:	c9 01       	movw	r24, r18
     fb8:	88 0f       	add	r24, r24
     fba:	99 1f       	adc	r25, r25
     fbc:	88 0f       	add	r24, r24
     fbe:	99 1f       	adc	r25, r25
     fc0:	88 0f       	add	r24, r24
     fc2:	99 1f       	adc	r25, r25
     fc4:	82 0f       	add	r24, r18
     fc6:	93 1f       	adc	r25, r19
     fc8:	ac 01       	movw	r20, r24
     fca:	4f 58       	subi	r20, 0x8F	; 143
     fcc:	5f 4f       	sbci	r21, 0xFF	; 255
     fce:	89 81       	ldd	r24, Y+1	; 0x01
     fd0:	9a 81       	ldd	r25, Y+2	; 0x02
     fd2:	9c 01       	movw	r18, r24
     fd4:	2e 5f       	subi	r18, 0xFE	; 254
     fd6:	3f 4f       	sbci	r19, 0xFF	; 255
     fd8:	ca 01       	movw	r24, r20
     fda:	b9 01       	movw	r22, r18
     fdc:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <vListInsertEnd>

		xReturn = pdPASS;
     fe0:	81 e0       	ldi	r24, 0x01	; 1
     fe2:	8b 83       	std	Y+3, r24	; 0x03
     fe4:	02 c0       	rjmp	.+4      	; 0xfea <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     fe6:	8f ef       	ldi	r24, 0xFF	; 255
     fe8:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     fea:	8b 81       	ldd	r24, Y+3	; 0x03
}
     fec:	27 96       	adiw	r28, 0x07	; 7
     fee:	0f b6       	in	r0, 0x3f	; 63
     ff0:	f8 94       	cli
     ff2:	de bf       	out	0x3e, r29	; 62
     ff4:	0f be       	out	0x3f, r0	; 63
     ff6:	cd bf       	out	0x3d, r28	; 61
     ff8:	cf 91       	pop	r28
     ffa:	df 91       	pop	r29
     ffc:	08 95       	ret

00000ffe <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     ffe:	df 93       	push	r29
    1000:	cf 93       	push	r28
    1002:	00 d0       	rcall	.+0      	; 0x1004 <vCoRoutineAddToDelayedList+0x6>
    1004:	00 d0       	rcall	.+0      	; 0x1006 <vCoRoutineAddToDelayedList+0x8>
    1006:	00 d0       	rcall	.+0      	; 0x1008 <vCoRoutineAddToDelayedList+0xa>
    1008:	cd b7       	in	r28, 0x3d	; 61
    100a:	de b7       	in	r29, 0x3e	; 62
    100c:	9c 83       	std	Y+4, r25	; 0x04
    100e:	8b 83       	std	Y+3, r24	; 0x03
    1010:	7e 83       	std	Y+6, r23	; 0x06
    1012:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1014:	20 91 6b 00 	lds	r18, 0x006B
    1018:	30 91 6c 00 	lds	r19, 0x006C
    101c:	8b 81       	ldd	r24, Y+3	; 0x03
    101e:	9c 81       	ldd	r25, Y+4	; 0x04
    1020:	82 0f       	add	r24, r18
    1022:	93 1f       	adc	r25, r19
    1024:	9a 83       	std	Y+2, r25	; 0x02
    1026:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1028:	80 91 68 00 	lds	r24, 0x0068
    102c:	90 91 69 00 	lds	r25, 0x0069
    1030:	02 96       	adiw	r24, 0x02	; 2
    1032:	0e 94 a1 0b 	call	0x1742	; 0x1742 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1036:	e0 91 68 00 	lds	r30, 0x0068
    103a:	f0 91 69 00 	lds	r31, 0x0069
    103e:	89 81       	ldd	r24, Y+1	; 0x01
    1040:	9a 81       	ldd	r25, Y+2	; 0x02
    1042:	93 83       	std	Z+3, r25	; 0x03
    1044:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1046:	20 91 6b 00 	lds	r18, 0x006B
    104a:	30 91 6c 00 	lds	r19, 0x006C
    104e:	89 81       	ldd	r24, Y+1	; 0x01
    1050:	9a 81       	ldd	r25, Y+2	; 0x02
    1052:	82 17       	cp	r24, r18
    1054:	93 07       	cpc	r25, r19
    1056:	70 f4       	brcc	.+28     	; 0x1074 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1058:	80 91 97 00 	lds	r24, 0x0097
    105c:	90 91 98 00 	lds	r25, 0x0098
    1060:	20 91 68 00 	lds	r18, 0x0068
    1064:	30 91 69 00 	lds	r19, 0x0069
    1068:	2e 5f       	subi	r18, 0xFE	; 254
    106a:	3f 4f       	sbci	r19, 0xFF	; 255
    106c:	b9 01       	movw	r22, r18
    106e:	0e 94 35 0b 	call	0x166a	; 0x166a <vListInsert>
    1072:	0d c0       	rjmp	.+26     	; 0x108e <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1074:	80 91 95 00 	lds	r24, 0x0095
    1078:	90 91 96 00 	lds	r25, 0x0096
    107c:	20 91 68 00 	lds	r18, 0x0068
    1080:	30 91 69 00 	lds	r19, 0x0069
    1084:	2e 5f       	subi	r18, 0xFE	; 254
    1086:	3f 4f       	sbci	r19, 0xFF	; 255
    1088:	b9 01       	movw	r22, r18
    108a:	0e 94 35 0b 	call	0x166a	; 0x166a <vListInsert>
	}

	if( pxEventList )
    108e:	8d 81       	ldd	r24, Y+5	; 0x05
    1090:	9e 81       	ldd	r25, Y+6	; 0x06
    1092:	00 97       	sbiw	r24, 0x00	; 0
    1094:	61 f0       	breq	.+24     	; 0x10ae <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1096:	80 91 68 00 	lds	r24, 0x0068
    109a:	90 91 69 00 	lds	r25, 0x0069
    109e:	9c 01       	movw	r18, r24
    10a0:	24 5f       	subi	r18, 0xF4	; 244
    10a2:	3f 4f       	sbci	r19, 0xFF	; 255
    10a4:	8d 81       	ldd	r24, Y+5	; 0x05
    10a6:	9e 81       	ldd	r25, Y+6	; 0x06
    10a8:	b9 01       	movw	r22, r18
    10aa:	0e 94 35 0b 	call	0x166a	; 0x166a <vListInsert>
	}
}
    10ae:	26 96       	adiw	r28, 0x06	; 6
    10b0:	0f b6       	in	r0, 0x3f	; 63
    10b2:	f8 94       	cli
    10b4:	de bf       	out	0x3e, r29	; 62
    10b6:	0f be       	out	0x3f, r0	; 63
    10b8:	cd bf       	out	0x3d, r28	; 61
    10ba:	cf 91       	pop	r28
    10bc:	df 91       	pop	r29
    10be:	08 95       	ret

000010c0 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    10c0:	df 93       	push	r29
    10c2:	cf 93       	push	r28
    10c4:	00 d0       	rcall	.+0      	; 0x10c6 <prvCheckPendingReadyList+0x6>
    10c6:	cd b7       	in	r28, 0x3d	; 61
    10c8:	de b7       	in	r29, 0x3e	; 62
    10ca:	3a c0       	rjmp	.+116    	; 0x1140 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    10cc:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    10ce:	e0 91 9e 00 	lds	r30, 0x009E
    10d2:	f0 91 9f 00 	lds	r31, 0x009F
    10d6:	86 81       	ldd	r24, Z+6	; 0x06
    10d8:	97 81       	ldd	r25, Z+7	; 0x07
    10da:	9a 83       	std	Y+2, r25	; 0x02
    10dc:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    10de:	89 81       	ldd	r24, Y+1	; 0x01
    10e0:	9a 81       	ldd	r25, Y+2	; 0x02
    10e2:	0c 96       	adiw	r24, 0x0c	; 12
    10e4:	0e 94 a1 0b 	call	0x1742	; 0x1742 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    10e8:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    10ea:	89 81       	ldd	r24, Y+1	; 0x01
    10ec:	9a 81       	ldd	r25, Y+2	; 0x02
    10ee:	02 96       	adiw	r24, 0x02	; 2
    10f0:	0e 94 a1 0b 	call	0x1742	; 0x1742 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    10f4:	e9 81       	ldd	r30, Y+1	; 0x01
    10f6:	fa 81       	ldd	r31, Y+2	; 0x02
    10f8:	96 89       	ldd	r25, Z+22	; 0x16
    10fa:	80 91 6a 00 	lds	r24, 0x006A
    10fe:	89 17       	cp	r24, r25
    1100:	28 f4       	brcc	.+10     	; 0x110c <prvCheckPendingReadyList+0x4c>
    1102:	e9 81       	ldd	r30, Y+1	; 0x01
    1104:	fa 81       	ldd	r31, Y+2	; 0x02
    1106:	86 89       	ldd	r24, Z+22	; 0x16
    1108:	80 93 6a 00 	sts	0x006A, r24
    110c:	e9 81       	ldd	r30, Y+1	; 0x01
    110e:	fa 81       	ldd	r31, Y+2	; 0x02
    1110:	86 89       	ldd	r24, Z+22	; 0x16
    1112:	28 2f       	mov	r18, r24
    1114:	30 e0       	ldi	r19, 0x00	; 0
    1116:	c9 01       	movw	r24, r18
    1118:	88 0f       	add	r24, r24
    111a:	99 1f       	adc	r25, r25
    111c:	88 0f       	add	r24, r24
    111e:	99 1f       	adc	r25, r25
    1120:	88 0f       	add	r24, r24
    1122:	99 1f       	adc	r25, r25
    1124:	82 0f       	add	r24, r18
    1126:	93 1f       	adc	r25, r19
    1128:	ac 01       	movw	r20, r24
    112a:	4f 58       	subi	r20, 0x8F	; 143
    112c:	5f 4f       	sbci	r21, 0xFF	; 255
    112e:	89 81       	ldd	r24, Y+1	; 0x01
    1130:	9a 81       	ldd	r25, Y+2	; 0x02
    1132:	9c 01       	movw	r18, r24
    1134:	2e 5f       	subi	r18, 0xFE	; 254
    1136:	3f 4f       	sbci	r19, 0xFF	; 255
    1138:	ca 01       	movw	r24, r20
    113a:	b9 01       	movw	r22, r18
    113c:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1140:	80 91 99 00 	lds	r24, 0x0099
    1144:	88 23       	and	r24, r24
    1146:	09 f0       	breq	.+2      	; 0x114a <prvCheckPendingReadyList+0x8a>
    1148:	c1 cf       	rjmp	.-126    	; 0x10cc <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    114a:	0f 90       	pop	r0
    114c:	0f 90       	pop	r0
    114e:	cf 91       	pop	r28
    1150:	df 91       	pop	r29
    1152:	08 95       	ret

00001154 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    1154:	df 93       	push	r29
    1156:	cf 93       	push	r28
    1158:	00 d0       	rcall	.+0      	; 0x115a <prvCheckDelayedList+0x6>
    115a:	00 d0       	rcall	.+0      	; 0x115c <prvCheckDelayedList+0x8>
    115c:	cd b7       	in	r28, 0x3d	; 61
    115e:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1160:	0e 94 91 16 	call	0x2d22	; 0x2d22 <xTaskGetTickCount>
    1164:	20 91 6d 00 	lds	r18, 0x006D
    1168:	30 91 6e 00 	lds	r19, 0x006E
    116c:	82 1b       	sub	r24, r18
    116e:	93 0b       	sbc	r25, r19
    1170:	90 93 70 00 	sts	0x0070, r25
    1174:	80 93 6f 00 	sts	0x006F, r24
    1178:	85 c0       	rjmp	.+266    	; 0x1284 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    117a:	80 91 6b 00 	lds	r24, 0x006B
    117e:	90 91 6c 00 	lds	r25, 0x006C
    1182:	01 96       	adiw	r24, 0x01	; 1
    1184:	90 93 6c 00 	sts	0x006C, r25
    1188:	80 93 6b 00 	sts	0x006B, r24
		xPassedTicks--;
    118c:	80 91 6f 00 	lds	r24, 0x006F
    1190:	90 91 70 00 	lds	r25, 0x0070
    1194:	01 97       	sbiw	r24, 0x01	; 1
    1196:	90 93 70 00 	sts	0x0070, r25
    119a:	80 93 6f 00 	sts	0x006F, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    119e:	80 91 6b 00 	lds	r24, 0x006B
    11a2:	90 91 6c 00 	lds	r25, 0x006C
    11a6:	00 97       	sbiw	r24, 0x00	; 0
    11a8:	09 f0       	breq	.+2      	; 0x11ac <prvCheckDelayedList+0x58>
    11aa:	64 c0       	rjmp	.+200    	; 0x1274 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    11ac:	80 91 95 00 	lds	r24, 0x0095
    11b0:	90 91 96 00 	lds	r25, 0x0096
    11b4:	9a 83       	std	Y+2, r25	; 0x02
    11b6:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    11b8:	80 91 97 00 	lds	r24, 0x0097
    11bc:	90 91 98 00 	lds	r25, 0x0098
    11c0:	90 93 96 00 	sts	0x0096, r25
    11c4:	80 93 95 00 	sts	0x0095, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    11c8:	89 81       	ldd	r24, Y+1	; 0x01
    11ca:	9a 81       	ldd	r25, Y+2	; 0x02
    11cc:	90 93 98 00 	sts	0x0098, r25
    11d0:	80 93 97 00 	sts	0x0097, r24
    11d4:	4f c0       	rjmp	.+158    	; 0x1274 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    11d6:	e0 91 95 00 	lds	r30, 0x0095
    11da:	f0 91 96 00 	lds	r31, 0x0096
    11de:	05 80       	ldd	r0, Z+5	; 0x05
    11e0:	f6 81       	ldd	r31, Z+6	; 0x06
    11e2:	e0 2d       	mov	r30, r0
    11e4:	86 81       	ldd	r24, Z+6	; 0x06
    11e6:	97 81       	ldd	r25, Z+7	; 0x07
    11e8:	9c 83       	std	Y+4, r25	; 0x04
    11ea:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    11ec:	eb 81       	ldd	r30, Y+3	; 0x03
    11ee:	fc 81       	ldd	r31, Y+4	; 0x04
    11f0:	22 81       	ldd	r18, Z+2	; 0x02
    11f2:	33 81       	ldd	r19, Z+3	; 0x03
    11f4:	80 91 6b 00 	lds	r24, 0x006B
    11f8:	90 91 6c 00 	lds	r25, 0x006C
    11fc:	82 17       	cp	r24, r18
    11fe:	93 07       	cpc	r25, r19
    1200:	08 f4       	brcc	.+2      	; 0x1204 <prvCheckDelayedList+0xb0>
    1202:	40 c0       	rjmp	.+128    	; 0x1284 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    1204:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    1206:	8b 81       	ldd	r24, Y+3	; 0x03
    1208:	9c 81       	ldd	r25, Y+4	; 0x04
    120a:	02 96       	adiw	r24, 0x02	; 2
    120c:	0e 94 a1 0b 	call	0x1742	; 0x1742 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    1210:	eb 81       	ldd	r30, Y+3	; 0x03
    1212:	fc 81       	ldd	r31, Y+4	; 0x04
    1214:	84 89       	ldd	r24, Z+20	; 0x14
    1216:	95 89       	ldd	r25, Z+21	; 0x15
    1218:	00 97       	sbiw	r24, 0x00	; 0
    121a:	29 f0       	breq	.+10     	; 0x1226 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    121c:	8b 81       	ldd	r24, Y+3	; 0x03
    121e:	9c 81       	ldd	r25, Y+4	; 0x04
    1220:	0c 96       	adiw	r24, 0x0c	; 12
    1222:	0e 94 a1 0b 	call	0x1742	; 0x1742 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    1226:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    1228:	eb 81       	ldd	r30, Y+3	; 0x03
    122a:	fc 81       	ldd	r31, Y+4	; 0x04
    122c:	96 89       	ldd	r25, Z+22	; 0x16
    122e:	80 91 6a 00 	lds	r24, 0x006A
    1232:	89 17       	cp	r24, r25
    1234:	28 f4       	brcc	.+10     	; 0x1240 <prvCheckDelayedList+0xec>
    1236:	eb 81       	ldd	r30, Y+3	; 0x03
    1238:	fc 81       	ldd	r31, Y+4	; 0x04
    123a:	86 89       	ldd	r24, Z+22	; 0x16
    123c:	80 93 6a 00 	sts	0x006A, r24
    1240:	eb 81       	ldd	r30, Y+3	; 0x03
    1242:	fc 81       	ldd	r31, Y+4	; 0x04
    1244:	86 89       	ldd	r24, Z+22	; 0x16
    1246:	28 2f       	mov	r18, r24
    1248:	30 e0       	ldi	r19, 0x00	; 0
    124a:	c9 01       	movw	r24, r18
    124c:	88 0f       	add	r24, r24
    124e:	99 1f       	adc	r25, r25
    1250:	88 0f       	add	r24, r24
    1252:	99 1f       	adc	r25, r25
    1254:	88 0f       	add	r24, r24
    1256:	99 1f       	adc	r25, r25
    1258:	82 0f       	add	r24, r18
    125a:	93 1f       	adc	r25, r19
    125c:	ac 01       	movw	r20, r24
    125e:	4f 58       	subi	r20, 0x8F	; 143
    1260:	5f 4f       	sbci	r21, 0xFF	; 255
    1262:	8b 81       	ldd	r24, Y+3	; 0x03
    1264:	9c 81       	ldd	r25, Y+4	; 0x04
    1266:	9c 01       	movw	r18, r24
    1268:	2e 5f       	subi	r18, 0xFE	; 254
    126a:	3f 4f       	sbci	r19, 0xFF	; 255
    126c:	ca 01       	movw	r24, r20
    126e:	b9 01       	movw	r22, r18
    1270:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1274:	e0 91 95 00 	lds	r30, 0x0095
    1278:	f0 91 96 00 	lds	r31, 0x0096
    127c:	80 81       	ld	r24, Z
    127e:	88 23       	and	r24, r24
    1280:	09 f0       	breq	.+2      	; 0x1284 <prvCheckDelayedList+0x130>
    1282:	a9 cf       	rjmp	.-174    	; 0x11d6 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1284:	80 91 6f 00 	lds	r24, 0x006F
    1288:	90 91 70 00 	lds	r25, 0x0070
    128c:	00 97       	sbiw	r24, 0x00	; 0
    128e:	09 f0       	breq	.+2      	; 0x1292 <prvCheckDelayedList+0x13e>
    1290:	74 cf       	rjmp	.-280    	; 0x117a <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    1292:	80 91 6b 00 	lds	r24, 0x006B
    1296:	90 91 6c 00 	lds	r25, 0x006C
    129a:	90 93 6e 00 	sts	0x006E, r25
    129e:	80 93 6d 00 	sts	0x006D, r24
}
    12a2:	0f 90       	pop	r0
    12a4:	0f 90       	pop	r0
    12a6:	0f 90       	pop	r0
    12a8:	0f 90       	pop	r0
    12aa:	cf 91       	pop	r28
    12ac:	df 91       	pop	r29
    12ae:	08 95       	ret

000012b0 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    12b0:	df 93       	push	r29
    12b2:	cf 93       	push	r28
    12b4:	00 d0       	rcall	.+0      	; 0x12b6 <vCoRoutineSchedule+0x6>
    12b6:	cd b7       	in	r28, 0x3d	; 61
    12b8:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    12ba:	0e 94 60 08 	call	0x10c0	; 0x10c0 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    12be:	0e 94 aa 08 	call	0x1154	; 0x1154 <prvCheckDelayedList>
    12c2:	0a c0       	rjmp	.+20     	; 0x12d8 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    12c4:	80 91 6a 00 	lds	r24, 0x006A
    12c8:	88 23       	and	r24, r24
    12ca:	09 f4       	brne	.+2      	; 0x12ce <vCoRoutineSchedule+0x1e>
    12cc:	66 c0       	rjmp	.+204    	; 0x139a <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    12ce:	80 91 6a 00 	lds	r24, 0x006A
    12d2:	81 50       	subi	r24, 0x01	; 1
    12d4:	80 93 6a 00 	sts	0x006A, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    12d8:	80 91 6a 00 	lds	r24, 0x006A
    12dc:	28 2f       	mov	r18, r24
    12de:	30 e0       	ldi	r19, 0x00	; 0
    12e0:	c9 01       	movw	r24, r18
    12e2:	88 0f       	add	r24, r24
    12e4:	99 1f       	adc	r25, r25
    12e6:	88 0f       	add	r24, r24
    12e8:	99 1f       	adc	r25, r25
    12ea:	88 0f       	add	r24, r24
    12ec:	99 1f       	adc	r25, r25
    12ee:	82 0f       	add	r24, r18
    12f0:	93 1f       	adc	r25, r19
    12f2:	fc 01       	movw	r30, r24
    12f4:	ef 58       	subi	r30, 0x8F	; 143
    12f6:	ff 4f       	sbci	r31, 0xFF	; 255
    12f8:	80 81       	ld	r24, Z
    12fa:	88 23       	and	r24, r24
    12fc:	19 f3       	breq	.-58     	; 0x12c4 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    12fe:	80 91 6a 00 	lds	r24, 0x006A
    1302:	28 2f       	mov	r18, r24
    1304:	30 e0       	ldi	r19, 0x00	; 0
    1306:	c9 01       	movw	r24, r18
    1308:	88 0f       	add	r24, r24
    130a:	99 1f       	adc	r25, r25
    130c:	88 0f       	add	r24, r24
    130e:	99 1f       	adc	r25, r25
    1310:	88 0f       	add	r24, r24
    1312:	99 1f       	adc	r25, r25
    1314:	82 0f       	add	r24, r18
    1316:	93 1f       	adc	r25, r19
    1318:	8f 58       	subi	r24, 0x8F	; 143
    131a:	9f 4f       	sbci	r25, 0xFF	; 255
    131c:	9a 83       	std	Y+2, r25	; 0x02
    131e:	89 83       	std	Y+1, r24	; 0x01
    1320:	e9 81       	ldd	r30, Y+1	; 0x01
    1322:	fa 81       	ldd	r31, Y+2	; 0x02
    1324:	01 80       	ldd	r0, Z+1	; 0x01
    1326:	f2 81       	ldd	r31, Z+2	; 0x02
    1328:	e0 2d       	mov	r30, r0
    132a:	82 81       	ldd	r24, Z+2	; 0x02
    132c:	93 81       	ldd	r25, Z+3	; 0x03
    132e:	e9 81       	ldd	r30, Y+1	; 0x01
    1330:	fa 81       	ldd	r31, Y+2	; 0x02
    1332:	92 83       	std	Z+2, r25	; 0x02
    1334:	81 83       	std	Z+1, r24	; 0x01
    1336:	e9 81       	ldd	r30, Y+1	; 0x01
    1338:	fa 81       	ldd	r31, Y+2	; 0x02
    133a:	21 81       	ldd	r18, Z+1	; 0x01
    133c:	32 81       	ldd	r19, Z+2	; 0x02
    133e:	89 81       	ldd	r24, Y+1	; 0x01
    1340:	9a 81       	ldd	r25, Y+2	; 0x02
    1342:	03 96       	adiw	r24, 0x03	; 3
    1344:	28 17       	cp	r18, r24
    1346:	39 07       	cpc	r19, r25
    1348:	59 f4       	brne	.+22     	; 0x1360 <vCoRoutineSchedule+0xb0>
    134a:	e9 81       	ldd	r30, Y+1	; 0x01
    134c:	fa 81       	ldd	r31, Y+2	; 0x02
    134e:	01 80       	ldd	r0, Z+1	; 0x01
    1350:	f2 81       	ldd	r31, Z+2	; 0x02
    1352:	e0 2d       	mov	r30, r0
    1354:	82 81       	ldd	r24, Z+2	; 0x02
    1356:	93 81       	ldd	r25, Z+3	; 0x03
    1358:	e9 81       	ldd	r30, Y+1	; 0x01
    135a:	fa 81       	ldd	r31, Y+2	; 0x02
    135c:	92 83       	std	Z+2, r25	; 0x02
    135e:	81 83       	std	Z+1, r24	; 0x01
    1360:	e9 81       	ldd	r30, Y+1	; 0x01
    1362:	fa 81       	ldd	r31, Y+2	; 0x02
    1364:	01 80       	ldd	r0, Z+1	; 0x01
    1366:	f2 81       	ldd	r31, Z+2	; 0x02
    1368:	e0 2d       	mov	r30, r0
    136a:	86 81       	ldd	r24, Z+6	; 0x06
    136c:	97 81       	ldd	r25, Z+7	; 0x07
    136e:	90 93 69 00 	sts	0x0069, r25
    1372:	80 93 68 00 	sts	0x0068, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1376:	e0 91 68 00 	lds	r30, 0x0068
    137a:	f0 91 69 00 	lds	r31, 0x0069
    137e:	40 81       	ld	r20, Z
    1380:	51 81       	ldd	r21, Z+1	; 0x01
    1382:	80 91 68 00 	lds	r24, 0x0068
    1386:	90 91 69 00 	lds	r25, 0x0069
    138a:	e0 91 68 00 	lds	r30, 0x0068
    138e:	f0 91 69 00 	lds	r31, 0x0069
    1392:	27 89       	ldd	r18, Z+23	; 0x17
    1394:	62 2f       	mov	r22, r18
    1396:	fa 01       	movw	r30, r20
    1398:	09 95       	icall

	return;
}
    139a:	0f 90       	pop	r0
    139c:	0f 90       	pop	r0
    139e:	cf 91       	pop	r28
    13a0:	df 91       	pop	r29
    13a2:	08 95       	ret

000013a4 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    13a4:	df 93       	push	r29
    13a6:	cf 93       	push	r28
    13a8:	0f 92       	push	r0
    13aa:	cd b7       	in	r28, 0x3d	; 61
    13ac:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    13ae:	19 82       	std	Y+1, r1	; 0x01
    13b0:	13 c0       	rjmp	.+38     	; 0x13d8 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    13b2:	89 81       	ldd	r24, Y+1	; 0x01
    13b4:	28 2f       	mov	r18, r24
    13b6:	30 e0       	ldi	r19, 0x00	; 0
    13b8:	c9 01       	movw	r24, r18
    13ba:	88 0f       	add	r24, r24
    13bc:	99 1f       	adc	r25, r25
    13be:	88 0f       	add	r24, r24
    13c0:	99 1f       	adc	r25, r25
    13c2:	88 0f       	add	r24, r24
    13c4:	99 1f       	adc	r25, r25
    13c6:	82 0f       	add	r24, r18
    13c8:	93 1f       	adc	r25, r19
    13ca:	8f 58       	subi	r24, 0x8F	; 143
    13cc:	9f 4f       	sbci	r25, 0xFF	; 255
    13ce:	0e 94 af 0a 	call	0x155e	; 0x155e <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    13d2:	89 81       	ldd	r24, Y+1	; 0x01
    13d4:	8f 5f       	subi	r24, 0xFF	; 255
    13d6:	89 83       	std	Y+1, r24	; 0x01
    13d8:	89 81       	ldd	r24, Y+1	; 0x01
    13da:	82 30       	cpi	r24, 0x02	; 2
    13dc:	50 f3       	brcs	.-44     	; 0x13b2 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    13de:	83 e8       	ldi	r24, 0x83	; 131
    13e0:	90 e0       	ldi	r25, 0x00	; 0
    13e2:	0e 94 af 0a 	call	0x155e	; 0x155e <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    13e6:	8c e8       	ldi	r24, 0x8C	; 140
    13e8:	90 e0       	ldi	r25, 0x00	; 0
    13ea:	0e 94 af 0a 	call	0x155e	; 0x155e <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    13ee:	89 e9       	ldi	r24, 0x99	; 153
    13f0:	90 e0       	ldi	r25, 0x00	; 0
    13f2:	0e 94 af 0a 	call	0x155e	; 0x155e <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    13f6:	83 e8       	ldi	r24, 0x83	; 131
    13f8:	90 e0       	ldi	r25, 0x00	; 0
    13fa:	90 93 96 00 	sts	0x0096, r25
    13fe:	80 93 95 00 	sts	0x0095, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1402:	8c e8       	ldi	r24, 0x8C	; 140
    1404:	90 e0       	ldi	r25, 0x00	; 0
    1406:	90 93 98 00 	sts	0x0098, r25
    140a:	80 93 97 00 	sts	0x0097, r24
}
    140e:	0f 90       	pop	r0
    1410:	cf 91       	pop	r28
    1412:	df 91       	pop	r29
    1414:	08 95       	ret

00001416 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    1416:	df 93       	push	r29
    1418:	cf 93       	push	r28
    141a:	00 d0       	rcall	.+0      	; 0x141c <xCoRoutineRemoveFromEventList+0x6>
    141c:	00 d0       	rcall	.+0      	; 0x141e <xCoRoutineRemoveFromEventList+0x8>
    141e:	0f 92       	push	r0
    1420:	cd b7       	in	r28, 0x3d	; 61
    1422:	de b7       	in	r29, 0x3e	; 62
    1424:	9d 83       	std	Y+5, r25	; 0x05
    1426:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1428:	ec 81       	ldd	r30, Y+4	; 0x04
    142a:	fd 81       	ldd	r31, Y+5	; 0x05
    142c:	05 80       	ldd	r0, Z+5	; 0x05
    142e:	f6 81       	ldd	r31, Z+6	; 0x06
    1430:	e0 2d       	mov	r30, r0
    1432:	86 81       	ldd	r24, Z+6	; 0x06
    1434:	97 81       	ldd	r25, Z+7	; 0x07
    1436:	9b 83       	std	Y+3, r25	; 0x03
    1438:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    143a:	8a 81       	ldd	r24, Y+2	; 0x02
    143c:	9b 81       	ldd	r25, Y+3	; 0x03
    143e:	0c 96       	adiw	r24, 0x0c	; 12
    1440:	0e 94 a1 0b 	call	0x1742	; 0x1742 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1444:	8a 81       	ldd	r24, Y+2	; 0x02
    1446:	9b 81       	ldd	r25, Y+3	; 0x03
    1448:	9c 01       	movw	r18, r24
    144a:	24 5f       	subi	r18, 0xF4	; 244
    144c:	3f 4f       	sbci	r19, 0xFF	; 255
    144e:	89 e9       	ldi	r24, 0x99	; 153
    1450:	90 e0       	ldi	r25, 0x00	; 0
    1452:	b9 01       	movw	r22, r18
    1454:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    1458:	ea 81       	ldd	r30, Y+2	; 0x02
    145a:	fb 81       	ldd	r31, Y+3	; 0x03
    145c:	96 89       	ldd	r25, Z+22	; 0x16
    145e:	e0 91 68 00 	lds	r30, 0x0068
    1462:	f0 91 69 00 	lds	r31, 0x0069
    1466:	86 89       	ldd	r24, Z+22	; 0x16
    1468:	98 17       	cp	r25, r24
    146a:	18 f0       	brcs	.+6      	; 0x1472 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    146c:	81 e0       	ldi	r24, 0x01	; 1
    146e:	89 83       	std	Y+1, r24	; 0x01
    1470:	01 c0       	rjmp	.+2      	; 0x1474 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    1472:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    1474:	89 81       	ldd	r24, Y+1	; 0x01
}
    1476:	0f 90       	pop	r0
    1478:	0f 90       	pop	r0
    147a:	0f 90       	pop	r0
    147c:	0f 90       	pop	r0
    147e:	0f 90       	pop	r0
    1480:	cf 91       	pop	r28
    1482:	df 91       	pop	r29
    1484:	08 95       	ret

00001486 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1486:	df 93       	push	r29
    1488:	cf 93       	push	r28
    148a:	00 d0       	rcall	.+0      	; 0x148c <pvPortMalloc+0x6>
    148c:	00 d0       	rcall	.+0      	; 0x148e <pvPortMalloc+0x8>
    148e:	cd b7       	in	r28, 0x3d	; 61
    1490:	de b7       	in	r29, 0x3e	; 62
    1492:	9c 83       	std	Y+4, r25	; 0x04
    1494:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    1496:	1a 82       	std	Y+2, r1	; 0x02
    1498:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    149a:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    149e:	80 91 a2 00 	lds	r24, 0x00A2
    14a2:	90 91 a3 00 	lds	r25, 0x00A3
    14a6:	2b 81       	ldd	r18, Y+3	; 0x03
    14a8:	3c 81       	ldd	r19, Y+4	; 0x04
    14aa:	82 0f       	add	r24, r18
    14ac:	93 1f       	adc	r25, r19
    14ae:	22 e0       	ldi	r18, 0x02	; 2
    14b0:	88 35       	cpi	r24, 0x58	; 88
    14b2:	92 07       	cpc	r25, r18
    14b4:	18 f5       	brcc	.+70     	; 0x14fc <pvPortMalloc+0x76>
    14b6:	20 91 a2 00 	lds	r18, 0x00A2
    14ba:	30 91 a3 00 	lds	r19, 0x00A3
    14be:	8b 81       	ldd	r24, Y+3	; 0x03
    14c0:	9c 81       	ldd	r25, Y+4	; 0x04
    14c2:	28 0f       	add	r18, r24
    14c4:	39 1f       	adc	r19, r25
    14c6:	80 91 a2 00 	lds	r24, 0x00A2
    14ca:	90 91 a3 00 	lds	r25, 0x00A3
    14ce:	82 17       	cp	r24, r18
    14d0:	93 07       	cpc	r25, r19
    14d2:	a0 f4       	brcc	.+40     	; 0x14fc <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    14d4:	80 91 a2 00 	lds	r24, 0x00A2
    14d8:	90 91 a3 00 	lds	r25, 0x00A3
    14dc:	8c 55       	subi	r24, 0x5C	; 92
    14de:	9f 4f       	sbci	r25, 0xFF	; 255
    14e0:	9a 83       	std	Y+2, r25	; 0x02
    14e2:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    14e4:	20 91 a2 00 	lds	r18, 0x00A2
    14e8:	30 91 a3 00 	lds	r19, 0x00A3
    14ec:	8b 81       	ldd	r24, Y+3	; 0x03
    14ee:	9c 81       	ldd	r25, Y+4	; 0x04
    14f0:	82 0f       	add	r24, r18
    14f2:	93 1f       	adc	r25, r19
    14f4:	90 93 a3 00 	sts	0x00A3, r25
    14f8:	80 93 a2 00 	sts	0x00A2, r24
		}	
	}
	xTaskResumeAll();
    14fc:	0e 94 07 16 	call	0x2c0e	; 0x2c0e <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    1500:	89 81       	ldd	r24, Y+1	; 0x01
    1502:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1504:	0f 90       	pop	r0
    1506:	0f 90       	pop	r0
    1508:	0f 90       	pop	r0
    150a:	0f 90       	pop	r0
    150c:	cf 91       	pop	r28
    150e:	df 91       	pop	r29
    1510:	08 95       	ret

00001512 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1512:	df 93       	push	r29
    1514:	cf 93       	push	r28
    1516:	00 d0       	rcall	.+0      	; 0x1518 <vPortFree+0x6>
    1518:	cd b7       	in	r28, 0x3d	; 61
    151a:	de b7       	in	r29, 0x3e	; 62
    151c:	9a 83       	std	Y+2, r25	; 0x02
    151e:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    1520:	0f 90       	pop	r0
    1522:	0f 90       	pop	r0
    1524:	cf 91       	pop	r28
    1526:	df 91       	pop	r29
    1528:	08 95       	ret

0000152a <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    152a:	df 93       	push	r29
    152c:	cf 93       	push	r28
    152e:	cd b7       	in	r28, 0x3d	; 61
    1530:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1532:	10 92 a3 00 	sts	0x00A3, r1
    1536:	10 92 a2 00 	sts	0x00A2, r1
}
    153a:	cf 91       	pop	r28
    153c:	df 91       	pop	r29
    153e:	08 95       	ret

00001540 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1540:	df 93       	push	r29
    1542:	cf 93       	push	r28
    1544:	cd b7       	in	r28, 0x3d	; 61
    1546:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    1548:	20 91 a2 00 	lds	r18, 0x00A2
    154c:	30 91 a3 00 	lds	r19, 0x00A3
    1550:	88 e5       	ldi	r24, 0x58	; 88
    1552:	92 e0       	ldi	r25, 0x02	; 2
    1554:	82 1b       	sub	r24, r18
    1556:	93 0b       	sbc	r25, r19
}
    1558:	cf 91       	pop	r28
    155a:	df 91       	pop	r29
    155c:	08 95       	ret

0000155e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    155e:	df 93       	push	r29
    1560:	cf 93       	push	r28
    1562:	00 d0       	rcall	.+0      	; 0x1564 <vListInitialise+0x6>
    1564:	cd b7       	in	r28, 0x3d	; 61
    1566:	de b7       	in	r29, 0x3e	; 62
    1568:	9a 83       	std	Y+2, r25	; 0x02
    156a:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    156c:	89 81       	ldd	r24, Y+1	; 0x01
    156e:	9a 81       	ldd	r25, Y+2	; 0x02
    1570:	03 96       	adiw	r24, 0x03	; 3
    1572:	e9 81       	ldd	r30, Y+1	; 0x01
    1574:	fa 81       	ldd	r31, Y+2	; 0x02
    1576:	92 83       	std	Z+2, r25	; 0x02
    1578:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    157a:	e9 81       	ldd	r30, Y+1	; 0x01
    157c:	fa 81       	ldd	r31, Y+2	; 0x02
    157e:	8f ef       	ldi	r24, 0xFF	; 255
    1580:	9f ef       	ldi	r25, 0xFF	; 255
    1582:	94 83       	std	Z+4, r25	; 0x04
    1584:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1586:	89 81       	ldd	r24, Y+1	; 0x01
    1588:	9a 81       	ldd	r25, Y+2	; 0x02
    158a:	03 96       	adiw	r24, 0x03	; 3
    158c:	e9 81       	ldd	r30, Y+1	; 0x01
    158e:	fa 81       	ldd	r31, Y+2	; 0x02
    1590:	96 83       	std	Z+6, r25	; 0x06
    1592:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1594:	89 81       	ldd	r24, Y+1	; 0x01
    1596:	9a 81       	ldd	r25, Y+2	; 0x02
    1598:	03 96       	adiw	r24, 0x03	; 3
    159a:	e9 81       	ldd	r30, Y+1	; 0x01
    159c:	fa 81       	ldd	r31, Y+2	; 0x02
    159e:	90 87       	std	Z+8, r25	; 0x08
    15a0:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    15a2:	e9 81       	ldd	r30, Y+1	; 0x01
    15a4:	fa 81       	ldd	r31, Y+2	; 0x02
    15a6:	10 82       	st	Z, r1
}
    15a8:	0f 90       	pop	r0
    15aa:	0f 90       	pop	r0
    15ac:	cf 91       	pop	r28
    15ae:	df 91       	pop	r29
    15b0:	08 95       	ret

000015b2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    15b2:	df 93       	push	r29
    15b4:	cf 93       	push	r28
    15b6:	00 d0       	rcall	.+0      	; 0x15b8 <vListInitialiseItem+0x6>
    15b8:	cd b7       	in	r28, 0x3d	; 61
    15ba:	de b7       	in	r29, 0x3e	; 62
    15bc:	9a 83       	std	Y+2, r25	; 0x02
    15be:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    15c0:	e9 81       	ldd	r30, Y+1	; 0x01
    15c2:	fa 81       	ldd	r31, Y+2	; 0x02
    15c4:	11 86       	std	Z+9, r1	; 0x09
    15c6:	10 86       	std	Z+8, r1	; 0x08
}
    15c8:	0f 90       	pop	r0
    15ca:	0f 90       	pop	r0
    15cc:	cf 91       	pop	r28
    15ce:	df 91       	pop	r29
    15d0:	08 95       	ret

000015d2 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    15d2:	df 93       	push	r29
    15d4:	cf 93       	push	r28
    15d6:	00 d0       	rcall	.+0      	; 0x15d8 <vListInsertEnd+0x6>
    15d8:	00 d0       	rcall	.+0      	; 0x15da <vListInsertEnd+0x8>
    15da:	00 d0       	rcall	.+0      	; 0x15dc <vListInsertEnd+0xa>
    15dc:	cd b7       	in	r28, 0x3d	; 61
    15de:	de b7       	in	r29, 0x3e	; 62
    15e0:	9c 83       	std	Y+4, r25	; 0x04
    15e2:	8b 83       	std	Y+3, r24	; 0x03
    15e4:	7e 83       	std	Y+6, r23	; 0x06
    15e6:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    15e8:	eb 81       	ldd	r30, Y+3	; 0x03
    15ea:	fc 81       	ldd	r31, Y+4	; 0x04
    15ec:	81 81       	ldd	r24, Z+1	; 0x01
    15ee:	92 81       	ldd	r25, Z+2	; 0x02
    15f0:	9a 83       	std	Y+2, r25	; 0x02
    15f2:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    15f4:	e9 81       	ldd	r30, Y+1	; 0x01
    15f6:	fa 81       	ldd	r31, Y+2	; 0x02
    15f8:	82 81       	ldd	r24, Z+2	; 0x02
    15fa:	93 81       	ldd	r25, Z+3	; 0x03
    15fc:	ed 81       	ldd	r30, Y+5	; 0x05
    15fe:	fe 81       	ldd	r31, Y+6	; 0x06
    1600:	93 83       	std	Z+3, r25	; 0x03
    1602:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1604:	eb 81       	ldd	r30, Y+3	; 0x03
    1606:	fc 81       	ldd	r31, Y+4	; 0x04
    1608:	81 81       	ldd	r24, Z+1	; 0x01
    160a:	92 81       	ldd	r25, Z+2	; 0x02
    160c:	ed 81       	ldd	r30, Y+5	; 0x05
    160e:	fe 81       	ldd	r31, Y+6	; 0x06
    1610:	95 83       	std	Z+5, r25	; 0x05
    1612:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1614:	e9 81       	ldd	r30, Y+1	; 0x01
    1616:	fa 81       	ldd	r31, Y+2	; 0x02
    1618:	02 80       	ldd	r0, Z+2	; 0x02
    161a:	f3 81       	ldd	r31, Z+3	; 0x03
    161c:	e0 2d       	mov	r30, r0
    161e:	8d 81       	ldd	r24, Y+5	; 0x05
    1620:	9e 81       	ldd	r25, Y+6	; 0x06
    1622:	95 83       	std	Z+5, r25	; 0x05
    1624:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1626:	8d 81       	ldd	r24, Y+5	; 0x05
    1628:	9e 81       	ldd	r25, Y+6	; 0x06
    162a:	e9 81       	ldd	r30, Y+1	; 0x01
    162c:	fa 81       	ldd	r31, Y+2	; 0x02
    162e:	93 83       	std	Z+3, r25	; 0x03
    1630:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1632:	8d 81       	ldd	r24, Y+5	; 0x05
    1634:	9e 81       	ldd	r25, Y+6	; 0x06
    1636:	eb 81       	ldd	r30, Y+3	; 0x03
    1638:	fc 81       	ldd	r31, Y+4	; 0x04
    163a:	92 83       	std	Z+2, r25	; 0x02
    163c:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    163e:	ed 81       	ldd	r30, Y+5	; 0x05
    1640:	fe 81       	ldd	r31, Y+6	; 0x06
    1642:	8b 81       	ldd	r24, Y+3	; 0x03
    1644:	9c 81       	ldd	r25, Y+4	; 0x04
    1646:	91 87       	std	Z+9, r25	; 0x09
    1648:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    164a:	eb 81       	ldd	r30, Y+3	; 0x03
    164c:	fc 81       	ldd	r31, Y+4	; 0x04
    164e:	80 81       	ld	r24, Z
    1650:	8f 5f       	subi	r24, 0xFF	; 255
    1652:	eb 81       	ldd	r30, Y+3	; 0x03
    1654:	fc 81       	ldd	r31, Y+4	; 0x04
    1656:	80 83       	st	Z, r24
}
    1658:	26 96       	adiw	r28, 0x06	; 6
    165a:	0f b6       	in	r0, 0x3f	; 63
    165c:	f8 94       	cli
    165e:	de bf       	out	0x3e, r29	; 62
    1660:	0f be       	out	0x3f, r0	; 63
    1662:	cd bf       	out	0x3d, r28	; 61
    1664:	cf 91       	pop	r28
    1666:	df 91       	pop	r29
    1668:	08 95       	ret

0000166a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    166a:	df 93       	push	r29
    166c:	cf 93       	push	r28
    166e:	cd b7       	in	r28, 0x3d	; 61
    1670:	de b7       	in	r29, 0x3e	; 62
    1672:	28 97       	sbiw	r28, 0x08	; 8
    1674:	0f b6       	in	r0, 0x3f	; 63
    1676:	f8 94       	cli
    1678:	de bf       	out	0x3e, r29	; 62
    167a:	0f be       	out	0x3f, r0	; 63
    167c:	cd bf       	out	0x3d, r28	; 61
    167e:	9e 83       	std	Y+6, r25	; 0x06
    1680:	8d 83       	std	Y+5, r24	; 0x05
    1682:	78 87       	std	Y+8, r23	; 0x08
    1684:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1686:	ef 81       	ldd	r30, Y+7	; 0x07
    1688:	f8 85       	ldd	r31, Y+8	; 0x08
    168a:	80 81       	ld	r24, Z
    168c:	91 81       	ldd	r25, Z+1	; 0x01
    168e:	9a 83       	std	Y+2, r25	; 0x02
    1690:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1692:	89 81       	ldd	r24, Y+1	; 0x01
    1694:	9a 81       	ldd	r25, Y+2	; 0x02
    1696:	2f ef       	ldi	r18, 0xFF	; 255
    1698:	8f 3f       	cpi	r24, 0xFF	; 255
    169a:	92 07       	cpc	r25, r18
    169c:	39 f4       	brne	.+14     	; 0x16ac <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    169e:	ed 81       	ldd	r30, Y+5	; 0x05
    16a0:	fe 81       	ldd	r31, Y+6	; 0x06
    16a2:	87 81       	ldd	r24, Z+7	; 0x07
    16a4:	90 85       	ldd	r25, Z+8	; 0x08
    16a6:	9c 83       	std	Y+4, r25	; 0x04
    16a8:	8b 83       	std	Y+3, r24	; 0x03
    16aa:	18 c0       	rjmp	.+48     	; 0x16dc <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    16ac:	8d 81       	ldd	r24, Y+5	; 0x05
    16ae:	9e 81       	ldd	r25, Y+6	; 0x06
    16b0:	03 96       	adiw	r24, 0x03	; 3
    16b2:	9c 83       	std	Y+4, r25	; 0x04
    16b4:	8b 83       	std	Y+3, r24	; 0x03
    16b6:	06 c0       	rjmp	.+12     	; 0x16c4 <vListInsert+0x5a>
    16b8:	eb 81       	ldd	r30, Y+3	; 0x03
    16ba:	fc 81       	ldd	r31, Y+4	; 0x04
    16bc:	82 81       	ldd	r24, Z+2	; 0x02
    16be:	93 81       	ldd	r25, Z+3	; 0x03
    16c0:	9c 83       	std	Y+4, r25	; 0x04
    16c2:	8b 83       	std	Y+3, r24	; 0x03
    16c4:	eb 81       	ldd	r30, Y+3	; 0x03
    16c6:	fc 81       	ldd	r31, Y+4	; 0x04
    16c8:	02 80       	ldd	r0, Z+2	; 0x02
    16ca:	f3 81       	ldd	r31, Z+3	; 0x03
    16cc:	e0 2d       	mov	r30, r0
    16ce:	20 81       	ld	r18, Z
    16d0:	31 81       	ldd	r19, Z+1	; 0x01
    16d2:	89 81       	ldd	r24, Y+1	; 0x01
    16d4:	9a 81       	ldd	r25, Y+2	; 0x02
    16d6:	82 17       	cp	r24, r18
    16d8:	93 07       	cpc	r25, r19
    16da:	70 f7       	brcc	.-36     	; 0x16b8 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    16dc:	eb 81       	ldd	r30, Y+3	; 0x03
    16de:	fc 81       	ldd	r31, Y+4	; 0x04
    16e0:	82 81       	ldd	r24, Z+2	; 0x02
    16e2:	93 81       	ldd	r25, Z+3	; 0x03
    16e4:	ef 81       	ldd	r30, Y+7	; 0x07
    16e6:	f8 85       	ldd	r31, Y+8	; 0x08
    16e8:	93 83       	std	Z+3, r25	; 0x03
    16ea:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    16ec:	ef 81       	ldd	r30, Y+7	; 0x07
    16ee:	f8 85       	ldd	r31, Y+8	; 0x08
    16f0:	02 80       	ldd	r0, Z+2	; 0x02
    16f2:	f3 81       	ldd	r31, Z+3	; 0x03
    16f4:	e0 2d       	mov	r30, r0
    16f6:	8f 81       	ldd	r24, Y+7	; 0x07
    16f8:	98 85       	ldd	r25, Y+8	; 0x08
    16fa:	95 83       	std	Z+5, r25	; 0x05
    16fc:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    16fe:	ef 81       	ldd	r30, Y+7	; 0x07
    1700:	f8 85       	ldd	r31, Y+8	; 0x08
    1702:	8b 81       	ldd	r24, Y+3	; 0x03
    1704:	9c 81       	ldd	r25, Y+4	; 0x04
    1706:	95 83       	std	Z+5, r25	; 0x05
    1708:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    170a:	8f 81       	ldd	r24, Y+7	; 0x07
    170c:	98 85       	ldd	r25, Y+8	; 0x08
    170e:	eb 81       	ldd	r30, Y+3	; 0x03
    1710:	fc 81       	ldd	r31, Y+4	; 0x04
    1712:	93 83       	std	Z+3, r25	; 0x03
    1714:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1716:	ef 81       	ldd	r30, Y+7	; 0x07
    1718:	f8 85       	ldd	r31, Y+8	; 0x08
    171a:	8d 81       	ldd	r24, Y+5	; 0x05
    171c:	9e 81       	ldd	r25, Y+6	; 0x06
    171e:	91 87       	std	Z+9, r25	; 0x09
    1720:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1722:	ed 81       	ldd	r30, Y+5	; 0x05
    1724:	fe 81       	ldd	r31, Y+6	; 0x06
    1726:	80 81       	ld	r24, Z
    1728:	8f 5f       	subi	r24, 0xFF	; 255
    172a:	ed 81       	ldd	r30, Y+5	; 0x05
    172c:	fe 81       	ldd	r31, Y+6	; 0x06
    172e:	80 83       	st	Z, r24
}
    1730:	28 96       	adiw	r28, 0x08	; 8
    1732:	0f b6       	in	r0, 0x3f	; 63
    1734:	f8 94       	cli
    1736:	de bf       	out	0x3e, r29	; 62
    1738:	0f be       	out	0x3f, r0	; 63
    173a:	cd bf       	out	0x3d, r28	; 61
    173c:	cf 91       	pop	r28
    173e:	df 91       	pop	r29
    1740:	08 95       	ret

00001742 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1742:	df 93       	push	r29
    1744:	cf 93       	push	r28
    1746:	00 d0       	rcall	.+0      	; 0x1748 <vListRemove+0x6>
    1748:	00 d0       	rcall	.+0      	; 0x174a <vListRemove+0x8>
    174a:	cd b7       	in	r28, 0x3d	; 61
    174c:	de b7       	in	r29, 0x3e	; 62
    174e:	9c 83       	std	Y+4, r25	; 0x04
    1750:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1752:	eb 81       	ldd	r30, Y+3	; 0x03
    1754:	fc 81       	ldd	r31, Y+4	; 0x04
    1756:	a2 81       	ldd	r26, Z+2	; 0x02
    1758:	b3 81       	ldd	r27, Z+3	; 0x03
    175a:	eb 81       	ldd	r30, Y+3	; 0x03
    175c:	fc 81       	ldd	r31, Y+4	; 0x04
    175e:	84 81       	ldd	r24, Z+4	; 0x04
    1760:	95 81       	ldd	r25, Z+5	; 0x05
    1762:	15 96       	adiw	r26, 0x05	; 5
    1764:	9c 93       	st	X, r25
    1766:	8e 93       	st	-X, r24
    1768:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    176a:	eb 81       	ldd	r30, Y+3	; 0x03
    176c:	fc 81       	ldd	r31, Y+4	; 0x04
    176e:	a4 81       	ldd	r26, Z+4	; 0x04
    1770:	b5 81       	ldd	r27, Z+5	; 0x05
    1772:	eb 81       	ldd	r30, Y+3	; 0x03
    1774:	fc 81       	ldd	r31, Y+4	; 0x04
    1776:	82 81       	ldd	r24, Z+2	; 0x02
    1778:	93 81       	ldd	r25, Z+3	; 0x03
    177a:	13 96       	adiw	r26, 0x03	; 3
    177c:	9c 93       	st	X, r25
    177e:	8e 93       	st	-X, r24
    1780:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1782:	eb 81       	ldd	r30, Y+3	; 0x03
    1784:	fc 81       	ldd	r31, Y+4	; 0x04
    1786:	80 85       	ldd	r24, Z+8	; 0x08
    1788:	91 85       	ldd	r25, Z+9	; 0x09
    178a:	9a 83       	std	Y+2, r25	; 0x02
    178c:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    178e:	e9 81       	ldd	r30, Y+1	; 0x01
    1790:	fa 81       	ldd	r31, Y+2	; 0x02
    1792:	21 81       	ldd	r18, Z+1	; 0x01
    1794:	32 81       	ldd	r19, Z+2	; 0x02
    1796:	8b 81       	ldd	r24, Y+3	; 0x03
    1798:	9c 81       	ldd	r25, Y+4	; 0x04
    179a:	28 17       	cp	r18, r24
    179c:	39 07       	cpc	r19, r25
    179e:	41 f4       	brne	.+16     	; 0x17b0 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    17a0:	eb 81       	ldd	r30, Y+3	; 0x03
    17a2:	fc 81       	ldd	r31, Y+4	; 0x04
    17a4:	84 81       	ldd	r24, Z+4	; 0x04
    17a6:	95 81       	ldd	r25, Z+5	; 0x05
    17a8:	e9 81       	ldd	r30, Y+1	; 0x01
    17aa:	fa 81       	ldd	r31, Y+2	; 0x02
    17ac:	92 83       	std	Z+2, r25	; 0x02
    17ae:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    17b0:	eb 81       	ldd	r30, Y+3	; 0x03
    17b2:	fc 81       	ldd	r31, Y+4	; 0x04
    17b4:	11 86       	std	Z+9, r1	; 0x09
    17b6:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    17b8:	e9 81       	ldd	r30, Y+1	; 0x01
    17ba:	fa 81       	ldd	r31, Y+2	; 0x02
    17bc:	80 81       	ld	r24, Z
    17be:	81 50       	subi	r24, 0x01	; 1
    17c0:	e9 81       	ldd	r30, Y+1	; 0x01
    17c2:	fa 81       	ldd	r31, Y+2	; 0x02
    17c4:	80 83       	st	Z, r24
}
    17c6:	0f 90       	pop	r0
    17c8:	0f 90       	pop	r0
    17ca:	0f 90       	pop	r0
    17cc:	0f 90       	pop	r0
    17ce:	cf 91       	pop	r28
    17d0:	df 91       	pop	r29
    17d2:	08 95       	ret

000017d4 <main>:
#define TASK2_STACK_SIZE (configMINIMAL_STACK_SIZE * 2)
#define TASK3_STACK_SIZE (configMINIMAL_STACK_SIZE * 2)


void main(void)
{
    17d4:	af 92       	push	r10
    17d6:	bf 92       	push	r11
    17d8:	cf 92       	push	r12
    17da:	df 92       	push	r13
    17dc:	ef 92       	push	r14
    17de:	ff 92       	push	r15
    17e0:	0f 93       	push	r16
    17e2:	df 93       	push	r29
    17e4:	cf 93       	push	r28
    17e6:	cd b7       	in	r28, 0x3d	; 61
    17e8:	de b7       	in	r29, 0x3e	; 62
	PORT_voidInit();
    17ea:	0e 94 4a 07 	call	0xe94	; 0xe94 <PORT_voidInit>
	xTaskCreate(LED1,NULL,TASK1_STACK_SIZE,NULL,TASK1_PRIORITY,NULL);
    17ee:	86 e3       	ldi	r24, 0x36	; 54
    17f0:	9c e0       	ldi	r25, 0x0C	; 12
    17f2:	60 e0       	ldi	r22, 0x00	; 0
    17f4:	70 e0       	ldi	r23, 0x00	; 0
    17f6:	4a ea       	ldi	r20, 0xAA	; 170
    17f8:	50 e0       	ldi	r21, 0x00	; 0
    17fa:	20 e0       	ldi	r18, 0x00	; 0
    17fc:	30 e0       	ldi	r19, 0x00	; 0
    17fe:	02 e0       	ldi	r16, 0x02	; 2
    1800:	ee 24       	eor	r14, r14
    1802:	ff 24       	eor	r15, r15
    1804:	cc 24       	eor	r12, r12
    1806:	dd 24       	eor	r13, r13
    1808:	aa 24       	eor	r10, r10
    180a:	bb 24       	eor	r11, r11
    180c:	0e 94 bf 13 	call	0x277e	; 0x277e <xTaskGenericCreate>
	xTaskCreate(LED2,NULL,TASK2_STACK_SIZE,NULL,TASK2_PRIORITY,NULL);
    1810:	88 e4       	ldi	r24, 0x48	; 72
    1812:	9c e0       	ldi	r25, 0x0C	; 12
    1814:	60 e0       	ldi	r22, 0x00	; 0
    1816:	70 e0       	ldi	r23, 0x00	; 0
    1818:	4a ea       	ldi	r20, 0xAA	; 170
    181a:	50 e0       	ldi	r21, 0x00	; 0
    181c:	20 e0       	ldi	r18, 0x00	; 0
    181e:	30 e0       	ldi	r19, 0x00	; 0
    1820:	01 e0       	ldi	r16, 0x01	; 1
    1822:	ee 24       	eor	r14, r14
    1824:	ff 24       	eor	r15, r15
    1826:	cc 24       	eor	r12, r12
    1828:	dd 24       	eor	r13, r13
    182a:	aa 24       	eor	r10, r10
    182c:	bb 24       	eor	r11, r11
    182e:	0e 94 bf 13 	call	0x277e	; 0x277e <xTaskGenericCreate>
	xTaskCreate(LED3,NULL,TASK3_STACK_SIZE,NULL,TASK3_PRIORITY,NULL);
    1832:	8a e5       	ldi	r24, 0x5A	; 90
    1834:	9c e0       	ldi	r25, 0x0C	; 12
    1836:	60 e0       	ldi	r22, 0x00	; 0
    1838:	70 e0       	ldi	r23, 0x00	; 0
    183a:	4a ea       	ldi	r20, 0xAA	; 170
    183c:	50 e0       	ldi	r21, 0x00	; 0
    183e:	20 e0       	ldi	r18, 0x00	; 0
    1840:	30 e0       	ldi	r19, 0x00	; 0
    1842:	00 e0       	ldi	r16, 0x00	; 0
    1844:	ee 24       	eor	r14, r14
    1846:	ff 24       	eor	r15, r15
    1848:	cc 24       	eor	r12, r12
    184a:	dd 24       	eor	r13, r13
    184c:	aa 24       	eor	r10, r10
    184e:	bb 24       	eor	r11, r11
    1850:	0e 94 bf 13 	call	0x277e	; 0x277e <xTaskGenericCreate>

	vTaskStartScheduler();
    1854:	0e 94 b8 15 	call	0x2b70	; 0x2b70 <vTaskStartScheduler>
}
    1858:	cf 91       	pop	r28
    185a:	df 91       	pop	r29
    185c:	0f 91       	pop	r16
    185e:	ff 90       	pop	r15
    1860:	ef 90       	pop	r14
    1862:	df 90       	pop	r13
    1864:	cf 90       	pop	r12
    1866:	bf 90       	pop	r11
    1868:	af 90       	pop	r10
    186a:	08 95       	ret

0000186c <LED1>:

void LED1(void *pv)
{
    186c:	df 93       	push	r29
    186e:	cf 93       	push	r28
    1870:	00 d0       	rcall	.+0      	; 0x1872 <LED1+0x6>
    1872:	cd b7       	in	r28, 0x3d	; 61
    1874:	de b7       	in	r29, 0x3e	; 62
    1876:	9a 83       	std	Y+2, r25	; 0x02
    1878:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		DIO_enumTogglePinValue(PORTA,DIO_PIN0);
    187a:	eb e3       	ldi	r30, 0x3B	; 59
    187c:	f0 e0       	ldi	r31, 0x00	; 0
    187e:	80 81       	ld	r24, Z
    1880:	60 e0       	ldi	r22, 0x00	; 0
    1882:	0e 94 2c 03 	call	0x658	; 0x658 <DIO_enumTogglePinValue>
		vTaskDelay(1000);
    1886:	88 ee       	ldi	r24, 0xE8	; 232
    1888:	93 e0       	ldi	r25, 0x03	; 3
    188a:	0e 94 83 15 	call	0x2b06	; 0x2b06 <vTaskDelay>
    188e:	f5 cf       	rjmp	.-22     	; 0x187a <LED1+0xe>

00001890 <LED2>:
	}
}
void LED2(void *pv)
{
    1890:	df 93       	push	r29
    1892:	cf 93       	push	r28
    1894:	00 d0       	rcall	.+0      	; 0x1896 <LED2+0x6>
    1896:	cd b7       	in	r28, 0x3d	; 61
    1898:	de b7       	in	r29, 0x3e	; 62
    189a:	9a 83       	std	Y+2, r25	; 0x02
    189c:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		DIO_enumTogglePinValue(PORTA,DIO_PIN1);
    189e:	eb e3       	ldi	r30, 0x3B	; 59
    18a0:	f0 e0       	ldi	r31, 0x00	; 0
    18a2:	80 81       	ld	r24, Z
    18a4:	61 e0       	ldi	r22, 0x01	; 1
    18a6:	0e 94 2c 03 	call	0x658	; 0x658 <DIO_enumTogglePinValue>
		vTaskDelay(2000);
    18aa:	80 ed       	ldi	r24, 0xD0	; 208
    18ac:	97 e0       	ldi	r25, 0x07	; 7
    18ae:	0e 94 83 15 	call	0x2b06	; 0x2b06 <vTaskDelay>
    18b2:	f5 cf       	rjmp	.-22     	; 0x189e <LED2+0xe>

000018b4 <LED3>:
	}
}
void LED3(void *pv)
{
    18b4:	df 93       	push	r29
    18b6:	cf 93       	push	r28
    18b8:	00 d0       	rcall	.+0      	; 0x18ba <LED3+0x6>
    18ba:	cd b7       	in	r28, 0x3d	; 61
    18bc:	de b7       	in	r29, 0x3e	; 62
    18be:	9a 83       	std	Y+2, r25	; 0x02
    18c0:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		DIO_enumTogglePinValue(PORTA,DIO_PIN2);
    18c2:	eb e3       	ldi	r30, 0x3B	; 59
    18c4:	f0 e0       	ldi	r31, 0x00	; 0
    18c6:	80 81       	ld	r24, Z
    18c8:	62 e0       	ldi	r22, 0x02	; 2
    18ca:	0e 94 2c 03 	call	0x658	; 0x658 <DIO_enumTogglePinValue>
		vTaskDelay(3000);
    18ce:	88 eb       	ldi	r24, 0xB8	; 184
    18d0:	9b e0       	ldi	r25, 0x0B	; 11
    18d2:	0e 94 83 15 	call	0x2b06	; 0x2b06 <vTaskDelay>
    18d6:	f5 cf       	rjmp	.-22     	; 0x18c2 <LED3+0xe>

000018d8 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    18d8:	df 93       	push	r29
    18da:	cf 93       	push	r28
    18dc:	cd b7       	in	r28, 0x3d	; 61
    18de:	de b7       	in	r29, 0x3e	; 62
    18e0:	28 97       	sbiw	r28, 0x08	; 8
    18e2:	0f b6       	in	r0, 0x3f	; 63
    18e4:	f8 94       	cli
    18e6:	de bf       	out	0x3e, r29	; 62
    18e8:	0f be       	out	0x3f, r0	; 63
    18ea:	cd bf       	out	0x3d, r28	; 61
    18ec:	9c 83       	std	Y+4, r25	; 0x04
    18ee:	8b 83       	std	Y+3, r24	; 0x03
    18f0:	7e 83       	std	Y+6, r23	; 0x06
    18f2:	6d 83       	std	Y+5, r22	; 0x05
    18f4:	58 87       	std	Y+8, r21	; 0x08
    18f6:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    18f8:	eb 81       	ldd	r30, Y+3	; 0x03
    18fa:	fc 81       	ldd	r31, Y+4	; 0x04
    18fc:	81 e1       	ldi	r24, 0x11	; 17
    18fe:	80 83       	st	Z, r24
	pxTopOfStack--;
    1900:	8b 81       	ldd	r24, Y+3	; 0x03
    1902:	9c 81       	ldd	r25, Y+4	; 0x04
    1904:	01 97       	sbiw	r24, 0x01	; 1
    1906:	9c 83       	std	Y+4, r25	; 0x04
    1908:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    190a:	eb 81       	ldd	r30, Y+3	; 0x03
    190c:	fc 81       	ldd	r31, Y+4	; 0x04
    190e:	82 e2       	ldi	r24, 0x22	; 34
    1910:	80 83       	st	Z, r24
	pxTopOfStack--;
    1912:	8b 81       	ldd	r24, Y+3	; 0x03
    1914:	9c 81       	ldd	r25, Y+4	; 0x04
    1916:	01 97       	sbiw	r24, 0x01	; 1
    1918:	9c 83       	std	Y+4, r25	; 0x04
    191a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    191c:	eb 81       	ldd	r30, Y+3	; 0x03
    191e:	fc 81       	ldd	r31, Y+4	; 0x04
    1920:	83 e3       	ldi	r24, 0x33	; 51
    1922:	80 83       	st	Z, r24
	pxTopOfStack--;
    1924:	8b 81       	ldd	r24, Y+3	; 0x03
    1926:	9c 81       	ldd	r25, Y+4	; 0x04
    1928:	01 97       	sbiw	r24, 0x01	; 1
    192a:	9c 83       	std	Y+4, r25	; 0x04
    192c:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    192e:	8d 81       	ldd	r24, Y+5	; 0x05
    1930:	9e 81       	ldd	r25, Y+6	; 0x06
    1932:	9a 83       	std	Y+2, r25	; 0x02
    1934:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1936:	89 81       	ldd	r24, Y+1	; 0x01
    1938:	eb 81       	ldd	r30, Y+3	; 0x03
    193a:	fc 81       	ldd	r31, Y+4	; 0x04
    193c:	80 83       	st	Z, r24
	pxTopOfStack--;
    193e:	8b 81       	ldd	r24, Y+3	; 0x03
    1940:	9c 81       	ldd	r25, Y+4	; 0x04
    1942:	01 97       	sbiw	r24, 0x01	; 1
    1944:	9c 83       	std	Y+4, r25	; 0x04
    1946:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1948:	89 81       	ldd	r24, Y+1	; 0x01
    194a:	9a 81       	ldd	r25, Y+2	; 0x02
    194c:	89 2f       	mov	r24, r25
    194e:	99 27       	eor	r25, r25
    1950:	9a 83       	std	Y+2, r25	; 0x02
    1952:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1954:	89 81       	ldd	r24, Y+1	; 0x01
    1956:	eb 81       	ldd	r30, Y+3	; 0x03
    1958:	fc 81       	ldd	r31, Y+4	; 0x04
    195a:	80 83       	st	Z, r24
	pxTopOfStack--;
    195c:	8b 81       	ldd	r24, Y+3	; 0x03
    195e:	9c 81       	ldd	r25, Y+4	; 0x04
    1960:	01 97       	sbiw	r24, 0x01	; 1
    1962:	9c 83       	std	Y+4, r25	; 0x04
    1964:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    1966:	eb 81       	ldd	r30, Y+3	; 0x03
    1968:	fc 81       	ldd	r31, Y+4	; 0x04
    196a:	10 82       	st	Z, r1
	pxTopOfStack--;
    196c:	8b 81       	ldd	r24, Y+3	; 0x03
    196e:	9c 81       	ldd	r25, Y+4	; 0x04
    1970:	01 97       	sbiw	r24, 0x01	; 1
    1972:	9c 83       	std	Y+4, r25	; 0x04
    1974:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1976:	eb 81       	ldd	r30, Y+3	; 0x03
    1978:	fc 81       	ldd	r31, Y+4	; 0x04
    197a:	80 e8       	ldi	r24, 0x80	; 128
    197c:	80 83       	st	Z, r24
	pxTopOfStack--;
    197e:	8b 81       	ldd	r24, Y+3	; 0x03
    1980:	9c 81       	ldd	r25, Y+4	; 0x04
    1982:	01 97       	sbiw	r24, 0x01	; 1
    1984:	9c 83       	std	Y+4, r25	; 0x04
    1986:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    1988:	eb 81       	ldd	r30, Y+3	; 0x03
    198a:	fc 81       	ldd	r31, Y+4	; 0x04
    198c:	10 82       	st	Z, r1
	pxTopOfStack--;
    198e:	8b 81       	ldd	r24, Y+3	; 0x03
    1990:	9c 81       	ldd	r25, Y+4	; 0x04
    1992:	01 97       	sbiw	r24, 0x01	; 1
    1994:	9c 83       	std	Y+4, r25	; 0x04
    1996:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    1998:	eb 81       	ldd	r30, Y+3	; 0x03
    199a:	fc 81       	ldd	r31, Y+4	; 0x04
    199c:	82 e0       	ldi	r24, 0x02	; 2
    199e:	80 83       	st	Z, r24
	pxTopOfStack--;
    19a0:	8b 81       	ldd	r24, Y+3	; 0x03
    19a2:	9c 81       	ldd	r25, Y+4	; 0x04
    19a4:	01 97       	sbiw	r24, 0x01	; 1
    19a6:	9c 83       	std	Y+4, r25	; 0x04
    19a8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    19aa:	eb 81       	ldd	r30, Y+3	; 0x03
    19ac:	fc 81       	ldd	r31, Y+4	; 0x04
    19ae:	83 e0       	ldi	r24, 0x03	; 3
    19b0:	80 83       	st	Z, r24
	pxTopOfStack--;
    19b2:	8b 81       	ldd	r24, Y+3	; 0x03
    19b4:	9c 81       	ldd	r25, Y+4	; 0x04
    19b6:	01 97       	sbiw	r24, 0x01	; 1
    19b8:	9c 83       	std	Y+4, r25	; 0x04
    19ba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    19bc:	eb 81       	ldd	r30, Y+3	; 0x03
    19be:	fc 81       	ldd	r31, Y+4	; 0x04
    19c0:	84 e0       	ldi	r24, 0x04	; 4
    19c2:	80 83       	st	Z, r24
	pxTopOfStack--;
    19c4:	8b 81       	ldd	r24, Y+3	; 0x03
    19c6:	9c 81       	ldd	r25, Y+4	; 0x04
    19c8:	01 97       	sbiw	r24, 0x01	; 1
    19ca:	9c 83       	std	Y+4, r25	; 0x04
    19cc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    19ce:	eb 81       	ldd	r30, Y+3	; 0x03
    19d0:	fc 81       	ldd	r31, Y+4	; 0x04
    19d2:	85 e0       	ldi	r24, 0x05	; 5
    19d4:	80 83       	st	Z, r24
	pxTopOfStack--;
    19d6:	8b 81       	ldd	r24, Y+3	; 0x03
    19d8:	9c 81       	ldd	r25, Y+4	; 0x04
    19da:	01 97       	sbiw	r24, 0x01	; 1
    19dc:	9c 83       	std	Y+4, r25	; 0x04
    19de:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    19e0:	eb 81       	ldd	r30, Y+3	; 0x03
    19e2:	fc 81       	ldd	r31, Y+4	; 0x04
    19e4:	86 e0       	ldi	r24, 0x06	; 6
    19e6:	80 83       	st	Z, r24
	pxTopOfStack--;
    19e8:	8b 81       	ldd	r24, Y+3	; 0x03
    19ea:	9c 81       	ldd	r25, Y+4	; 0x04
    19ec:	01 97       	sbiw	r24, 0x01	; 1
    19ee:	9c 83       	std	Y+4, r25	; 0x04
    19f0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    19f2:	eb 81       	ldd	r30, Y+3	; 0x03
    19f4:	fc 81       	ldd	r31, Y+4	; 0x04
    19f6:	87 e0       	ldi	r24, 0x07	; 7
    19f8:	80 83       	st	Z, r24
	pxTopOfStack--;
    19fa:	8b 81       	ldd	r24, Y+3	; 0x03
    19fc:	9c 81       	ldd	r25, Y+4	; 0x04
    19fe:	01 97       	sbiw	r24, 0x01	; 1
    1a00:	9c 83       	std	Y+4, r25	; 0x04
    1a02:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    1a04:	eb 81       	ldd	r30, Y+3	; 0x03
    1a06:	fc 81       	ldd	r31, Y+4	; 0x04
    1a08:	88 e0       	ldi	r24, 0x08	; 8
    1a0a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a0c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a0e:	9c 81       	ldd	r25, Y+4	; 0x04
    1a10:	01 97       	sbiw	r24, 0x01	; 1
    1a12:	9c 83       	std	Y+4, r25	; 0x04
    1a14:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    1a16:	eb 81       	ldd	r30, Y+3	; 0x03
    1a18:	fc 81       	ldd	r31, Y+4	; 0x04
    1a1a:	89 e0       	ldi	r24, 0x09	; 9
    1a1c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a1e:	8b 81       	ldd	r24, Y+3	; 0x03
    1a20:	9c 81       	ldd	r25, Y+4	; 0x04
    1a22:	01 97       	sbiw	r24, 0x01	; 1
    1a24:	9c 83       	std	Y+4, r25	; 0x04
    1a26:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    1a28:	eb 81       	ldd	r30, Y+3	; 0x03
    1a2a:	fc 81       	ldd	r31, Y+4	; 0x04
    1a2c:	80 e1       	ldi	r24, 0x10	; 16
    1a2e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a30:	8b 81       	ldd	r24, Y+3	; 0x03
    1a32:	9c 81       	ldd	r25, Y+4	; 0x04
    1a34:	01 97       	sbiw	r24, 0x01	; 1
    1a36:	9c 83       	std	Y+4, r25	; 0x04
    1a38:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    1a3a:	eb 81       	ldd	r30, Y+3	; 0x03
    1a3c:	fc 81       	ldd	r31, Y+4	; 0x04
    1a3e:	81 e1       	ldi	r24, 0x11	; 17
    1a40:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a42:	8b 81       	ldd	r24, Y+3	; 0x03
    1a44:	9c 81       	ldd	r25, Y+4	; 0x04
    1a46:	01 97       	sbiw	r24, 0x01	; 1
    1a48:	9c 83       	std	Y+4, r25	; 0x04
    1a4a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    1a4c:	eb 81       	ldd	r30, Y+3	; 0x03
    1a4e:	fc 81       	ldd	r31, Y+4	; 0x04
    1a50:	82 e1       	ldi	r24, 0x12	; 18
    1a52:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a54:	8b 81       	ldd	r24, Y+3	; 0x03
    1a56:	9c 81       	ldd	r25, Y+4	; 0x04
    1a58:	01 97       	sbiw	r24, 0x01	; 1
    1a5a:	9c 83       	std	Y+4, r25	; 0x04
    1a5c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    1a5e:	eb 81       	ldd	r30, Y+3	; 0x03
    1a60:	fc 81       	ldd	r31, Y+4	; 0x04
    1a62:	83 e1       	ldi	r24, 0x13	; 19
    1a64:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a66:	8b 81       	ldd	r24, Y+3	; 0x03
    1a68:	9c 81       	ldd	r25, Y+4	; 0x04
    1a6a:	01 97       	sbiw	r24, 0x01	; 1
    1a6c:	9c 83       	std	Y+4, r25	; 0x04
    1a6e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    1a70:	eb 81       	ldd	r30, Y+3	; 0x03
    1a72:	fc 81       	ldd	r31, Y+4	; 0x04
    1a74:	84 e1       	ldi	r24, 0x14	; 20
    1a76:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a78:	8b 81       	ldd	r24, Y+3	; 0x03
    1a7a:	9c 81       	ldd	r25, Y+4	; 0x04
    1a7c:	01 97       	sbiw	r24, 0x01	; 1
    1a7e:	9c 83       	std	Y+4, r25	; 0x04
    1a80:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    1a82:	eb 81       	ldd	r30, Y+3	; 0x03
    1a84:	fc 81       	ldd	r31, Y+4	; 0x04
    1a86:	85 e1       	ldi	r24, 0x15	; 21
    1a88:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a8a:	8b 81       	ldd	r24, Y+3	; 0x03
    1a8c:	9c 81       	ldd	r25, Y+4	; 0x04
    1a8e:	01 97       	sbiw	r24, 0x01	; 1
    1a90:	9c 83       	std	Y+4, r25	; 0x04
    1a92:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    1a94:	eb 81       	ldd	r30, Y+3	; 0x03
    1a96:	fc 81       	ldd	r31, Y+4	; 0x04
    1a98:	86 e1       	ldi	r24, 0x16	; 22
    1a9a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a9c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a9e:	9c 81       	ldd	r25, Y+4	; 0x04
    1aa0:	01 97       	sbiw	r24, 0x01	; 1
    1aa2:	9c 83       	std	Y+4, r25	; 0x04
    1aa4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    1aa6:	eb 81       	ldd	r30, Y+3	; 0x03
    1aa8:	fc 81       	ldd	r31, Y+4	; 0x04
    1aaa:	87 e1       	ldi	r24, 0x17	; 23
    1aac:	80 83       	st	Z, r24
	pxTopOfStack--;
    1aae:	8b 81       	ldd	r24, Y+3	; 0x03
    1ab0:	9c 81       	ldd	r25, Y+4	; 0x04
    1ab2:	01 97       	sbiw	r24, 0x01	; 1
    1ab4:	9c 83       	std	Y+4, r25	; 0x04
    1ab6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    1ab8:	eb 81       	ldd	r30, Y+3	; 0x03
    1aba:	fc 81       	ldd	r31, Y+4	; 0x04
    1abc:	88 e1       	ldi	r24, 0x18	; 24
    1abe:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ac0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ac2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ac4:	01 97       	sbiw	r24, 0x01	; 1
    1ac6:	9c 83       	std	Y+4, r25	; 0x04
    1ac8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    1aca:	eb 81       	ldd	r30, Y+3	; 0x03
    1acc:	fc 81       	ldd	r31, Y+4	; 0x04
    1ace:	89 e1       	ldi	r24, 0x19	; 25
    1ad0:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ad2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ad4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ad6:	01 97       	sbiw	r24, 0x01	; 1
    1ad8:	9c 83       	std	Y+4, r25	; 0x04
    1ada:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    1adc:	eb 81       	ldd	r30, Y+3	; 0x03
    1ade:	fc 81       	ldd	r31, Y+4	; 0x04
    1ae0:	80 e2       	ldi	r24, 0x20	; 32
    1ae2:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ae4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ae6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ae8:	01 97       	sbiw	r24, 0x01	; 1
    1aea:	9c 83       	std	Y+4, r25	; 0x04
    1aec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    1aee:	eb 81       	ldd	r30, Y+3	; 0x03
    1af0:	fc 81       	ldd	r31, Y+4	; 0x04
    1af2:	81 e2       	ldi	r24, 0x21	; 33
    1af4:	80 83       	st	Z, r24
	pxTopOfStack--;
    1af6:	8b 81       	ldd	r24, Y+3	; 0x03
    1af8:	9c 81       	ldd	r25, Y+4	; 0x04
    1afa:	01 97       	sbiw	r24, 0x01	; 1
    1afc:	9c 83       	std	Y+4, r25	; 0x04
    1afe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    1b00:	eb 81       	ldd	r30, Y+3	; 0x03
    1b02:	fc 81       	ldd	r31, Y+4	; 0x04
    1b04:	82 e2       	ldi	r24, 0x22	; 34
    1b06:	80 83       	st	Z, r24
	pxTopOfStack--;
    1b08:	8b 81       	ldd	r24, Y+3	; 0x03
    1b0a:	9c 81       	ldd	r25, Y+4	; 0x04
    1b0c:	01 97       	sbiw	r24, 0x01	; 1
    1b0e:	9c 83       	std	Y+4, r25	; 0x04
    1b10:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    1b12:	eb 81       	ldd	r30, Y+3	; 0x03
    1b14:	fc 81       	ldd	r31, Y+4	; 0x04
    1b16:	83 e2       	ldi	r24, 0x23	; 35
    1b18:	80 83       	st	Z, r24
	pxTopOfStack--;
    1b1a:	8b 81       	ldd	r24, Y+3	; 0x03
    1b1c:	9c 81       	ldd	r25, Y+4	; 0x04
    1b1e:	01 97       	sbiw	r24, 0x01	; 1
    1b20:	9c 83       	std	Y+4, r25	; 0x04
    1b22:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    1b24:	8f 81       	ldd	r24, Y+7	; 0x07
    1b26:	98 85       	ldd	r25, Y+8	; 0x08
    1b28:	9a 83       	std	Y+2, r25	; 0x02
    1b2a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1b2c:	89 81       	ldd	r24, Y+1	; 0x01
    1b2e:	eb 81       	ldd	r30, Y+3	; 0x03
    1b30:	fc 81       	ldd	r31, Y+4	; 0x04
    1b32:	80 83       	st	Z, r24
	pxTopOfStack--;
    1b34:	8b 81       	ldd	r24, Y+3	; 0x03
    1b36:	9c 81       	ldd	r25, Y+4	; 0x04
    1b38:	01 97       	sbiw	r24, 0x01	; 1
    1b3a:	9c 83       	std	Y+4, r25	; 0x04
    1b3c:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1b3e:	89 81       	ldd	r24, Y+1	; 0x01
    1b40:	9a 81       	ldd	r25, Y+2	; 0x02
    1b42:	89 2f       	mov	r24, r25
    1b44:	99 27       	eor	r25, r25
    1b46:	9a 83       	std	Y+2, r25	; 0x02
    1b48:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1b4a:	89 81       	ldd	r24, Y+1	; 0x01
    1b4c:	eb 81       	ldd	r30, Y+3	; 0x03
    1b4e:	fc 81       	ldd	r31, Y+4	; 0x04
    1b50:	80 83       	st	Z, r24
	pxTopOfStack--;
    1b52:	8b 81       	ldd	r24, Y+3	; 0x03
    1b54:	9c 81       	ldd	r25, Y+4	; 0x04
    1b56:	01 97       	sbiw	r24, 0x01	; 1
    1b58:	9c 83       	std	Y+4, r25	; 0x04
    1b5a:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    1b5c:	eb 81       	ldd	r30, Y+3	; 0x03
    1b5e:	fc 81       	ldd	r31, Y+4	; 0x04
    1b60:	86 e2       	ldi	r24, 0x26	; 38
    1b62:	80 83       	st	Z, r24
	pxTopOfStack--;
    1b64:	8b 81       	ldd	r24, Y+3	; 0x03
    1b66:	9c 81       	ldd	r25, Y+4	; 0x04
    1b68:	01 97       	sbiw	r24, 0x01	; 1
    1b6a:	9c 83       	std	Y+4, r25	; 0x04
    1b6c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    1b6e:	eb 81       	ldd	r30, Y+3	; 0x03
    1b70:	fc 81       	ldd	r31, Y+4	; 0x04
    1b72:	87 e2       	ldi	r24, 0x27	; 39
    1b74:	80 83       	st	Z, r24
	pxTopOfStack--;
    1b76:	8b 81       	ldd	r24, Y+3	; 0x03
    1b78:	9c 81       	ldd	r25, Y+4	; 0x04
    1b7a:	01 97       	sbiw	r24, 0x01	; 1
    1b7c:	9c 83       	std	Y+4, r25	; 0x04
    1b7e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    1b80:	eb 81       	ldd	r30, Y+3	; 0x03
    1b82:	fc 81       	ldd	r31, Y+4	; 0x04
    1b84:	88 e2       	ldi	r24, 0x28	; 40
    1b86:	80 83       	st	Z, r24
	pxTopOfStack--;
    1b88:	8b 81       	ldd	r24, Y+3	; 0x03
    1b8a:	9c 81       	ldd	r25, Y+4	; 0x04
    1b8c:	01 97       	sbiw	r24, 0x01	; 1
    1b8e:	9c 83       	std	Y+4, r25	; 0x04
    1b90:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    1b92:	eb 81       	ldd	r30, Y+3	; 0x03
    1b94:	fc 81       	ldd	r31, Y+4	; 0x04
    1b96:	89 e2       	ldi	r24, 0x29	; 41
    1b98:	80 83       	st	Z, r24
	pxTopOfStack--;
    1b9a:	8b 81       	ldd	r24, Y+3	; 0x03
    1b9c:	9c 81       	ldd	r25, Y+4	; 0x04
    1b9e:	01 97       	sbiw	r24, 0x01	; 1
    1ba0:	9c 83       	std	Y+4, r25	; 0x04
    1ba2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    1ba4:	eb 81       	ldd	r30, Y+3	; 0x03
    1ba6:	fc 81       	ldd	r31, Y+4	; 0x04
    1ba8:	80 e3       	ldi	r24, 0x30	; 48
    1baa:	80 83       	st	Z, r24
	pxTopOfStack--;
    1bac:	8b 81       	ldd	r24, Y+3	; 0x03
    1bae:	9c 81       	ldd	r25, Y+4	; 0x04
    1bb0:	01 97       	sbiw	r24, 0x01	; 1
    1bb2:	9c 83       	std	Y+4, r25	; 0x04
    1bb4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    1bb6:	eb 81       	ldd	r30, Y+3	; 0x03
    1bb8:	fc 81       	ldd	r31, Y+4	; 0x04
    1bba:	81 e3       	ldi	r24, 0x31	; 49
    1bbc:	80 83       	st	Z, r24
	pxTopOfStack--;
    1bbe:	8b 81       	ldd	r24, Y+3	; 0x03
    1bc0:	9c 81       	ldd	r25, Y+4	; 0x04
    1bc2:	01 97       	sbiw	r24, 0x01	; 1
    1bc4:	9c 83       	std	Y+4, r25	; 0x04
    1bc6:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1bc8:	8b 81       	ldd	r24, Y+3	; 0x03
    1bca:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1bcc:	28 96       	adiw	r28, 0x08	; 8
    1bce:	0f b6       	in	r0, 0x3f	; 63
    1bd0:	f8 94       	cli
    1bd2:	de bf       	out	0x3e, r29	; 62
    1bd4:	0f be       	out	0x3f, r0	; 63
    1bd6:	cd bf       	out	0x3d, r28	; 61
    1bd8:	cf 91       	pop	r28
    1bda:	df 91       	pop	r29
    1bdc:	08 95       	ret

00001bde <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    1bde:	df 93       	push	r29
    1be0:	cf 93       	push	r28
    1be2:	cd b7       	in	r28, 0x3d	; 61
    1be4:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    1be6:	0e 94 df 0e 	call	0x1dbe	; 0x1dbe <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1bea:	a0 91 fc 02 	lds	r26, 0x02FC
    1bee:	b0 91 fd 02 	lds	r27, 0x02FD
    1bf2:	cd 91       	ld	r28, X+
    1bf4:	cd bf       	out	0x3d, r28	; 61
    1bf6:	dd 91       	ld	r29, X+
    1bf8:	de bf       	out	0x3e, r29	; 62
    1bfa:	ff 91       	pop	r31
    1bfc:	ef 91       	pop	r30
    1bfe:	df 91       	pop	r29
    1c00:	cf 91       	pop	r28
    1c02:	bf 91       	pop	r27
    1c04:	af 91       	pop	r26
    1c06:	9f 91       	pop	r25
    1c08:	8f 91       	pop	r24
    1c0a:	7f 91       	pop	r23
    1c0c:	6f 91       	pop	r22
    1c0e:	5f 91       	pop	r21
    1c10:	4f 91       	pop	r20
    1c12:	3f 91       	pop	r19
    1c14:	2f 91       	pop	r18
    1c16:	1f 91       	pop	r17
    1c18:	0f 91       	pop	r16
    1c1a:	ff 90       	pop	r15
    1c1c:	ef 90       	pop	r14
    1c1e:	df 90       	pop	r13
    1c20:	cf 90       	pop	r12
    1c22:	bf 90       	pop	r11
    1c24:	af 90       	pop	r10
    1c26:	9f 90       	pop	r9
    1c28:	8f 90       	pop	r8
    1c2a:	7f 90       	pop	r7
    1c2c:	6f 90       	pop	r6
    1c2e:	5f 90       	pop	r5
    1c30:	4f 90       	pop	r4
    1c32:	3f 90       	pop	r3
    1c34:	2f 90       	pop	r2
    1c36:	1f 90       	pop	r1
    1c38:	0f 90       	pop	r0
    1c3a:	0f be       	out	0x3f, r0	; 63
    1c3c:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1c3e:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1c40:	81 e0       	ldi	r24, 0x01	; 1
}
    1c42:	cf 91       	pop	r28
    1c44:	df 91       	pop	r29
    1c46:	08 95       	ret

00001c48 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1c48:	df 93       	push	r29
    1c4a:	cf 93       	push	r28
    1c4c:	cd b7       	in	r28, 0x3d	; 61
    1c4e:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1c50:	cf 91       	pop	r28
    1c52:	df 91       	pop	r29
    1c54:	08 95       	ret

00001c56 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1c56:	0f 92       	push	r0
    1c58:	0f b6       	in	r0, 0x3f	; 63
    1c5a:	f8 94       	cli
    1c5c:	0f 92       	push	r0
    1c5e:	1f 92       	push	r1
    1c60:	11 24       	eor	r1, r1
    1c62:	2f 92       	push	r2
    1c64:	3f 92       	push	r3
    1c66:	4f 92       	push	r4
    1c68:	5f 92       	push	r5
    1c6a:	6f 92       	push	r6
    1c6c:	7f 92       	push	r7
    1c6e:	8f 92       	push	r8
    1c70:	9f 92       	push	r9
    1c72:	af 92       	push	r10
    1c74:	bf 92       	push	r11
    1c76:	cf 92       	push	r12
    1c78:	df 92       	push	r13
    1c7a:	ef 92       	push	r14
    1c7c:	ff 92       	push	r15
    1c7e:	0f 93       	push	r16
    1c80:	1f 93       	push	r17
    1c82:	2f 93       	push	r18
    1c84:	3f 93       	push	r19
    1c86:	4f 93       	push	r20
    1c88:	5f 93       	push	r21
    1c8a:	6f 93       	push	r22
    1c8c:	7f 93       	push	r23
    1c8e:	8f 93       	push	r24
    1c90:	9f 93       	push	r25
    1c92:	af 93       	push	r26
    1c94:	bf 93       	push	r27
    1c96:	cf 93       	push	r28
    1c98:	df 93       	push	r29
    1c9a:	ef 93       	push	r30
    1c9c:	ff 93       	push	r31
    1c9e:	a0 91 fc 02 	lds	r26, 0x02FC
    1ca2:	b0 91 fd 02 	lds	r27, 0x02FD
    1ca6:	0d b6       	in	r0, 0x3d	; 61
    1ca8:	0d 92       	st	X+, r0
    1caa:	0e b6       	in	r0, 0x3e	; 62
    1cac:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1cae:	0e 94 9b 17 	call	0x2f36	; 0x2f36 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1cb2:	a0 91 fc 02 	lds	r26, 0x02FC
    1cb6:	b0 91 fd 02 	lds	r27, 0x02FD
    1cba:	cd 91       	ld	r28, X+
    1cbc:	cd bf       	out	0x3d, r28	; 61
    1cbe:	dd 91       	ld	r29, X+
    1cc0:	de bf       	out	0x3e, r29	; 62
    1cc2:	ff 91       	pop	r31
    1cc4:	ef 91       	pop	r30
    1cc6:	df 91       	pop	r29
    1cc8:	cf 91       	pop	r28
    1cca:	bf 91       	pop	r27
    1ccc:	af 91       	pop	r26
    1cce:	9f 91       	pop	r25
    1cd0:	8f 91       	pop	r24
    1cd2:	7f 91       	pop	r23
    1cd4:	6f 91       	pop	r22
    1cd6:	5f 91       	pop	r21
    1cd8:	4f 91       	pop	r20
    1cda:	3f 91       	pop	r19
    1cdc:	2f 91       	pop	r18
    1cde:	1f 91       	pop	r17
    1ce0:	0f 91       	pop	r16
    1ce2:	ff 90       	pop	r15
    1ce4:	ef 90       	pop	r14
    1ce6:	df 90       	pop	r13
    1ce8:	cf 90       	pop	r12
    1cea:	bf 90       	pop	r11
    1cec:	af 90       	pop	r10
    1cee:	9f 90       	pop	r9
    1cf0:	8f 90       	pop	r8
    1cf2:	7f 90       	pop	r7
    1cf4:	6f 90       	pop	r6
    1cf6:	5f 90       	pop	r5
    1cf8:	4f 90       	pop	r4
    1cfa:	3f 90       	pop	r3
    1cfc:	2f 90       	pop	r2
    1cfe:	1f 90       	pop	r1
    1d00:	0f 90       	pop	r0
    1d02:	0f be       	out	0x3f, r0	; 63
    1d04:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1d06:	08 95       	ret

00001d08 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1d08:	0f 92       	push	r0
    1d0a:	0f b6       	in	r0, 0x3f	; 63
    1d0c:	f8 94       	cli
    1d0e:	0f 92       	push	r0
    1d10:	1f 92       	push	r1
    1d12:	11 24       	eor	r1, r1
    1d14:	2f 92       	push	r2
    1d16:	3f 92       	push	r3
    1d18:	4f 92       	push	r4
    1d1a:	5f 92       	push	r5
    1d1c:	6f 92       	push	r6
    1d1e:	7f 92       	push	r7
    1d20:	8f 92       	push	r8
    1d22:	9f 92       	push	r9
    1d24:	af 92       	push	r10
    1d26:	bf 92       	push	r11
    1d28:	cf 92       	push	r12
    1d2a:	df 92       	push	r13
    1d2c:	ef 92       	push	r14
    1d2e:	ff 92       	push	r15
    1d30:	0f 93       	push	r16
    1d32:	1f 93       	push	r17
    1d34:	2f 93       	push	r18
    1d36:	3f 93       	push	r19
    1d38:	4f 93       	push	r20
    1d3a:	5f 93       	push	r21
    1d3c:	6f 93       	push	r22
    1d3e:	7f 93       	push	r23
    1d40:	8f 93       	push	r24
    1d42:	9f 93       	push	r25
    1d44:	af 93       	push	r26
    1d46:	bf 93       	push	r27
    1d48:	cf 93       	push	r28
    1d4a:	df 93       	push	r29
    1d4c:	ef 93       	push	r30
    1d4e:	ff 93       	push	r31
    1d50:	a0 91 fc 02 	lds	r26, 0x02FC
    1d54:	b0 91 fd 02 	lds	r27, 0x02FD
    1d58:	0d b6       	in	r0, 0x3d	; 61
    1d5a:	0d 92       	st	X+, r0
    1d5c:	0e b6       	in	r0, 0x3e	; 62
    1d5e:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1d60:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <vTaskIncrementTick>
	vTaskSwitchContext();
    1d64:	0e 94 9b 17 	call	0x2f36	; 0x2f36 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1d68:	a0 91 fc 02 	lds	r26, 0x02FC
    1d6c:	b0 91 fd 02 	lds	r27, 0x02FD
    1d70:	cd 91       	ld	r28, X+
    1d72:	cd bf       	out	0x3d, r28	; 61
    1d74:	dd 91       	ld	r29, X+
    1d76:	de bf       	out	0x3e, r29	; 62
    1d78:	ff 91       	pop	r31
    1d7a:	ef 91       	pop	r30
    1d7c:	df 91       	pop	r29
    1d7e:	cf 91       	pop	r28
    1d80:	bf 91       	pop	r27
    1d82:	af 91       	pop	r26
    1d84:	9f 91       	pop	r25
    1d86:	8f 91       	pop	r24
    1d88:	7f 91       	pop	r23
    1d8a:	6f 91       	pop	r22
    1d8c:	5f 91       	pop	r21
    1d8e:	4f 91       	pop	r20
    1d90:	3f 91       	pop	r19
    1d92:	2f 91       	pop	r18
    1d94:	1f 91       	pop	r17
    1d96:	0f 91       	pop	r16
    1d98:	ff 90       	pop	r15
    1d9a:	ef 90       	pop	r14
    1d9c:	df 90       	pop	r13
    1d9e:	cf 90       	pop	r12
    1da0:	bf 90       	pop	r11
    1da2:	af 90       	pop	r10
    1da4:	9f 90       	pop	r9
    1da6:	8f 90       	pop	r8
    1da8:	7f 90       	pop	r7
    1daa:	6f 90       	pop	r6
    1dac:	5f 90       	pop	r5
    1dae:	4f 90       	pop	r4
    1db0:	3f 90       	pop	r3
    1db2:	2f 90       	pop	r2
    1db4:	1f 90       	pop	r1
    1db6:	0f 90       	pop	r0
    1db8:	0f be       	out	0x3f, r0	; 63
    1dba:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1dbc:	08 95       	ret

00001dbe <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1dbe:	df 93       	push	r29
    1dc0:	cf 93       	push	r28
    1dc2:	00 d0       	rcall	.+0      	; 0x1dc4 <prvSetupTimerInterrupt+0x6>
    1dc4:	00 d0       	rcall	.+0      	; 0x1dc6 <prvSetupTimerInterrupt+0x8>
    1dc6:	00 d0       	rcall	.+0      	; 0x1dc8 <prvSetupTimerInterrupt+0xa>
    1dc8:	cd b7       	in	r28, 0x3d	; 61
    1dca:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1dcc:	80 e4       	ldi	r24, 0x40	; 64
    1dce:	9f e1       	ldi	r25, 0x1F	; 31
    1dd0:	a0 e0       	ldi	r26, 0x00	; 0
    1dd2:	b0 e0       	ldi	r27, 0x00	; 0
    1dd4:	8b 83       	std	Y+3, r24	; 0x03
    1dd6:	9c 83       	std	Y+4, r25	; 0x04
    1dd8:	ad 83       	std	Y+5, r26	; 0x05
    1dda:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1ddc:	8b 81       	ldd	r24, Y+3	; 0x03
    1dde:	9c 81       	ldd	r25, Y+4	; 0x04
    1de0:	ad 81       	ldd	r26, Y+5	; 0x05
    1de2:	be 81       	ldd	r27, Y+6	; 0x06
    1de4:	68 94       	set
    1de6:	15 f8       	bld	r1, 5
    1de8:	b6 95       	lsr	r27
    1dea:	a7 95       	ror	r26
    1dec:	97 95       	ror	r25
    1dee:	87 95       	ror	r24
    1df0:	16 94       	lsr	r1
    1df2:	d1 f7       	brne	.-12     	; 0x1de8 <prvSetupTimerInterrupt+0x2a>
    1df4:	8b 83       	std	Y+3, r24	; 0x03
    1df6:	9c 83       	std	Y+4, r25	; 0x04
    1df8:	ad 83       	std	Y+5, r26	; 0x05
    1dfa:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    1dfc:	8b 81       	ldd	r24, Y+3	; 0x03
    1dfe:	9c 81       	ldd	r25, Y+4	; 0x04
    1e00:	ad 81       	ldd	r26, Y+5	; 0x05
    1e02:	be 81       	ldd	r27, Y+6	; 0x06
    1e04:	01 97       	sbiw	r24, 0x01	; 1
    1e06:	a1 09       	sbc	r26, r1
    1e08:	b1 09       	sbc	r27, r1
    1e0a:	8b 83       	std	Y+3, r24	; 0x03
    1e0c:	9c 83       	std	Y+4, r25	; 0x04
    1e0e:	ad 83       	std	Y+5, r26	; 0x05
    1e10:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1e12:	8b 81       	ldd	r24, Y+3	; 0x03
    1e14:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1e16:	8b 81       	ldd	r24, Y+3	; 0x03
    1e18:	9c 81       	ldd	r25, Y+4	; 0x04
    1e1a:	ad 81       	ldd	r26, Y+5	; 0x05
    1e1c:	be 81       	ldd	r27, Y+6	; 0x06
    1e1e:	89 2f       	mov	r24, r25
    1e20:	9a 2f       	mov	r25, r26
    1e22:	ab 2f       	mov	r26, r27
    1e24:	bb 27       	eor	r27, r27
    1e26:	8b 83       	std	Y+3, r24	; 0x03
    1e28:	9c 83       	std	Y+4, r25	; 0x04
    1e2a:	ad 83       	std	Y+5, r26	; 0x05
    1e2c:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1e2e:	8b 81       	ldd	r24, Y+3	; 0x03
    1e30:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1e32:	eb e4       	ldi	r30, 0x4B	; 75
    1e34:	f0 e0       	ldi	r31, 0x00	; 0
    1e36:	8a 81       	ldd	r24, Y+2	; 0x02
    1e38:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1e3a:	ea e4       	ldi	r30, 0x4A	; 74
    1e3c:	f0 e0       	ldi	r31, 0x00	; 0
    1e3e:	89 81       	ldd	r24, Y+1	; 0x01
    1e40:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1e42:	8b e0       	ldi	r24, 0x0B	; 11
    1e44:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1e46:	ee e4       	ldi	r30, 0x4E	; 78
    1e48:	f0 e0       	ldi	r31, 0x00	; 0
    1e4a:	89 81       	ldd	r24, Y+1	; 0x01
    1e4c:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1e4e:	e9 e5       	ldi	r30, 0x59	; 89
    1e50:	f0 e0       	ldi	r31, 0x00	; 0
    1e52:	80 81       	ld	r24, Z
    1e54:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1e56:	89 81       	ldd	r24, Y+1	; 0x01
    1e58:	80 61       	ori	r24, 0x10	; 16
    1e5a:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1e5c:	e9 e5       	ldi	r30, 0x59	; 89
    1e5e:	f0 e0       	ldi	r31, 0x00	; 0
    1e60:	89 81       	ldd	r24, Y+1	; 0x01
    1e62:	80 83       	st	Z, r24
}
    1e64:	26 96       	adiw	r28, 0x06	; 6
    1e66:	0f b6       	in	r0, 0x3f	; 63
    1e68:	f8 94       	cli
    1e6a:	de bf       	out	0x3e, r29	; 62
    1e6c:	0f be       	out	0x3f, r0	; 63
    1e6e:	cd bf       	out	0x3d, r28	; 61
    1e70:	cf 91       	pop	r28
    1e72:	df 91       	pop	r29
    1e74:	08 95       	ret

00001e76 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    1e76:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1e7a:	18 95       	reti

00001e7c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    1e7c:	df 93       	push	r29
    1e7e:	cf 93       	push	r28
    1e80:	cd b7       	in	r28, 0x3d	; 61
    1e82:	de b7       	in	r29, 0x3e	; 62
    1e84:	28 97       	sbiw	r28, 0x08	; 8
    1e86:	0f b6       	in	r0, 0x3f	; 63
    1e88:	f8 94       	cli
    1e8a:	de bf       	out	0x3e, r29	; 62
    1e8c:	0f be       	out	0x3f, r0	; 63
    1e8e:	cd bf       	out	0x3d, r28	; 61
    1e90:	8f 83       	std	Y+7, r24	; 0x07
    1e92:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    1e94:	1a 82       	std	Y+2, r1	; 0x02
    1e96:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1e98:	8f 81       	ldd	r24, Y+7	; 0x07
    1e9a:	88 23       	and	r24, r24
    1e9c:	09 f4       	brne	.+2      	; 0x1ea0 <xQueueCreate+0x24>
    1e9e:	8c c0       	rjmp	.+280    	; 0x1fb8 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1ea0:	8f e1       	ldi	r24, 0x1F	; 31
    1ea2:	90 e0       	ldi	r25, 0x00	; 0
    1ea4:	0e 94 43 0a 	call	0x1486	; 0x1486 <pvPortMalloc>
    1ea8:	9e 83       	std	Y+6, r25	; 0x06
    1eaa:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    1eac:	8d 81       	ldd	r24, Y+5	; 0x05
    1eae:	9e 81       	ldd	r25, Y+6	; 0x06
    1eb0:	00 97       	sbiw	r24, 0x00	; 0
    1eb2:	09 f4       	brne	.+2      	; 0x1eb6 <xQueueCreate+0x3a>
    1eb4:	81 c0       	rjmp	.+258    	; 0x1fb8 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1eb6:	8f 81       	ldd	r24, Y+7	; 0x07
    1eb8:	28 2f       	mov	r18, r24
    1eba:	30 e0       	ldi	r19, 0x00	; 0
    1ebc:	88 85       	ldd	r24, Y+8	; 0x08
    1ebe:	88 2f       	mov	r24, r24
    1ec0:	90 e0       	ldi	r25, 0x00	; 0
    1ec2:	ac 01       	movw	r20, r24
    1ec4:	24 9f       	mul	r18, r20
    1ec6:	c0 01       	movw	r24, r0
    1ec8:	25 9f       	mul	r18, r21
    1eca:	90 0d       	add	r25, r0
    1ecc:	34 9f       	mul	r19, r20
    1ece:	90 0d       	add	r25, r0
    1ed0:	11 24       	eor	r1, r1
    1ed2:	01 96       	adiw	r24, 0x01	; 1
    1ed4:	9c 83       	std	Y+4, r25	; 0x04
    1ed6:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1ed8:	8b 81       	ldd	r24, Y+3	; 0x03
    1eda:	9c 81       	ldd	r25, Y+4	; 0x04
    1edc:	0e 94 43 0a 	call	0x1486	; 0x1486 <pvPortMalloc>
    1ee0:	ed 81       	ldd	r30, Y+5	; 0x05
    1ee2:	fe 81       	ldd	r31, Y+6	; 0x06
    1ee4:	91 83       	std	Z+1, r25	; 0x01
    1ee6:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    1ee8:	ed 81       	ldd	r30, Y+5	; 0x05
    1eea:	fe 81       	ldd	r31, Y+6	; 0x06
    1eec:	80 81       	ld	r24, Z
    1eee:	91 81       	ldd	r25, Z+1	; 0x01
    1ef0:	00 97       	sbiw	r24, 0x00	; 0
    1ef2:	09 f4       	brne	.+2      	; 0x1ef6 <xQueueCreate+0x7a>
    1ef4:	5d c0       	rjmp	.+186    	; 0x1fb0 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    1ef6:	ed 81       	ldd	r30, Y+5	; 0x05
    1ef8:	fe 81       	ldd	r31, Y+6	; 0x06
    1efa:	40 81       	ld	r20, Z
    1efc:	51 81       	ldd	r21, Z+1	; 0x01
    1efe:	8f 81       	ldd	r24, Y+7	; 0x07
    1f00:	28 2f       	mov	r18, r24
    1f02:	30 e0       	ldi	r19, 0x00	; 0
    1f04:	88 85       	ldd	r24, Y+8	; 0x08
    1f06:	88 2f       	mov	r24, r24
    1f08:	90 e0       	ldi	r25, 0x00	; 0
    1f0a:	bc 01       	movw	r22, r24
    1f0c:	26 9f       	mul	r18, r22
    1f0e:	c0 01       	movw	r24, r0
    1f10:	27 9f       	mul	r18, r23
    1f12:	90 0d       	add	r25, r0
    1f14:	36 9f       	mul	r19, r22
    1f16:	90 0d       	add	r25, r0
    1f18:	11 24       	eor	r1, r1
    1f1a:	84 0f       	add	r24, r20
    1f1c:	95 1f       	adc	r25, r21
    1f1e:	ed 81       	ldd	r30, Y+5	; 0x05
    1f20:	fe 81       	ldd	r31, Y+6	; 0x06
    1f22:	93 83       	std	Z+3, r25	; 0x03
    1f24:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1f26:	ed 81       	ldd	r30, Y+5	; 0x05
    1f28:	fe 81       	ldd	r31, Y+6	; 0x06
    1f2a:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    1f2c:	ed 81       	ldd	r30, Y+5	; 0x05
    1f2e:	fe 81       	ldd	r31, Y+6	; 0x06
    1f30:	80 81       	ld	r24, Z
    1f32:	91 81       	ldd	r25, Z+1	; 0x01
    1f34:	ed 81       	ldd	r30, Y+5	; 0x05
    1f36:	fe 81       	ldd	r31, Y+6	; 0x06
    1f38:	95 83       	std	Z+5, r25	; 0x05
    1f3a:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    1f3c:	ed 81       	ldd	r30, Y+5	; 0x05
    1f3e:	fe 81       	ldd	r31, Y+6	; 0x06
    1f40:	40 81       	ld	r20, Z
    1f42:	51 81       	ldd	r21, Z+1	; 0x01
    1f44:	8f 81       	ldd	r24, Y+7	; 0x07
    1f46:	88 2f       	mov	r24, r24
    1f48:	90 e0       	ldi	r25, 0x00	; 0
    1f4a:	9c 01       	movw	r18, r24
    1f4c:	21 50       	subi	r18, 0x01	; 1
    1f4e:	30 40       	sbci	r19, 0x00	; 0
    1f50:	88 85       	ldd	r24, Y+8	; 0x08
    1f52:	88 2f       	mov	r24, r24
    1f54:	90 e0       	ldi	r25, 0x00	; 0
    1f56:	bc 01       	movw	r22, r24
    1f58:	26 9f       	mul	r18, r22
    1f5a:	c0 01       	movw	r24, r0
    1f5c:	27 9f       	mul	r18, r23
    1f5e:	90 0d       	add	r25, r0
    1f60:	36 9f       	mul	r19, r22
    1f62:	90 0d       	add	r25, r0
    1f64:	11 24       	eor	r1, r1
    1f66:	84 0f       	add	r24, r20
    1f68:	95 1f       	adc	r25, r21
    1f6a:	ed 81       	ldd	r30, Y+5	; 0x05
    1f6c:	fe 81       	ldd	r31, Y+6	; 0x06
    1f6e:	97 83       	std	Z+7, r25	; 0x07
    1f70:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    1f72:	ed 81       	ldd	r30, Y+5	; 0x05
    1f74:	fe 81       	ldd	r31, Y+6	; 0x06
    1f76:	8f 81       	ldd	r24, Y+7	; 0x07
    1f78:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1f7a:	ed 81       	ldd	r30, Y+5	; 0x05
    1f7c:	fe 81       	ldd	r31, Y+6	; 0x06
    1f7e:	88 85       	ldd	r24, Y+8	; 0x08
    1f80:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    1f82:	ed 81       	ldd	r30, Y+5	; 0x05
    1f84:	fe 81       	ldd	r31, Y+6	; 0x06
    1f86:	8f ef       	ldi	r24, 0xFF	; 255
    1f88:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    1f8a:	ed 81       	ldd	r30, Y+5	; 0x05
    1f8c:	fe 81       	ldd	r31, Y+6	; 0x06
    1f8e:	8f ef       	ldi	r24, 0xFF	; 255
    1f90:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1f92:	8d 81       	ldd	r24, Y+5	; 0x05
    1f94:	9e 81       	ldd	r25, Y+6	; 0x06
    1f96:	08 96       	adiw	r24, 0x08	; 8
    1f98:	0e 94 af 0a 	call	0x155e	; 0x155e <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1f9c:	8d 81       	ldd	r24, Y+5	; 0x05
    1f9e:	9e 81       	ldd	r25, Y+6	; 0x06
    1fa0:	41 96       	adiw	r24, 0x11	; 17
    1fa2:	0e 94 af 0a 	call	0x155e	; 0x155e <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    1fa6:	8d 81       	ldd	r24, Y+5	; 0x05
    1fa8:	9e 81       	ldd	r25, Y+6	; 0x06
    1faa:	9a 83       	std	Y+2, r25	; 0x02
    1fac:	89 83       	std	Y+1, r24	; 0x01
    1fae:	04 c0       	rjmp	.+8      	; 0x1fb8 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    1fb0:	8d 81       	ldd	r24, Y+5	; 0x05
    1fb2:	9e 81       	ldd	r25, Y+6	; 0x06
    1fb4:	0e 94 89 0a 	call	0x1512	; 0x1512 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    1fb8:	89 81       	ldd	r24, Y+1	; 0x01
    1fba:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1fbc:	28 96       	adiw	r28, 0x08	; 8
    1fbe:	0f b6       	in	r0, 0x3f	; 63
    1fc0:	f8 94       	cli
    1fc2:	de bf       	out	0x3e, r29	; 62
    1fc4:	0f be       	out	0x3f, r0	; 63
    1fc6:	cd bf       	out	0x3d, r28	; 61
    1fc8:	cf 91       	pop	r28
    1fca:	df 91       	pop	r29
    1fcc:	08 95       	ret

00001fce <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1fce:	df 93       	push	r29
    1fd0:	cf 93       	push	r28
    1fd2:	cd b7       	in	r28, 0x3d	; 61
    1fd4:	de b7       	in	r29, 0x3e	; 62
    1fd6:	2c 97       	sbiw	r28, 0x0c	; 12
    1fd8:	0f b6       	in	r0, 0x3f	; 63
    1fda:	f8 94       	cli
    1fdc:	de bf       	out	0x3e, r29	; 62
    1fde:	0f be       	out	0x3f, r0	; 63
    1fe0:	cd bf       	out	0x3d, r28	; 61
    1fe2:	9e 83       	std	Y+6, r25	; 0x06
    1fe4:	8d 83       	std	Y+5, r24	; 0x05
    1fe6:	78 87       	std	Y+8, r23	; 0x08
    1fe8:	6f 83       	std	Y+7, r22	; 0x07
    1fea:	5a 87       	std	Y+10, r21	; 0x0a
    1fec:	49 87       	std	Y+9, r20	; 0x09
    1fee:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1ff0:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1ff2:	0f b6       	in	r0, 0x3f	; 63
    1ff4:	f8 94       	cli
    1ff6:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1ff8:	ed 81       	ldd	r30, Y+5	; 0x05
    1ffa:	fe 81       	ldd	r31, Y+6	; 0x06
    1ffc:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ffe:	ed 81       	ldd	r30, Y+5	; 0x05
    2000:	fe 81       	ldd	r31, Y+6	; 0x06
    2002:	83 8d       	ldd	r24, Z+27	; 0x1b
    2004:	98 17       	cp	r25, r24
    2006:	d8 f4       	brcc	.+54     	; 0x203e <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2008:	8d 81       	ldd	r24, Y+5	; 0x05
    200a:	9e 81       	ldd	r25, Y+6	; 0x06
    200c:	2f 81       	ldd	r18, Y+7	; 0x07
    200e:	38 85       	ldd	r19, Y+8	; 0x08
    2010:	b9 01       	movw	r22, r18
    2012:	4b 85       	ldd	r20, Y+11	; 0x0b
    2014:	0e 94 22 12 	call	0x2444	; 0x2444 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2018:	ed 81       	ldd	r30, Y+5	; 0x05
    201a:	fe 81       	ldd	r31, Y+6	; 0x06
    201c:	81 89       	ldd	r24, Z+17	; 0x11
    201e:	88 23       	and	r24, r24
    2020:	49 f0       	breq	.+18     	; 0x2034 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    2022:	8d 81       	ldd	r24, Y+5	; 0x05
    2024:	9e 81       	ldd	r25, Y+6	; 0x06
    2026:	41 96       	adiw	r24, 0x11	; 17
    2028:	0e 94 37 18 	call	0x306e	; 0x306e <xTaskRemoveFromEventList>
    202c:	81 30       	cpi	r24, 0x01	; 1
    202e:	11 f4       	brne	.+4      	; 0x2034 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    2030:	0e 94 2b 0e 	call	0x1c56	; 0x1c56 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    2034:	0f 90       	pop	r0
    2036:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    2038:	81 e0       	ldi	r24, 0x01	; 1
    203a:	8c 87       	std	Y+12, r24	; 0x0c
    203c:	5c c0       	rjmp	.+184    	; 0x20f6 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    203e:	89 85       	ldd	r24, Y+9	; 0x09
    2040:	9a 85       	ldd	r25, Y+10	; 0x0a
    2042:	00 97       	sbiw	r24, 0x00	; 0
    2044:	21 f4       	brne	.+8      	; 0x204e <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2046:	0f 90       	pop	r0
    2048:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    204a:	1c 86       	std	Y+12, r1	; 0x0c
    204c:	54 c0       	rjmp	.+168    	; 0x20f6 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    204e:	89 81       	ldd	r24, Y+1	; 0x01
    2050:	88 23       	and	r24, r24
    2052:	31 f4       	brne	.+12     	; 0x2060 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2054:	ce 01       	movw	r24, r28
    2056:	02 96       	adiw	r24, 0x02	; 2
    2058:	0e 94 9f 18 	call	0x313e	; 0x313e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    205c:	81 e0       	ldi	r24, 0x01	; 1
    205e:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    2060:	0f 90       	pop	r0
    2062:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2064:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2068:	0f b6       	in	r0, 0x3f	; 63
    206a:	f8 94       	cli
    206c:	0f 92       	push	r0
    206e:	ed 81       	ldd	r30, Y+5	; 0x05
    2070:	fe 81       	ldd	r31, Y+6	; 0x06
    2072:	85 8d       	ldd	r24, Z+29	; 0x1d
    2074:	8f 3f       	cpi	r24, 0xFF	; 255
    2076:	19 f4       	brne	.+6      	; 0x207e <xQueueGenericSend+0xb0>
    2078:	ed 81       	ldd	r30, Y+5	; 0x05
    207a:	fe 81       	ldd	r31, Y+6	; 0x06
    207c:	15 8e       	std	Z+29, r1	; 0x1d
    207e:	ed 81       	ldd	r30, Y+5	; 0x05
    2080:	fe 81       	ldd	r31, Y+6	; 0x06
    2082:	86 8d       	ldd	r24, Z+30	; 0x1e
    2084:	8f 3f       	cpi	r24, 0xFF	; 255
    2086:	19 f4       	brne	.+6      	; 0x208e <xQueueGenericSend+0xc0>
    2088:	ed 81       	ldd	r30, Y+5	; 0x05
    208a:	fe 81       	ldd	r31, Y+6	; 0x06
    208c:	16 8e       	std	Z+30, r1	; 0x1e
    208e:	0f 90       	pop	r0
    2090:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2092:	ce 01       	movw	r24, r28
    2094:	02 96       	adiw	r24, 0x02	; 2
    2096:	9e 01       	movw	r18, r28
    2098:	27 5f       	subi	r18, 0xF7	; 247
    209a:	3f 4f       	sbci	r19, 0xFF	; 255
    209c:	b9 01       	movw	r22, r18
    209e:	0e 94 b8 18 	call	0x3170	; 0x3170 <xTaskCheckForTimeOut>
    20a2:	88 23       	and	r24, r24
    20a4:	09 f5       	brne	.+66     	; 0x20e8 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    20a6:	8d 81       	ldd	r24, Y+5	; 0x05
    20a8:	9e 81       	ldd	r25, Y+6	; 0x06
    20aa:	0e 94 86 13 	call	0x270c	; 0x270c <prvIsQueueFull>
    20ae:	88 23       	and	r24, r24
    20b0:	a1 f0       	breq	.+40     	; 0x20da <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    20b2:	8d 81       	ldd	r24, Y+5	; 0x05
    20b4:	9e 81       	ldd	r25, Y+6	; 0x06
    20b6:	08 96       	adiw	r24, 0x08	; 8
    20b8:	29 85       	ldd	r18, Y+9	; 0x09
    20ba:	3a 85       	ldd	r19, Y+10	; 0x0a
    20bc:	b9 01       	movw	r22, r18
    20be:	0e 94 01 18 	call	0x3002	; 0x3002 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    20c2:	8d 81       	ldd	r24, Y+5	; 0x05
    20c4:	9e 81       	ldd	r25, Y+6	; 0x06
    20c6:	0e 94 ff 12 	call	0x25fe	; 0x25fe <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    20ca:	0e 94 07 16 	call	0x2c0e	; 0x2c0e <xTaskResumeAll>
    20ce:	88 23       	and	r24, r24
    20d0:	09 f0       	breq	.+2      	; 0x20d4 <xQueueGenericSend+0x106>
    20d2:	8f cf       	rjmp	.-226    	; 0x1ff2 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    20d4:	0e 94 2b 0e 	call	0x1c56	; 0x1c56 <vPortYield>
    20d8:	8c cf       	rjmp	.-232    	; 0x1ff2 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    20da:	8d 81       	ldd	r24, Y+5	; 0x05
    20dc:	9e 81       	ldd	r25, Y+6	; 0x06
    20de:	0e 94 ff 12 	call	0x25fe	; 0x25fe <prvUnlockQueue>
				( void ) xTaskResumeAll();
    20e2:	0e 94 07 16 	call	0x2c0e	; 0x2c0e <xTaskResumeAll>
    20e6:	85 cf       	rjmp	.-246    	; 0x1ff2 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    20e8:	8d 81       	ldd	r24, Y+5	; 0x05
    20ea:	9e 81       	ldd	r25, Y+6	; 0x06
    20ec:	0e 94 ff 12 	call	0x25fe	; 0x25fe <prvUnlockQueue>
			( void ) xTaskResumeAll();
    20f0:	0e 94 07 16 	call	0x2c0e	; 0x2c0e <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    20f4:	1c 86       	std	Y+12, r1	; 0x0c
    20f6:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    20f8:	2c 96       	adiw	r28, 0x0c	; 12
    20fa:	0f b6       	in	r0, 0x3f	; 63
    20fc:	f8 94       	cli
    20fe:	de bf       	out	0x3e, r29	; 62
    2100:	0f be       	out	0x3f, r0	; 63
    2102:	cd bf       	out	0x3d, r28	; 61
    2104:	cf 91       	pop	r28
    2106:	df 91       	pop	r29
    2108:	08 95       	ret

0000210a <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    210a:	df 93       	push	r29
    210c:	cf 93       	push	r28
    210e:	cd b7       	in	r28, 0x3d	; 61
    2110:	de b7       	in	r29, 0x3e	; 62
    2112:	29 97       	sbiw	r28, 0x09	; 9
    2114:	0f b6       	in	r0, 0x3f	; 63
    2116:	f8 94       	cli
    2118:	de bf       	out	0x3e, r29	; 62
    211a:	0f be       	out	0x3f, r0	; 63
    211c:	cd bf       	out	0x3d, r28	; 61
    211e:	9c 83       	std	Y+4, r25	; 0x04
    2120:	8b 83       	std	Y+3, r24	; 0x03
    2122:	7e 83       	std	Y+6, r23	; 0x06
    2124:	6d 83       	std	Y+5, r22	; 0x05
    2126:	58 87       	std	Y+8, r21	; 0x08
    2128:	4f 83       	std	Y+7, r20	; 0x07
    212a:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    212c:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    212e:	eb 81       	ldd	r30, Y+3	; 0x03
    2130:	fc 81       	ldd	r31, Y+4	; 0x04
    2132:	92 8d       	ldd	r25, Z+26	; 0x1a
    2134:	eb 81       	ldd	r30, Y+3	; 0x03
    2136:	fc 81       	ldd	r31, Y+4	; 0x04
    2138:	83 8d       	ldd	r24, Z+27	; 0x1b
    213a:	98 17       	cp	r25, r24
    213c:	40 f5       	brcc	.+80     	; 0x218e <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    213e:	8b 81       	ldd	r24, Y+3	; 0x03
    2140:	9c 81       	ldd	r25, Y+4	; 0x04
    2142:	2d 81       	ldd	r18, Y+5	; 0x05
    2144:	3e 81       	ldd	r19, Y+6	; 0x06
    2146:	b9 01       	movw	r22, r18
    2148:	49 85       	ldd	r20, Y+9	; 0x09
    214a:	0e 94 22 12 	call	0x2444	; 0x2444 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    214e:	eb 81       	ldd	r30, Y+3	; 0x03
    2150:	fc 81       	ldd	r31, Y+4	; 0x04
    2152:	86 8d       	ldd	r24, Z+30	; 0x1e
    2154:	8f 3f       	cpi	r24, 0xFF	; 255
    2156:	89 f4       	brne	.+34     	; 0x217a <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2158:	eb 81       	ldd	r30, Y+3	; 0x03
    215a:	fc 81       	ldd	r31, Y+4	; 0x04
    215c:	81 89       	ldd	r24, Z+17	; 0x11
    215e:	88 23       	and	r24, r24
    2160:	99 f0       	breq	.+38     	; 0x2188 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2162:	8b 81       	ldd	r24, Y+3	; 0x03
    2164:	9c 81       	ldd	r25, Y+4	; 0x04
    2166:	41 96       	adiw	r24, 0x11	; 17
    2168:	0e 94 37 18 	call	0x306e	; 0x306e <xTaskRemoveFromEventList>
    216c:	88 23       	and	r24, r24
    216e:	61 f0       	breq	.+24     	; 0x2188 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    2170:	ef 81       	ldd	r30, Y+7	; 0x07
    2172:	f8 85       	ldd	r31, Y+8	; 0x08
    2174:	81 e0       	ldi	r24, 0x01	; 1
    2176:	80 83       	st	Z, r24
    2178:	07 c0       	rjmp	.+14     	; 0x2188 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    217a:	eb 81       	ldd	r30, Y+3	; 0x03
    217c:	fc 81       	ldd	r31, Y+4	; 0x04
    217e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2180:	8f 5f       	subi	r24, 0xFF	; 255
    2182:	eb 81       	ldd	r30, Y+3	; 0x03
    2184:	fc 81       	ldd	r31, Y+4	; 0x04
    2186:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2188:	81 e0       	ldi	r24, 0x01	; 1
    218a:	8a 83       	std	Y+2, r24	; 0x02
    218c:	01 c0       	rjmp	.+2      	; 0x2190 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    218e:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2190:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2192:	29 96       	adiw	r28, 0x09	; 9
    2194:	0f b6       	in	r0, 0x3f	; 63
    2196:	f8 94       	cli
    2198:	de bf       	out	0x3e, r29	; 62
    219a:	0f be       	out	0x3f, r0	; 63
    219c:	cd bf       	out	0x3d, r28	; 61
    219e:	cf 91       	pop	r28
    21a0:	df 91       	pop	r29
    21a2:	08 95       	ret

000021a4 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    21a4:	df 93       	push	r29
    21a6:	cf 93       	push	r28
    21a8:	cd b7       	in	r28, 0x3d	; 61
    21aa:	de b7       	in	r29, 0x3e	; 62
    21ac:	2e 97       	sbiw	r28, 0x0e	; 14
    21ae:	0f b6       	in	r0, 0x3f	; 63
    21b0:	f8 94       	cli
    21b2:	de bf       	out	0x3e, r29	; 62
    21b4:	0f be       	out	0x3f, r0	; 63
    21b6:	cd bf       	out	0x3d, r28	; 61
    21b8:	98 87       	std	Y+8, r25	; 0x08
    21ba:	8f 83       	std	Y+7, r24	; 0x07
    21bc:	7a 87       	std	Y+10, r23	; 0x0a
    21be:	69 87       	std	Y+9, r22	; 0x09
    21c0:	5c 87       	std	Y+12, r21	; 0x0c
    21c2:	4b 87       	std	Y+11, r20	; 0x0b
    21c4:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    21c6:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    21c8:	0f b6       	in	r0, 0x3f	; 63
    21ca:	f8 94       	cli
    21cc:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    21ce:	ef 81       	ldd	r30, Y+7	; 0x07
    21d0:	f8 85       	ldd	r31, Y+8	; 0x08
    21d2:	82 8d       	ldd	r24, Z+26	; 0x1a
    21d4:	88 23       	and	r24, r24
    21d6:	09 f4       	brne	.+2      	; 0x21da <xQueueGenericReceive+0x36>
    21d8:	3f c0       	rjmp	.+126    	; 0x2258 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    21da:	ef 81       	ldd	r30, Y+7	; 0x07
    21dc:	f8 85       	ldd	r31, Y+8	; 0x08
    21de:	86 81       	ldd	r24, Z+6	; 0x06
    21e0:	97 81       	ldd	r25, Z+7	; 0x07
    21e2:	9a 83       	std	Y+2, r25	; 0x02
    21e4:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    21e6:	8f 81       	ldd	r24, Y+7	; 0x07
    21e8:	98 85       	ldd	r25, Y+8	; 0x08
    21ea:	29 85       	ldd	r18, Y+9	; 0x09
    21ec:	3a 85       	ldd	r19, Y+10	; 0x0a
    21ee:	b9 01       	movw	r22, r18
    21f0:	0e 94 b7 12 	call	0x256e	; 0x256e <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    21f4:	8d 85       	ldd	r24, Y+13	; 0x0d
    21f6:	88 23       	and	r24, r24
    21f8:	b1 f4       	brne	.+44     	; 0x2226 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    21fa:	ef 81       	ldd	r30, Y+7	; 0x07
    21fc:	f8 85       	ldd	r31, Y+8	; 0x08
    21fe:	82 8d       	ldd	r24, Z+26	; 0x1a
    2200:	81 50       	subi	r24, 0x01	; 1
    2202:	ef 81       	ldd	r30, Y+7	; 0x07
    2204:	f8 85       	ldd	r31, Y+8	; 0x08
    2206:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2208:	ef 81       	ldd	r30, Y+7	; 0x07
    220a:	f8 85       	ldd	r31, Y+8	; 0x08
    220c:	80 85       	ldd	r24, Z+8	; 0x08
    220e:	88 23       	and	r24, r24
    2210:	f1 f0       	breq	.+60     	; 0x224e <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    2212:	8f 81       	ldd	r24, Y+7	; 0x07
    2214:	98 85       	ldd	r25, Y+8	; 0x08
    2216:	08 96       	adiw	r24, 0x08	; 8
    2218:	0e 94 37 18 	call	0x306e	; 0x306e <xTaskRemoveFromEventList>
    221c:	81 30       	cpi	r24, 0x01	; 1
    221e:	b9 f4       	brne	.+46     	; 0x224e <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    2220:	0e 94 2b 0e 	call	0x1c56	; 0x1c56 <vPortYield>
    2224:	14 c0       	rjmp	.+40     	; 0x224e <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    2226:	ef 81       	ldd	r30, Y+7	; 0x07
    2228:	f8 85       	ldd	r31, Y+8	; 0x08
    222a:	89 81       	ldd	r24, Y+1	; 0x01
    222c:	9a 81       	ldd	r25, Y+2	; 0x02
    222e:	97 83       	std	Z+7, r25	; 0x07
    2230:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2232:	ef 81       	ldd	r30, Y+7	; 0x07
    2234:	f8 85       	ldd	r31, Y+8	; 0x08
    2236:	81 89       	ldd	r24, Z+17	; 0x11
    2238:	88 23       	and	r24, r24
    223a:	49 f0       	breq	.+18     	; 0x224e <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    223c:	8f 81       	ldd	r24, Y+7	; 0x07
    223e:	98 85       	ldd	r25, Y+8	; 0x08
    2240:	41 96       	adiw	r24, 0x11	; 17
    2242:	0e 94 37 18 	call	0x306e	; 0x306e <xTaskRemoveFromEventList>
    2246:	88 23       	and	r24, r24
    2248:	11 f0       	breq	.+4      	; 0x224e <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    224a:	0e 94 2b 0e 	call	0x1c56	; 0x1c56 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    224e:	0f 90       	pop	r0
    2250:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2252:	81 e0       	ldi	r24, 0x01	; 1
    2254:	8e 87       	std	Y+14, r24	; 0x0e
    2256:	5c c0       	rjmp	.+184    	; 0x2310 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    2258:	8b 85       	ldd	r24, Y+11	; 0x0b
    225a:	9c 85       	ldd	r25, Y+12	; 0x0c
    225c:	00 97       	sbiw	r24, 0x00	; 0
    225e:	21 f4       	brne	.+8      	; 0x2268 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2260:	0f 90       	pop	r0
    2262:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2264:	1e 86       	std	Y+14, r1	; 0x0e
    2266:	54 c0       	rjmp	.+168    	; 0x2310 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    2268:	8b 81       	ldd	r24, Y+3	; 0x03
    226a:	88 23       	and	r24, r24
    226c:	31 f4       	brne	.+12     	; 0x227a <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    226e:	ce 01       	movw	r24, r28
    2270:	04 96       	adiw	r24, 0x04	; 4
    2272:	0e 94 9f 18 	call	0x313e	; 0x313e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2276:	81 e0       	ldi	r24, 0x01	; 1
    2278:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    227a:	0f 90       	pop	r0
    227c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    227e:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2282:	0f b6       	in	r0, 0x3f	; 63
    2284:	f8 94       	cli
    2286:	0f 92       	push	r0
    2288:	ef 81       	ldd	r30, Y+7	; 0x07
    228a:	f8 85       	ldd	r31, Y+8	; 0x08
    228c:	85 8d       	ldd	r24, Z+29	; 0x1d
    228e:	8f 3f       	cpi	r24, 0xFF	; 255
    2290:	19 f4       	brne	.+6      	; 0x2298 <xQueueGenericReceive+0xf4>
    2292:	ef 81       	ldd	r30, Y+7	; 0x07
    2294:	f8 85       	ldd	r31, Y+8	; 0x08
    2296:	15 8e       	std	Z+29, r1	; 0x1d
    2298:	ef 81       	ldd	r30, Y+7	; 0x07
    229a:	f8 85       	ldd	r31, Y+8	; 0x08
    229c:	86 8d       	ldd	r24, Z+30	; 0x1e
    229e:	8f 3f       	cpi	r24, 0xFF	; 255
    22a0:	19 f4       	brne	.+6      	; 0x22a8 <xQueueGenericReceive+0x104>
    22a2:	ef 81       	ldd	r30, Y+7	; 0x07
    22a4:	f8 85       	ldd	r31, Y+8	; 0x08
    22a6:	16 8e       	std	Z+30, r1	; 0x1e
    22a8:	0f 90       	pop	r0
    22aa:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    22ac:	ce 01       	movw	r24, r28
    22ae:	04 96       	adiw	r24, 0x04	; 4
    22b0:	9e 01       	movw	r18, r28
    22b2:	25 5f       	subi	r18, 0xF5	; 245
    22b4:	3f 4f       	sbci	r19, 0xFF	; 255
    22b6:	b9 01       	movw	r22, r18
    22b8:	0e 94 b8 18 	call	0x3170	; 0x3170 <xTaskCheckForTimeOut>
    22bc:	88 23       	and	r24, r24
    22be:	09 f5       	brne	.+66     	; 0x2302 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    22c0:	8f 81       	ldd	r24, Y+7	; 0x07
    22c2:	98 85       	ldd	r25, Y+8	; 0x08
    22c4:	0e 94 53 13 	call	0x26a6	; 0x26a6 <prvIsQueueEmpty>
    22c8:	88 23       	and	r24, r24
    22ca:	a1 f0       	breq	.+40     	; 0x22f4 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    22cc:	8f 81       	ldd	r24, Y+7	; 0x07
    22ce:	98 85       	ldd	r25, Y+8	; 0x08
    22d0:	41 96       	adiw	r24, 0x11	; 17
    22d2:	2b 85       	ldd	r18, Y+11	; 0x0b
    22d4:	3c 85       	ldd	r19, Y+12	; 0x0c
    22d6:	b9 01       	movw	r22, r18
    22d8:	0e 94 01 18 	call	0x3002	; 0x3002 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    22dc:	8f 81       	ldd	r24, Y+7	; 0x07
    22de:	98 85       	ldd	r25, Y+8	; 0x08
    22e0:	0e 94 ff 12 	call	0x25fe	; 0x25fe <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    22e4:	0e 94 07 16 	call	0x2c0e	; 0x2c0e <xTaskResumeAll>
    22e8:	88 23       	and	r24, r24
    22ea:	09 f0       	breq	.+2      	; 0x22ee <xQueueGenericReceive+0x14a>
    22ec:	6d cf       	rjmp	.-294    	; 0x21c8 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    22ee:	0e 94 2b 0e 	call	0x1c56	; 0x1c56 <vPortYield>
    22f2:	6a cf       	rjmp	.-300    	; 0x21c8 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    22f4:	8f 81       	ldd	r24, Y+7	; 0x07
    22f6:	98 85       	ldd	r25, Y+8	; 0x08
    22f8:	0e 94 ff 12 	call	0x25fe	; 0x25fe <prvUnlockQueue>
				( void ) xTaskResumeAll();
    22fc:	0e 94 07 16 	call	0x2c0e	; 0x2c0e <xTaskResumeAll>
    2300:	63 cf       	rjmp	.-314    	; 0x21c8 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    2302:	8f 81       	ldd	r24, Y+7	; 0x07
    2304:	98 85       	ldd	r25, Y+8	; 0x08
    2306:	0e 94 ff 12 	call	0x25fe	; 0x25fe <prvUnlockQueue>
			( void ) xTaskResumeAll();
    230a:	0e 94 07 16 	call	0x2c0e	; 0x2c0e <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    230e:	1e 86       	std	Y+14, r1	; 0x0e
    2310:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    2312:	2e 96       	adiw	r28, 0x0e	; 14
    2314:	0f b6       	in	r0, 0x3f	; 63
    2316:	f8 94       	cli
    2318:	de bf       	out	0x3e, r29	; 62
    231a:	0f be       	out	0x3f, r0	; 63
    231c:	cd bf       	out	0x3d, r28	; 61
    231e:	cf 91       	pop	r28
    2320:	df 91       	pop	r29
    2322:	08 95       	ret

00002324 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    2324:	df 93       	push	r29
    2326:	cf 93       	push	r28
    2328:	cd b7       	in	r28, 0x3d	; 61
    232a:	de b7       	in	r29, 0x3e	; 62
    232c:	28 97       	sbiw	r28, 0x08	; 8
    232e:	0f b6       	in	r0, 0x3f	; 63
    2330:	f8 94       	cli
    2332:	de bf       	out	0x3e, r29	; 62
    2334:	0f be       	out	0x3f, r0	; 63
    2336:	cd bf       	out	0x3d, r28	; 61
    2338:	9c 83       	std	Y+4, r25	; 0x04
    233a:	8b 83       	std	Y+3, r24	; 0x03
    233c:	7e 83       	std	Y+6, r23	; 0x06
    233e:	6d 83       	std	Y+5, r22	; 0x05
    2340:	58 87       	std	Y+8, r21	; 0x08
    2342:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2344:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2346:	eb 81       	ldd	r30, Y+3	; 0x03
    2348:	fc 81       	ldd	r31, Y+4	; 0x04
    234a:	82 8d       	ldd	r24, Z+26	; 0x1a
    234c:	88 23       	and	r24, r24
    234e:	71 f1       	breq	.+92     	; 0x23ac <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2350:	8b 81       	ldd	r24, Y+3	; 0x03
    2352:	9c 81       	ldd	r25, Y+4	; 0x04
    2354:	2d 81       	ldd	r18, Y+5	; 0x05
    2356:	3e 81       	ldd	r19, Y+6	; 0x06
    2358:	b9 01       	movw	r22, r18
    235a:	0e 94 b7 12 	call	0x256e	; 0x256e <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    235e:	eb 81       	ldd	r30, Y+3	; 0x03
    2360:	fc 81       	ldd	r31, Y+4	; 0x04
    2362:	82 8d       	ldd	r24, Z+26	; 0x1a
    2364:	81 50       	subi	r24, 0x01	; 1
    2366:	eb 81       	ldd	r30, Y+3	; 0x03
    2368:	fc 81       	ldd	r31, Y+4	; 0x04
    236a:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    236c:	eb 81       	ldd	r30, Y+3	; 0x03
    236e:	fc 81       	ldd	r31, Y+4	; 0x04
    2370:	85 8d       	ldd	r24, Z+29	; 0x1d
    2372:	8f 3f       	cpi	r24, 0xFF	; 255
    2374:	89 f4       	brne	.+34     	; 0x2398 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2376:	eb 81       	ldd	r30, Y+3	; 0x03
    2378:	fc 81       	ldd	r31, Y+4	; 0x04
    237a:	80 85       	ldd	r24, Z+8	; 0x08
    237c:	88 23       	and	r24, r24
    237e:	99 f0       	breq	.+38     	; 0x23a6 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2380:	8b 81       	ldd	r24, Y+3	; 0x03
    2382:	9c 81       	ldd	r25, Y+4	; 0x04
    2384:	08 96       	adiw	r24, 0x08	; 8
    2386:	0e 94 37 18 	call	0x306e	; 0x306e <xTaskRemoveFromEventList>
    238a:	88 23       	and	r24, r24
    238c:	61 f0       	breq	.+24     	; 0x23a6 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    238e:	ef 81       	ldd	r30, Y+7	; 0x07
    2390:	f8 85       	ldd	r31, Y+8	; 0x08
    2392:	81 e0       	ldi	r24, 0x01	; 1
    2394:	80 83       	st	Z, r24
    2396:	07 c0       	rjmp	.+14     	; 0x23a6 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    2398:	eb 81       	ldd	r30, Y+3	; 0x03
    239a:	fc 81       	ldd	r31, Y+4	; 0x04
    239c:	85 8d       	ldd	r24, Z+29	; 0x1d
    239e:	8f 5f       	subi	r24, 0xFF	; 255
    23a0:	eb 81       	ldd	r30, Y+3	; 0x03
    23a2:	fc 81       	ldd	r31, Y+4	; 0x04
    23a4:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    23a6:	81 e0       	ldi	r24, 0x01	; 1
    23a8:	8a 83       	std	Y+2, r24	; 0x02
    23aa:	01 c0       	rjmp	.+2      	; 0x23ae <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    23ac:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    23ae:	8a 81       	ldd	r24, Y+2	; 0x02
}
    23b0:	28 96       	adiw	r28, 0x08	; 8
    23b2:	0f b6       	in	r0, 0x3f	; 63
    23b4:	f8 94       	cli
    23b6:	de bf       	out	0x3e, r29	; 62
    23b8:	0f be       	out	0x3f, r0	; 63
    23ba:	cd bf       	out	0x3d, r28	; 61
    23bc:	cf 91       	pop	r28
    23be:	df 91       	pop	r29
    23c0:	08 95       	ret

000023c2 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    23c2:	df 93       	push	r29
    23c4:	cf 93       	push	r28
    23c6:	00 d0       	rcall	.+0      	; 0x23c8 <uxQueueMessagesWaiting+0x6>
    23c8:	0f 92       	push	r0
    23ca:	cd b7       	in	r28, 0x3d	; 61
    23cc:	de b7       	in	r29, 0x3e	; 62
    23ce:	9b 83       	std	Y+3, r25	; 0x03
    23d0:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    23d2:	0f b6       	in	r0, 0x3f	; 63
    23d4:	f8 94       	cli
    23d6:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    23d8:	ea 81       	ldd	r30, Y+2	; 0x02
    23da:	fb 81       	ldd	r31, Y+3	; 0x03
    23dc:	82 8d       	ldd	r24, Z+26	; 0x1a
    23de:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    23e0:	0f 90       	pop	r0
    23e2:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    23e4:	89 81       	ldd	r24, Y+1	; 0x01
}
    23e6:	0f 90       	pop	r0
    23e8:	0f 90       	pop	r0
    23ea:	0f 90       	pop	r0
    23ec:	cf 91       	pop	r28
    23ee:	df 91       	pop	r29
    23f0:	08 95       	ret

000023f2 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    23f2:	df 93       	push	r29
    23f4:	cf 93       	push	r28
    23f6:	00 d0       	rcall	.+0      	; 0x23f8 <uxQueueMessagesWaitingFromISR+0x6>
    23f8:	0f 92       	push	r0
    23fa:	cd b7       	in	r28, 0x3d	; 61
    23fc:	de b7       	in	r29, 0x3e	; 62
    23fe:	9b 83       	std	Y+3, r25	; 0x03
    2400:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    2402:	ea 81       	ldd	r30, Y+2	; 0x02
    2404:	fb 81       	ldd	r31, Y+3	; 0x03
    2406:	82 8d       	ldd	r24, Z+26	; 0x1a
    2408:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    240a:	89 81       	ldd	r24, Y+1	; 0x01
}
    240c:	0f 90       	pop	r0
    240e:	0f 90       	pop	r0
    2410:	0f 90       	pop	r0
    2412:	cf 91       	pop	r28
    2414:	df 91       	pop	r29
    2416:	08 95       	ret

00002418 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    2418:	df 93       	push	r29
    241a:	cf 93       	push	r28
    241c:	00 d0       	rcall	.+0      	; 0x241e <vQueueDelete+0x6>
    241e:	cd b7       	in	r28, 0x3d	; 61
    2420:	de b7       	in	r29, 0x3e	; 62
    2422:	9a 83       	std	Y+2, r25	; 0x02
    2424:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    2426:	e9 81       	ldd	r30, Y+1	; 0x01
    2428:	fa 81       	ldd	r31, Y+2	; 0x02
    242a:	80 81       	ld	r24, Z
    242c:	91 81       	ldd	r25, Z+1	; 0x01
    242e:	0e 94 89 0a 	call	0x1512	; 0x1512 <vPortFree>
	vPortFree( pxQueue );
    2432:	89 81       	ldd	r24, Y+1	; 0x01
    2434:	9a 81       	ldd	r25, Y+2	; 0x02
    2436:	0e 94 89 0a 	call	0x1512	; 0x1512 <vPortFree>
}
    243a:	0f 90       	pop	r0
    243c:	0f 90       	pop	r0
    243e:	cf 91       	pop	r28
    2440:	df 91       	pop	r29
    2442:	08 95       	ret

00002444 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    2444:	df 93       	push	r29
    2446:	cf 93       	push	r28
    2448:	00 d0       	rcall	.+0      	; 0x244a <prvCopyDataToQueue+0x6>
    244a:	00 d0       	rcall	.+0      	; 0x244c <prvCopyDataToQueue+0x8>
    244c:	0f 92       	push	r0
    244e:	cd b7       	in	r28, 0x3d	; 61
    2450:	de b7       	in	r29, 0x3e	; 62
    2452:	9a 83       	std	Y+2, r25	; 0x02
    2454:	89 83       	std	Y+1, r24	; 0x01
    2456:	7c 83       	std	Y+4, r23	; 0x04
    2458:	6b 83       	std	Y+3, r22	; 0x03
    245a:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    245c:	e9 81       	ldd	r30, Y+1	; 0x01
    245e:	fa 81       	ldd	r31, Y+2	; 0x02
    2460:	84 8d       	ldd	r24, Z+28	; 0x1c
    2462:	88 23       	and	r24, r24
    2464:	09 f4       	brne	.+2      	; 0x2468 <prvCopyDataToQueue+0x24>
    2466:	74 c0       	rjmp	.+232    	; 0x2550 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    2468:	8d 81       	ldd	r24, Y+5	; 0x05
    246a:	88 23       	and	r24, r24
    246c:	99 f5       	brne	.+102    	; 0x24d4 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    246e:	e9 81       	ldd	r30, Y+1	; 0x01
    2470:	fa 81       	ldd	r31, Y+2	; 0x02
    2472:	64 81       	ldd	r22, Z+4	; 0x04
    2474:	75 81       	ldd	r23, Z+5	; 0x05
    2476:	e9 81       	ldd	r30, Y+1	; 0x01
    2478:	fa 81       	ldd	r31, Y+2	; 0x02
    247a:	84 8d       	ldd	r24, Z+28	; 0x1c
    247c:	48 2f       	mov	r20, r24
    247e:	50 e0       	ldi	r21, 0x00	; 0
    2480:	2b 81       	ldd	r18, Y+3	; 0x03
    2482:	3c 81       	ldd	r19, Y+4	; 0x04
    2484:	cb 01       	movw	r24, r22
    2486:	b9 01       	movw	r22, r18
    2488:	0e 94 aa 1a 	call	0x3554	; 0x3554 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    248c:	e9 81       	ldd	r30, Y+1	; 0x01
    248e:	fa 81       	ldd	r31, Y+2	; 0x02
    2490:	24 81       	ldd	r18, Z+4	; 0x04
    2492:	35 81       	ldd	r19, Z+5	; 0x05
    2494:	e9 81       	ldd	r30, Y+1	; 0x01
    2496:	fa 81       	ldd	r31, Y+2	; 0x02
    2498:	84 8d       	ldd	r24, Z+28	; 0x1c
    249a:	88 2f       	mov	r24, r24
    249c:	90 e0       	ldi	r25, 0x00	; 0
    249e:	82 0f       	add	r24, r18
    24a0:	93 1f       	adc	r25, r19
    24a2:	e9 81       	ldd	r30, Y+1	; 0x01
    24a4:	fa 81       	ldd	r31, Y+2	; 0x02
    24a6:	95 83       	std	Z+5, r25	; 0x05
    24a8:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    24aa:	e9 81       	ldd	r30, Y+1	; 0x01
    24ac:	fa 81       	ldd	r31, Y+2	; 0x02
    24ae:	24 81       	ldd	r18, Z+4	; 0x04
    24b0:	35 81       	ldd	r19, Z+5	; 0x05
    24b2:	e9 81       	ldd	r30, Y+1	; 0x01
    24b4:	fa 81       	ldd	r31, Y+2	; 0x02
    24b6:	82 81       	ldd	r24, Z+2	; 0x02
    24b8:	93 81       	ldd	r25, Z+3	; 0x03
    24ba:	28 17       	cp	r18, r24
    24bc:	39 07       	cpc	r19, r25
    24be:	08 f4       	brcc	.+2      	; 0x24c2 <prvCopyDataToQueue+0x7e>
    24c0:	47 c0       	rjmp	.+142    	; 0x2550 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    24c2:	e9 81       	ldd	r30, Y+1	; 0x01
    24c4:	fa 81       	ldd	r31, Y+2	; 0x02
    24c6:	80 81       	ld	r24, Z
    24c8:	91 81       	ldd	r25, Z+1	; 0x01
    24ca:	e9 81       	ldd	r30, Y+1	; 0x01
    24cc:	fa 81       	ldd	r31, Y+2	; 0x02
    24ce:	95 83       	std	Z+5, r25	; 0x05
    24d0:	84 83       	std	Z+4, r24	; 0x04
    24d2:	3e c0       	rjmp	.+124    	; 0x2550 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    24d4:	e9 81       	ldd	r30, Y+1	; 0x01
    24d6:	fa 81       	ldd	r31, Y+2	; 0x02
    24d8:	66 81       	ldd	r22, Z+6	; 0x06
    24da:	77 81       	ldd	r23, Z+7	; 0x07
    24dc:	e9 81       	ldd	r30, Y+1	; 0x01
    24de:	fa 81       	ldd	r31, Y+2	; 0x02
    24e0:	84 8d       	ldd	r24, Z+28	; 0x1c
    24e2:	48 2f       	mov	r20, r24
    24e4:	50 e0       	ldi	r21, 0x00	; 0
    24e6:	2b 81       	ldd	r18, Y+3	; 0x03
    24e8:	3c 81       	ldd	r19, Y+4	; 0x04
    24ea:	cb 01       	movw	r24, r22
    24ec:	b9 01       	movw	r22, r18
    24ee:	0e 94 aa 1a 	call	0x3554	; 0x3554 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    24f2:	e9 81       	ldd	r30, Y+1	; 0x01
    24f4:	fa 81       	ldd	r31, Y+2	; 0x02
    24f6:	26 81       	ldd	r18, Z+6	; 0x06
    24f8:	37 81       	ldd	r19, Z+7	; 0x07
    24fa:	e9 81       	ldd	r30, Y+1	; 0x01
    24fc:	fa 81       	ldd	r31, Y+2	; 0x02
    24fe:	84 8d       	ldd	r24, Z+28	; 0x1c
    2500:	88 2f       	mov	r24, r24
    2502:	90 e0       	ldi	r25, 0x00	; 0
    2504:	90 95       	com	r25
    2506:	81 95       	neg	r24
    2508:	9f 4f       	sbci	r25, 0xFF	; 255
    250a:	82 0f       	add	r24, r18
    250c:	93 1f       	adc	r25, r19
    250e:	e9 81       	ldd	r30, Y+1	; 0x01
    2510:	fa 81       	ldd	r31, Y+2	; 0x02
    2512:	97 83       	std	Z+7, r25	; 0x07
    2514:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    2516:	e9 81       	ldd	r30, Y+1	; 0x01
    2518:	fa 81       	ldd	r31, Y+2	; 0x02
    251a:	26 81       	ldd	r18, Z+6	; 0x06
    251c:	37 81       	ldd	r19, Z+7	; 0x07
    251e:	e9 81       	ldd	r30, Y+1	; 0x01
    2520:	fa 81       	ldd	r31, Y+2	; 0x02
    2522:	80 81       	ld	r24, Z
    2524:	91 81       	ldd	r25, Z+1	; 0x01
    2526:	28 17       	cp	r18, r24
    2528:	39 07       	cpc	r19, r25
    252a:	90 f4       	brcc	.+36     	; 0x2550 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    252c:	e9 81       	ldd	r30, Y+1	; 0x01
    252e:	fa 81       	ldd	r31, Y+2	; 0x02
    2530:	22 81       	ldd	r18, Z+2	; 0x02
    2532:	33 81       	ldd	r19, Z+3	; 0x03
    2534:	e9 81       	ldd	r30, Y+1	; 0x01
    2536:	fa 81       	ldd	r31, Y+2	; 0x02
    2538:	84 8d       	ldd	r24, Z+28	; 0x1c
    253a:	88 2f       	mov	r24, r24
    253c:	90 e0       	ldi	r25, 0x00	; 0
    253e:	90 95       	com	r25
    2540:	81 95       	neg	r24
    2542:	9f 4f       	sbci	r25, 0xFF	; 255
    2544:	82 0f       	add	r24, r18
    2546:	93 1f       	adc	r25, r19
    2548:	e9 81       	ldd	r30, Y+1	; 0x01
    254a:	fa 81       	ldd	r31, Y+2	; 0x02
    254c:	97 83       	std	Z+7, r25	; 0x07
    254e:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    2550:	e9 81       	ldd	r30, Y+1	; 0x01
    2552:	fa 81       	ldd	r31, Y+2	; 0x02
    2554:	82 8d       	ldd	r24, Z+26	; 0x1a
    2556:	8f 5f       	subi	r24, 0xFF	; 255
    2558:	e9 81       	ldd	r30, Y+1	; 0x01
    255a:	fa 81       	ldd	r31, Y+2	; 0x02
    255c:	82 8f       	std	Z+26, r24	; 0x1a
}
    255e:	0f 90       	pop	r0
    2560:	0f 90       	pop	r0
    2562:	0f 90       	pop	r0
    2564:	0f 90       	pop	r0
    2566:	0f 90       	pop	r0
    2568:	cf 91       	pop	r28
    256a:	df 91       	pop	r29
    256c:	08 95       	ret

0000256e <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    256e:	df 93       	push	r29
    2570:	cf 93       	push	r28
    2572:	00 d0       	rcall	.+0      	; 0x2574 <prvCopyDataFromQueue+0x6>
    2574:	00 d0       	rcall	.+0      	; 0x2576 <prvCopyDataFromQueue+0x8>
    2576:	cd b7       	in	r28, 0x3d	; 61
    2578:	de b7       	in	r29, 0x3e	; 62
    257a:	9a 83       	std	Y+2, r25	; 0x02
    257c:	89 83       	std	Y+1, r24	; 0x01
    257e:	7c 83       	std	Y+4, r23	; 0x04
    2580:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    2582:	e9 81       	ldd	r30, Y+1	; 0x01
    2584:	fa 81       	ldd	r31, Y+2	; 0x02
    2586:	80 81       	ld	r24, Z
    2588:	91 81       	ldd	r25, Z+1	; 0x01
    258a:	00 97       	sbiw	r24, 0x00	; 0
    258c:	89 f1       	breq	.+98     	; 0x25f0 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    258e:	e9 81       	ldd	r30, Y+1	; 0x01
    2590:	fa 81       	ldd	r31, Y+2	; 0x02
    2592:	26 81       	ldd	r18, Z+6	; 0x06
    2594:	37 81       	ldd	r19, Z+7	; 0x07
    2596:	e9 81       	ldd	r30, Y+1	; 0x01
    2598:	fa 81       	ldd	r31, Y+2	; 0x02
    259a:	84 8d       	ldd	r24, Z+28	; 0x1c
    259c:	88 2f       	mov	r24, r24
    259e:	90 e0       	ldi	r25, 0x00	; 0
    25a0:	82 0f       	add	r24, r18
    25a2:	93 1f       	adc	r25, r19
    25a4:	e9 81       	ldd	r30, Y+1	; 0x01
    25a6:	fa 81       	ldd	r31, Y+2	; 0x02
    25a8:	97 83       	std	Z+7, r25	; 0x07
    25aa:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    25ac:	e9 81       	ldd	r30, Y+1	; 0x01
    25ae:	fa 81       	ldd	r31, Y+2	; 0x02
    25b0:	26 81       	ldd	r18, Z+6	; 0x06
    25b2:	37 81       	ldd	r19, Z+7	; 0x07
    25b4:	e9 81       	ldd	r30, Y+1	; 0x01
    25b6:	fa 81       	ldd	r31, Y+2	; 0x02
    25b8:	82 81       	ldd	r24, Z+2	; 0x02
    25ba:	93 81       	ldd	r25, Z+3	; 0x03
    25bc:	28 17       	cp	r18, r24
    25be:	39 07       	cpc	r19, r25
    25c0:	40 f0       	brcs	.+16     	; 0x25d2 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    25c2:	e9 81       	ldd	r30, Y+1	; 0x01
    25c4:	fa 81       	ldd	r31, Y+2	; 0x02
    25c6:	80 81       	ld	r24, Z
    25c8:	91 81       	ldd	r25, Z+1	; 0x01
    25ca:	e9 81       	ldd	r30, Y+1	; 0x01
    25cc:	fa 81       	ldd	r31, Y+2	; 0x02
    25ce:	97 83       	std	Z+7, r25	; 0x07
    25d0:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    25d2:	e9 81       	ldd	r30, Y+1	; 0x01
    25d4:	fa 81       	ldd	r31, Y+2	; 0x02
    25d6:	46 81       	ldd	r20, Z+6	; 0x06
    25d8:	57 81       	ldd	r21, Z+7	; 0x07
    25da:	e9 81       	ldd	r30, Y+1	; 0x01
    25dc:	fa 81       	ldd	r31, Y+2	; 0x02
    25de:	84 8d       	ldd	r24, Z+28	; 0x1c
    25e0:	28 2f       	mov	r18, r24
    25e2:	30 e0       	ldi	r19, 0x00	; 0
    25e4:	8b 81       	ldd	r24, Y+3	; 0x03
    25e6:	9c 81       	ldd	r25, Y+4	; 0x04
    25e8:	ba 01       	movw	r22, r20
    25ea:	a9 01       	movw	r20, r18
    25ec:	0e 94 aa 1a 	call	0x3554	; 0x3554 <memcpy>
	}
}
    25f0:	0f 90       	pop	r0
    25f2:	0f 90       	pop	r0
    25f4:	0f 90       	pop	r0
    25f6:	0f 90       	pop	r0
    25f8:	cf 91       	pop	r28
    25fa:	df 91       	pop	r29
    25fc:	08 95       	ret

000025fe <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    25fe:	df 93       	push	r29
    2600:	cf 93       	push	r28
    2602:	00 d0       	rcall	.+0      	; 0x2604 <prvUnlockQueue+0x6>
    2604:	cd b7       	in	r28, 0x3d	; 61
    2606:	de b7       	in	r29, 0x3e	; 62
    2608:	9a 83       	std	Y+2, r25	; 0x02
    260a:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    260c:	0f b6       	in	r0, 0x3f	; 63
    260e:	f8 94       	cli
    2610:	0f 92       	push	r0
    2612:	15 c0       	rjmp	.+42     	; 0x263e <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2614:	e9 81       	ldd	r30, Y+1	; 0x01
    2616:	fa 81       	ldd	r31, Y+2	; 0x02
    2618:	81 89       	ldd	r24, Z+17	; 0x11
    261a:	88 23       	and	r24, r24
    261c:	a9 f0       	breq	.+42     	; 0x2648 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    261e:	89 81       	ldd	r24, Y+1	; 0x01
    2620:	9a 81       	ldd	r25, Y+2	; 0x02
    2622:	41 96       	adiw	r24, 0x11	; 17
    2624:	0e 94 37 18 	call	0x306e	; 0x306e <xTaskRemoveFromEventList>
    2628:	88 23       	and	r24, r24
    262a:	11 f0       	breq	.+4      	; 0x2630 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    262c:	0e 94 15 19 	call	0x322a	; 0x322a <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    2630:	e9 81       	ldd	r30, Y+1	; 0x01
    2632:	fa 81       	ldd	r31, Y+2	; 0x02
    2634:	86 8d       	ldd	r24, Z+30	; 0x1e
    2636:	81 50       	subi	r24, 0x01	; 1
    2638:	e9 81       	ldd	r30, Y+1	; 0x01
    263a:	fa 81       	ldd	r31, Y+2	; 0x02
    263c:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    263e:	e9 81       	ldd	r30, Y+1	; 0x01
    2640:	fa 81       	ldd	r31, Y+2	; 0x02
    2642:	86 8d       	ldd	r24, Z+30	; 0x1e
    2644:	18 16       	cp	r1, r24
    2646:	34 f3       	brlt	.-52     	; 0x2614 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    2648:	e9 81       	ldd	r30, Y+1	; 0x01
    264a:	fa 81       	ldd	r31, Y+2	; 0x02
    264c:	8f ef       	ldi	r24, 0xFF	; 255
    264e:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    2650:	0f 90       	pop	r0
    2652:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2654:	0f b6       	in	r0, 0x3f	; 63
    2656:	f8 94       	cli
    2658:	0f 92       	push	r0
    265a:	15 c0       	rjmp	.+42     	; 0x2686 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    265c:	e9 81       	ldd	r30, Y+1	; 0x01
    265e:	fa 81       	ldd	r31, Y+2	; 0x02
    2660:	80 85       	ldd	r24, Z+8	; 0x08
    2662:	88 23       	and	r24, r24
    2664:	a9 f0       	breq	.+42     	; 0x2690 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2666:	89 81       	ldd	r24, Y+1	; 0x01
    2668:	9a 81       	ldd	r25, Y+2	; 0x02
    266a:	08 96       	adiw	r24, 0x08	; 8
    266c:	0e 94 37 18 	call	0x306e	; 0x306e <xTaskRemoveFromEventList>
    2670:	88 23       	and	r24, r24
    2672:	11 f0       	breq	.+4      	; 0x2678 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    2674:	0e 94 15 19 	call	0x322a	; 0x322a <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    2678:	e9 81       	ldd	r30, Y+1	; 0x01
    267a:	fa 81       	ldd	r31, Y+2	; 0x02
    267c:	85 8d       	ldd	r24, Z+29	; 0x1d
    267e:	81 50       	subi	r24, 0x01	; 1
    2680:	e9 81       	ldd	r30, Y+1	; 0x01
    2682:	fa 81       	ldd	r31, Y+2	; 0x02
    2684:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2686:	e9 81       	ldd	r30, Y+1	; 0x01
    2688:	fa 81       	ldd	r31, Y+2	; 0x02
    268a:	85 8d       	ldd	r24, Z+29	; 0x1d
    268c:	18 16       	cp	r1, r24
    268e:	34 f3       	brlt	.-52     	; 0x265c <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    2690:	e9 81       	ldd	r30, Y+1	; 0x01
    2692:	fa 81       	ldd	r31, Y+2	; 0x02
    2694:	8f ef       	ldi	r24, 0xFF	; 255
    2696:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    2698:	0f 90       	pop	r0
    269a:	0f be       	out	0x3f, r0	; 63
}
    269c:	0f 90       	pop	r0
    269e:	0f 90       	pop	r0
    26a0:	cf 91       	pop	r28
    26a2:	df 91       	pop	r29
    26a4:	08 95       	ret

000026a6 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    26a6:	df 93       	push	r29
    26a8:	cf 93       	push	r28
    26aa:	00 d0       	rcall	.+0      	; 0x26ac <prvIsQueueEmpty+0x6>
    26ac:	0f 92       	push	r0
    26ae:	cd b7       	in	r28, 0x3d	; 61
    26b0:	de b7       	in	r29, 0x3e	; 62
    26b2:	9b 83       	std	Y+3, r25	; 0x03
    26b4:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    26b6:	0f b6       	in	r0, 0x3f	; 63
    26b8:	f8 94       	cli
    26ba:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    26bc:	ea 81       	ldd	r30, Y+2	; 0x02
    26be:	fb 81       	ldd	r31, Y+3	; 0x03
    26c0:	82 8d       	ldd	r24, Z+26	; 0x1a
    26c2:	19 82       	std	Y+1, r1	; 0x01
    26c4:	88 23       	and	r24, r24
    26c6:	11 f4       	brne	.+4      	; 0x26cc <prvIsQueueEmpty+0x26>
    26c8:	81 e0       	ldi	r24, 0x01	; 1
    26ca:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    26cc:	0f 90       	pop	r0
    26ce:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    26d0:	89 81       	ldd	r24, Y+1	; 0x01
}
    26d2:	0f 90       	pop	r0
    26d4:	0f 90       	pop	r0
    26d6:	0f 90       	pop	r0
    26d8:	cf 91       	pop	r28
    26da:	df 91       	pop	r29
    26dc:	08 95       	ret

000026de <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    26de:	df 93       	push	r29
    26e0:	cf 93       	push	r28
    26e2:	00 d0       	rcall	.+0      	; 0x26e4 <xQueueIsQueueEmptyFromISR+0x6>
    26e4:	0f 92       	push	r0
    26e6:	cd b7       	in	r28, 0x3d	; 61
    26e8:	de b7       	in	r29, 0x3e	; 62
    26ea:	9b 83       	std	Y+3, r25	; 0x03
    26ec:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    26ee:	ea 81       	ldd	r30, Y+2	; 0x02
    26f0:	fb 81       	ldd	r31, Y+3	; 0x03
    26f2:	82 8d       	ldd	r24, Z+26	; 0x1a
    26f4:	19 82       	std	Y+1, r1	; 0x01
    26f6:	88 23       	and	r24, r24
    26f8:	11 f4       	brne	.+4      	; 0x26fe <xQueueIsQueueEmptyFromISR+0x20>
    26fa:	81 e0       	ldi	r24, 0x01	; 1
    26fc:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    26fe:	89 81       	ldd	r24, Y+1	; 0x01
}
    2700:	0f 90       	pop	r0
    2702:	0f 90       	pop	r0
    2704:	0f 90       	pop	r0
    2706:	cf 91       	pop	r28
    2708:	df 91       	pop	r29
    270a:	08 95       	ret

0000270c <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    270c:	df 93       	push	r29
    270e:	cf 93       	push	r28
    2710:	00 d0       	rcall	.+0      	; 0x2712 <prvIsQueueFull+0x6>
    2712:	0f 92       	push	r0
    2714:	cd b7       	in	r28, 0x3d	; 61
    2716:	de b7       	in	r29, 0x3e	; 62
    2718:	9b 83       	std	Y+3, r25	; 0x03
    271a:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    271c:	0f b6       	in	r0, 0x3f	; 63
    271e:	f8 94       	cli
    2720:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2722:	ea 81       	ldd	r30, Y+2	; 0x02
    2724:	fb 81       	ldd	r31, Y+3	; 0x03
    2726:	92 8d       	ldd	r25, Z+26	; 0x1a
    2728:	ea 81       	ldd	r30, Y+2	; 0x02
    272a:	fb 81       	ldd	r31, Y+3	; 0x03
    272c:	83 8d       	ldd	r24, Z+27	; 0x1b
    272e:	19 82       	std	Y+1, r1	; 0x01
    2730:	98 17       	cp	r25, r24
    2732:	11 f4       	brne	.+4      	; 0x2738 <prvIsQueueFull+0x2c>
    2734:	81 e0       	ldi	r24, 0x01	; 1
    2736:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    2738:	0f 90       	pop	r0
    273a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    273c:	89 81       	ldd	r24, Y+1	; 0x01
}
    273e:	0f 90       	pop	r0
    2740:	0f 90       	pop	r0
    2742:	0f 90       	pop	r0
    2744:	cf 91       	pop	r28
    2746:	df 91       	pop	r29
    2748:	08 95       	ret

0000274a <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    274a:	df 93       	push	r29
    274c:	cf 93       	push	r28
    274e:	00 d0       	rcall	.+0      	; 0x2750 <xQueueIsQueueFullFromISR+0x6>
    2750:	0f 92       	push	r0
    2752:	cd b7       	in	r28, 0x3d	; 61
    2754:	de b7       	in	r29, 0x3e	; 62
    2756:	9b 83       	std	Y+3, r25	; 0x03
    2758:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    275a:	ea 81       	ldd	r30, Y+2	; 0x02
    275c:	fb 81       	ldd	r31, Y+3	; 0x03
    275e:	92 8d       	ldd	r25, Z+26	; 0x1a
    2760:	ea 81       	ldd	r30, Y+2	; 0x02
    2762:	fb 81       	ldd	r31, Y+3	; 0x03
    2764:	83 8d       	ldd	r24, Z+27	; 0x1b
    2766:	19 82       	std	Y+1, r1	; 0x01
    2768:	98 17       	cp	r25, r24
    276a:	11 f4       	brne	.+4      	; 0x2770 <xQueueIsQueueFullFromISR+0x26>
    276c:	81 e0       	ldi	r24, 0x01	; 1
    276e:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    2770:	89 81       	ldd	r24, Y+1	; 0x01
}
    2772:	0f 90       	pop	r0
    2774:	0f 90       	pop	r0
    2776:	0f 90       	pop	r0
    2778:	cf 91       	pop	r28
    277a:	df 91       	pop	r29
    277c:	08 95       	ret

0000277e <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    277e:	af 92       	push	r10
    2780:	bf 92       	push	r11
    2782:	cf 92       	push	r12
    2784:	df 92       	push	r13
    2786:	ef 92       	push	r14
    2788:	ff 92       	push	r15
    278a:	0f 93       	push	r16
    278c:	1f 93       	push	r17
    278e:	df 93       	push	r29
    2790:	cf 93       	push	r28
    2792:	cd b7       	in	r28, 0x3d	; 61
    2794:	de b7       	in	r29, 0x3e	; 62
    2796:	64 97       	sbiw	r28, 0x14	; 20
    2798:	0f b6       	in	r0, 0x3f	; 63
    279a:	f8 94       	cli
    279c:	de bf       	out	0x3e, r29	; 62
    279e:	0f be       	out	0x3f, r0	; 63
    27a0:	cd bf       	out	0x3d, r28	; 61
    27a2:	9f 83       	std	Y+7, r25	; 0x07
    27a4:	8e 83       	std	Y+6, r24	; 0x06
    27a6:	79 87       	std	Y+9, r23	; 0x09
    27a8:	68 87       	std	Y+8, r22	; 0x08
    27aa:	5b 87       	std	Y+11, r21	; 0x0b
    27ac:	4a 87       	std	Y+10, r20	; 0x0a
    27ae:	3d 87       	std	Y+13, r19	; 0x0d
    27b0:	2c 87       	std	Y+12, r18	; 0x0c
    27b2:	0e 87       	std	Y+14, r16	; 0x0e
    27b4:	f8 8a       	std	Y+16, r15	; 0x10
    27b6:	ef 86       	std	Y+15, r14	; 0x0f
    27b8:	da 8a       	std	Y+18, r13	; 0x12
    27ba:	c9 8a       	std	Y+17, r12	; 0x11
    27bc:	bc 8a       	std	Y+20, r11	; 0x14
    27be:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    27c0:	8a 85       	ldd	r24, Y+10	; 0x0a
    27c2:	9b 85       	ldd	r25, Y+11	; 0x0b
    27c4:	29 89       	ldd	r18, Y+17	; 0x11
    27c6:	3a 89       	ldd	r19, Y+18	; 0x12
    27c8:	b9 01       	movw	r22, r18
    27ca:	0e 94 44 1a 	call	0x3488	; 0x3488 <prvAllocateTCBAndStack>
    27ce:	9c 83       	std	Y+4, r25	; 0x04
    27d0:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    27d2:	8b 81       	ldd	r24, Y+3	; 0x03
    27d4:	9c 81       	ldd	r25, Y+4	; 0x04
    27d6:	00 97       	sbiw	r24, 0x00	; 0
    27d8:	09 f4       	brne	.+2      	; 0x27dc <xTaskGenericCreate+0x5e>
    27da:	99 c0       	rjmp	.+306    	; 0x290e <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    27dc:	eb 81       	ldd	r30, Y+3	; 0x03
    27de:	fc 81       	ldd	r31, Y+4	; 0x04
    27e0:	27 89       	ldd	r18, Z+23	; 0x17
    27e2:	30 8d       	ldd	r19, Z+24	; 0x18
    27e4:	8a 85       	ldd	r24, Y+10	; 0x0a
    27e6:	9b 85       	ldd	r25, Y+11	; 0x0b
    27e8:	01 97       	sbiw	r24, 0x01	; 1
    27ea:	82 0f       	add	r24, r18
    27ec:	93 1f       	adc	r25, r19
    27ee:	9a 83       	std	Y+2, r25	; 0x02
    27f0:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    27f2:	8b 81       	ldd	r24, Y+3	; 0x03
    27f4:	9c 81       	ldd	r25, Y+4	; 0x04
    27f6:	28 85       	ldd	r18, Y+8	; 0x08
    27f8:	39 85       	ldd	r19, Y+9	; 0x09
    27fa:	eb 89       	ldd	r30, Y+19	; 0x13
    27fc:	fc 89       	ldd	r31, Y+20	; 0x14
    27fe:	aa 85       	ldd	r26, Y+10	; 0x0a
    2800:	bb 85       	ldd	r27, Y+11	; 0x0b
    2802:	b9 01       	movw	r22, r18
    2804:	4e 85       	ldd	r20, Y+14	; 0x0e
    2806:	9f 01       	movw	r18, r30
    2808:	8d 01       	movw	r16, r26
    280a:	0e 94 29 19 	call	0x3252	; 0x3252 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    280e:	89 81       	ldd	r24, Y+1	; 0x01
    2810:	9a 81       	ldd	r25, Y+2	; 0x02
    2812:	2e 81       	ldd	r18, Y+6	; 0x06
    2814:	3f 81       	ldd	r19, Y+7	; 0x07
    2816:	4c 85       	ldd	r20, Y+12	; 0x0c
    2818:	5d 85       	ldd	r21, Y+13	; 0x0d
    281a:	b9 01       	movw	r22, r18
    281c:	0e 94 6c 0c 	call	0x18d8	; 0x18d8 <pxPortInitialiseStack>
    2820:	eb 81       	ldd	r30, Y+3	; 0x03
    2822:	fc 81       	ldd	r31, Y+4	; 0x04
    2824:	91 83       	std	Z+1, r25	; 0x01
    2826:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    2828:	8f 85       	ldd	r24, Y+15	; 0x0f
    282a:	98 89       	ldd	r25, Y+16	; 0x10
    282c:	00 97       	sbiw	r24, 0x00	; 0
    282e:	31 f0       	breq	.+12     	; 0x283c <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    2830:	ef 85       	ldd	r30, Y+15	; 0x0f
    2832:	f8 89       	ldd	r31, Y+16	; 0x10
    2834:	8b 81       	ldd	r24, Y+3	; 0x03
    2836:	9c 81       	ldd	r25, Y+4	; 0x04
    2838:	91 83       	std	Z+1, r25	; 0x01
    283a:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    283c:	0f b6       	in	r0, 0x3f	; 63
    283e:	f8 94       	cli
    2840:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    2842:	80 91 ff 02 	lds	r24, 0x02FF
    2846:	8f 5f       	subi	r24, 0xFF	; 255
    2848:	80 93 ff 02 	sts	0x02FF, r24
			if( pxCurrentTCB == NULL )
    284c:	80 91 fc 02 	lds	r24, 0x02FC
    2850:	90 91 fd 02 	lds	r25, 0x02FD
    2854:	00 97       	sbiw	r24, 0x00	; 0
    2856:	69 f4       	brne	.+26     	; 0x2872 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    2858:	8b 81       	ldd	r24, Y+3	; 0x03
    285a:	9c 81       	ldd	r25, Y+4	; 0x04
    285c:	90 93 fd 02 	sts	0x02FD, r25
    2860:	80 93 fc 02 	sts	0x02FC, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    2864:	80 91 ff 02 	lds	r24, 0x02FF
    2868:	81 30       	cpi	r24, 0x01	; 1
    286a:	a9 f4       	brne	.+42     	; 0x2896 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    286c:	0e 94 80 19 	call	0x3300	; 0x3300 <prvInitialiseTaskLists>
    2870:	12 c0       	rjmp	.+36     	; 0x2896 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    2872:	80 91 04 03 	lds	r24, 0x0304
    2876:	88 23       	and	r24, r24
    2878:	71 f4       	brne	.+28     	; 0x2896 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    287a:	e0 91 fc 02 	lds	r30, 0x02FC
    287e:	f0 91 fd 02 	lds	r31, 0x02FD
    2882:	96 89       	ldd	r25, Z+22	; 0x16
    2884:	8e 85       	ldd	r24, Y+14	; 0x0e
    2886:	89 17       	cp	r24, r25
    2888:	30 f0       	brcs	.+12     	; 0x2896 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    288a:	8b 81       	ldd	r24, Y+3	; 0x03
    288c:	9c 81       	ldd	r25, Y+4	; 0x04
    288e:	90 93 fd 02 	sts	0x02FD, r25
    2892:	80 93 fc 02 	sts	0x02FC, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    2896:	eb 81       	ldd	r30, Y+3	; 0x03
    2898:	fc 81       	ldd	r31, Y+4	; 0x04
    289a:	96 89       	ldd	r25, Z+22	; 0x16
    289c:	80 91 02 03 	lds	r24, 0x0302
    28a0:	89 17       	cp	r24, r25
    28a2:	28 f4       	brcc	.+10     	; 0x28ae <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    28a4:	eb 81       	ldd	r30, Y+3	; 0x03
    28a6:	fc 81       	ldd	r31, Y+4	; 0x04
    28a8:	86 89       	ldd	r24, Z+22	; 0x16
    28aa:	80 93 02 03 	sts	0x0302, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    28ae:	80 91 09 03 	lds	r24, 0x0309
    28b2:	8f 5f       	subi	r24, 0xFF	; 255
    28b4:	80 93 09 03 	sts	0x0309, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    28b8:	eb 81       	ldd	r30, Y+3	; 0x03
    28ba:	fc 81       	ldd	r31, Y+4	; 0x04
    28bc:	96 89       	ldd	r25, Z+22	; 0x16
    28be:	80 91 03 03 	lds	r24, 0x0303
    28c2:	89 17       	cp	r24, r25
    28c4:	28 f4       	brcc	.+10     	; 0x28d0 <xTaskGenericCreate+0x152>
    28c6:	eb 81       	ldd	r30, Y+3	; 0x03
    28c8:	fc 81       	ldd	r31, Y+4	; 0x04
    28ca:	86 89       	ldd	r24, Z+22	; 0x16
    28cc:	80 93 03 03 	sts	0x0303, r24
    28d0:	eb 81       	ldd	r30, Y+3	; 0x03
    28d2:	fc 81       	ldd	r31, Y+4	; 0x04
    28d4:	86 89       	ldd	r24, Z+22	; 0x16
    28d6:	28 2f       	mov	r18, r24
    28d8:	30 e0       	ldi	r19, 0x00	; 0
    28da:	c9 01       	movw	r24, r18
    28dc:	88 0f       	add	r24, r24
    28de:	99 1f       	adc	r25, r25
    28e0:	88 0f       	add	r24, r24
    28e2:	99 1f       	adc	r25, r25
    28e4:	88 0f       	add	r24, r24
    28e6:	99 1f       	adc	r25, r25
    28e8:	82 0f       	add	r24, r18
    28ea:	93 1f       	adc	r25, r19
    28ec:	ac 01       	movw	r20, r24
    28ee:	46 5f       	subi	r20, 0xF6	; 246
    28f0:	5c 4f       	sbci	r21, 0xFC	; 252
    28f2:	8b 81       	ldd	r24, Y+3	; 0x03
    28f4:	9c 81       	ldd	r25, Y+4	; 0x04
    28f6:	9c 01       	movw	r18, r24
    28f8:	2e 5f       	subi	r18, 0xFE	; 254
    28fa:	3f 4f       	sbci	r19, 0xFF	; 255
    28fc:	ca 01       	movw	r24, r20
    28fe:	b9 01       	movw	r22, r18
    2900:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <vListInsertEnd>

			xReturn = pdPASS;
    2904:	81 e0       	ldi	r24, 0x01	; 1
    2906:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    2908:	0f 90       	pop	r0
    290a:	0f be       	out	0x3f, r0	; 63
    290c:	02 c0       	rjmp	.+4      	; 0x2912 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    290e:	8f ef       	ldi	r24, 0xFF	; 255
    2910:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    2912:	8d 81       	ldd	r24, Y+5	; 0x05
    2914:	81 30       	cpi	r24, 0x01	; 1
    2916:	71 f4       	brne	.+28     	; 0x2934 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    2918:	80 91 04 03 	lds	r24, 0x0304
    291c:	88 23       	and	r24, r24
    291e:	51 f0       	breq	.+20     	; 0x2934 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    2920:	e0 91 fc 02 	lds	r30, 0x02FC
    2924:	f0 91 fd 02 	lds	r31, 0x02FD
    2928:	96 89       	ldd	r25, Z+22	; 0x16
    292a:	8e 85       	ldd	r24, Y+14	; 0x0e
    292c:	98 17       	cp	r25, r24
    292e:	10 f4       	brcc	.+4      	; 0x2934 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    2930:	0e 94 2b 0e 	call	0x1c56	; 0x1c56 <vPortYield>
			}
		}
	}

	return xReturn;
    2934:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2936:	64 96       	adiw	r28, 0x14	; 20
    2938:	0f b6       	in	r0, 0x3f	; 63
    293a:	f8 94       	cli
    293c:	de bf       	out	0x3e, r29	; 62
    293e:	0f be       	out	0x3f, r0	; 63
    2940:	cd bf       	out	0x3d, r28	; 61
    2942:	cf 91       	pop	r28
    2944:	df 91       	pop	r29
    2946:	1f 91       	pop	r17
    2948:	0f 91       	pop	r16
    294a:	ff 90       	pop	r15
    294c:	ef 90       	pop	r14
    294e:	df 90       	pop	r13
    2950:	cf 90       	pop	r12
    2952:	bf 90       	pop	r11
    2954:	af 90       	pop	r10
    2956:	08 95       	ret

00002958 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    2958:	df 93       	push	r29
    295a:	cf 93       	push	r28
    295c:	00 d0       	rcall	.+0      	; 0x295e <vTaskDelete+0x6>
    295e:	00 d0       	rcall	.+0      	; 0x2960 <vTaskDelete+0x8>
    2960:	00 d0       	rcall	.+0      	; 0x2962 <vTaskDelete+0xa>
    2962:	cd b7       	in	r28, 0x3d	; 61
    2964:	de b7       	in	r29, 0x3e	; 62
    2966:	9c 83       	std	Y+4, r25	; 0x04
    2968:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    296a:	0f b6       	in	r0, 0x3f	; 63
    296c:	f8 94       	cli
    296e:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    2970:	20 91 fc 02 	lds	r18, 0x02FC
    2974:	30 91 fd 02 	lds	r19, 0x02FD
    2978:	8b 81       	ldd	r24, Y+3	; 0x03
    297a:	9c 81       	ldd	r25, Y+4	; 0x04
    297c:	82 17       	cp	r24, r18
    297e:	93 07       	cpc	r25, r19
    2980:	11 f4       	brne	.+4      	; 0x2986 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    2982:	1c 82       	std	Y+4, r1	; 0x04
    2984:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    2986:	8b 81       	ldd	r24, Y+3	; 0x03
    2988:	9c 81       	ldd	r25, Y+4	; 0x04
    298a:	00 97       	sbiw	r24, 0x00	; 0
    298c:	39 f4       	brne	.+14     	; 0x299c <vTaskDelete+0x44>
    298e:	80 91 fc 02 	lds	r24, 0x02FC
    2992:	90 91 fd 02 	lds	r25, 0x02FD
    2996:	9e 83       	std	Y+6, r25	; 0x06
    2998:	8d 83       	std	Y+5, r24	; 0x05
    299a:	04 c0       	rjmp	.+8      	; 0x29a4 <vTaskDelete+0x4c>
    299c:	8b 81       	ldd	r24, Y+3	; 0x03
    299e:	9c 81       	ldd	r25, Y+4	; 0x04
    29a0:	9e 83       	std	Y+6, r25	; 0x06
    29a2:	8d 83       	std	Y+5, r24	; 0x05
    29a4:	8d 81       	ldd	r24, Y+5	; 0x05
    29a6:	9e 81       	ldd	r25, Y+6	; 0x06
    29a8:	9a 83       	std	Y+2, r25	; 0x02
    29aa:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    29ac:	89 81       	ldd	r24, Y+1	; 0x01
    29ae:	9a 81       	ldd	r25, Y+2	; 0x02
    29b0:	02 96       	adiw	r24, 0x02	; 2
    29b2:	0e 94 a1 0b 	call	0x1742	; 0x1742 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    29b6:	e9 81       	ldd	r30, Y+1	; 0x01
    29b8:	fa 81       	ldd	r31, Y+2	; 0x02
    29ba:	84 89       	ldd	r24, Z+20	; 0x14
    29bc:	95 89       	ldd	r25, Z+21	; 0x15
    29be:	00 97       	sbiw	r24, 0x00	; 0
    29c0:	29 f0       	breq	.+10     	; 0x29cc <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    29c2:	89 81       	ldd	r24, Y+1	; 0x01
    29c4:	9a 81       	ldd	r25, Y+2	; 0x02
    29c6:	0c 96       	adiw	r24, 0x0c	; 12
    29c8:	0e 94 a1 0b 	call	0x1742	; 0x1742 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    29cc:	89 81       	ldd	r24, Y+1	; 0x01
    29ce:	9a 81       	ldd	r25, Y+2	; 0x02
    29d0:	9c 01       	movw	r18, r24
    29d2:	2e 5f       	subi	r18, 0xFE	; 254
    29d4:	3f 4f       	sbci	r19, 0xFF	; 255
    29d6:	8a e7       	ldi	r24, 0x7A	; 122
    29d8:	93 e0       	ldi	r25, 0x03	; 3
    29da:	b9 01       	movw	r22, r18
    29dc:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    29e0:	80 91 fe 02 	lds	r24, 0x02FE
    29e4:	8f 5f       	subi	r24, 0xFF	; 255
    29e6:	80 93 fe 02 	sts	0x02FE, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    29ea:	80 91 09 03 	lds	r24, 0x0309
    29ee:	8f 5f       	subi	r24, 0xFF	; 255
    29f0:	80 93 09 03 	sts	0x0309, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    29f4:	0f 90       	pop	r0
    29f6:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    29f8:	80 91 04 03 	lds	r24, 0x0304
    29fc:	88 23       	and	r24, r24
    29fe:	31 f0       	breq	.+12     	; 0x2a0c <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    2a00:	8b 81       	ldd	r24, Y+3	; 0x03
    2a02:	9c 81       	ldd	r25, Y+4	; 0x04
    2a04:	00 97       	sbiw	r24, 0x00	; 0
    2a06:	11 f4       	brne	.+4      	; 0x2a0c <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    2a08:	0e 94 2b 0e 	call	0x1c56	; 0x1c56 <vPortYield>
			}
		}
	}
    2a0c:	26 96       	adiw	r28, 0x06	; 6
    2a0e:	0f b6       	in	r0, 0x3f	; 63
    2a10:	f8 94       	cli
    2a12:	de bf       	out	0x3e, r29	; 62
    2a14:	0f be       	out	0x3f, r0	; 63
    2a16:	cd bf       	out	0x3d, r28	; 61
    2a18:	cf 91       	pop	r28
    2a1a:	df 91       	pop	r29
    2a1c:	08 95       	ret

00002a1e <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2a1e:	df 93       	push	r29
    2a20:	cf 93       	push	r28
    2a22:	cd b7       	in	r28, 0x3d	; 61
    2a24:	de b7       	in	r29, 0x3e	; 62
    2a26:	28 97       	sbiw	r28, 0x08	; 8
    2a28:	0f b6       	in	r0, 0x3f	; 63
    2a2a:	f8 94       	cli
    2a2c:	de bf       	out	0x3e, r29	; 62
    2a2e:	0f be       	out	0x3f, r0	; 63
    2a30:	cd bf       	out	0x3d, r28	; 61
    2a32:	9e 83       	std	Y+6, r25	; 0x06
    2a34:	8d 83       	std	Y+5, r24	; 0x05
    2a36:	78 87       	std	Y+8, r23	; 0x08
    2a38:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    2a3a:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    2a3c:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2a40:	ed 81       	ldd	r30, Y+5	; 0x05
    2a42:	fe 81       	ldd	r31, Y+6	; 0x06
    2a44:	20 81       	ld	r18, Z
    2a46:	31 81       	ldd	r19, Z+1	; 0x01
    2a48:	8f 81       	ldd	r24, Y+7	; 0x07
    2a4a:	98 85       	ldd	r25, Y+8	; 0x08
    2a4c:	82 0f       	add	r24, r18
    2a4e:	93 1f       	adc	r25, r19
    2a50:	9c 83       	std	Y+4, r25	; 0x04
    2a52:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    2a54:	ed 81       	ldd	r30, Y+5	; 0x05
    2a56:	fe 81       	ldd	r31, Y+6	; 0x06
    2a58:	20 81       	ld	r18, Z
    2a5a:	31 81       	ldd	r19, Z+1	; 0x01
    2a5c:	80 91 00 03 	lds	r24, 0x0300
    2a60:	90 91 01 03 	lds	r25, 0x0301
    2a64:	82 17       	cp	r24, r18
    2a66:	93 07       	cpc	r25, r19
    2a68:	a8 f4       	brcc	.+42     	; 0x2a94 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2a6a:	ed 81       	ldd	r30, Y+5	; 0x05
    2a6c:	fe 81       	ldd	r31, Y+6	; 0x06
    2a6e:	20 81       	ld	r18, Z
    2a70:	31 81       	ldd	r19, Z+1	; 0x01
    2a72:	8b 81       	ldd	r24, Y+3	; 0x03
    2a74:	9c 81       	ldd	r25, Y+4	; 0x04
    2a76:	82 17       	cp	r24, r18
    2a78:	93 07       	cpc	r25, r19
    2a7a:	00 f5       	brcc	.+64     	; 0x2abc <vTaskDelayUntil+0x9e>
    2a7c:	20 91 00 03 	lds	r18, 0x0300
    2a80:	30 91 01 03 	lds	r19, 0x0301
    2a84:	8b 81       	ldd	r24, Y+3	; 0x03
    2a86:	9c 81       	ldd	r25, Y+4	; 0x04
    2a88:	28 17       	cp	r18, r24
    2a8a:	39 07       	cpc	r19, r25
    2a8c:	b8 f4       	brcc	.+46     	; 0x2abc <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2a8e:	81 e0       	ldi	r24, 0x01	; 1
    2a90:	89 83       	std	Y+1, r24	; 0x01
    2a92:	14 c0       	rjmp	.+40     	; 0x2abc <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    2a94:	ed 81       	ldd	r30, Y+5	; 0x05
    2a96:	fe 81       	ldd	r31, Y+6	; 0x06
    2a98:	20 81       	ld	r18, Z
    2a9a:	31 81       	ldd	r19, Z+1	; 0x01
    2a9c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a9e:	9c 81       	ldd	r25, Y+4	; 0x04
    2aa0:	82 17       	cp	r24, r18
    2aa2:	93 07       	cpc	r25, r19
    2aa4:	48 f0       	brcs	.+18     	; 0x2ab8 <vTaskDelayUntil+0x9a>
    2aa6:	20 91 00 03 	lds	r18, 0x0300
    2aaa:	30 91 01 03 	lds	r19, 0x0301
    2aae:	8b 81       	ldd	r24, Y+3	; 0x03
    2ab0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ab2:	28 17       	cp	r18, r24
    2ab4:	39 07       	cpc	r19, r25
    2ab6:	10 f4       	brcc	.+4      	; 0x2abc <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2ab8:	81 e0       	ldi	r24, 0x01	; 1
    2aba:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2abc:	ed 81       	ldd	r30, Y+5	; 0x05
    2abe:	fe 81       	ldd	r31, Y+6	; 0x06
    2ac0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ac2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ac4:	91 83       	std	Z+1, r25	; 0x01
    2ac6:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    2ac8:	89 81       	ldd	r24, Y+1	; 0x01
    2aca:	88 23       	and	r24, r24
    2acc:	59 f0       	breq	.+22     	; 0x2ae4 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2ace:	80 91 fc 02 	lds	r24, 0x02FC
    2ad2:	90 91 fd 02 	lds	r25, 0x02FD
    2ad6:	02 96       	adiw	r24, 0x02	; 2
    2ad8:	0e 94 a1 0b 	call	0x1742	; 0x1742 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2adc:	8b 81       	ldd	r24, Y+3	; 0x03
    2ade:	9c 81       	ldd	r25, Y+4	; 0x04
    2ae0:	0e 94 fb 19 	call	0x33f6	; 0x33f6 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2ae4:	0e 94 07 16 	call	0x2c0e	; 0x2c0e <xTaskResumeAll>
    2ae8:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2aea:	8a 81       	ldd	r24, Y+2	; 0x02
    2aec:	88 23       	and	r24, r24
    2aee:	11 f4       	brne	.+4      	; 0x2af4 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    2af0:	0e 94 2b 0e 	call	0x1c56	; 0x1c56 <vPortYield>
		}
	}
    2af4:	28 96       	adiw	r28, 0x08	; 8
    2af6:	0f b6       	in	r0, 0x3f	; 63
    2af8:	f8 94       	cli
    2afa:	de bf       	out	0x3e, r29	; 62
    2afc:	0f be       	out	0x3f, r0	; 63
    2afe:	cd bf       	out	0x3d, r28	; 61
    2b00:	cf 91       	pop	r28
    2b02:	df 91       	pop	r29
    2b04:	08 95       	ret

00002b06 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2b06:	df 93       	push	r29
    2b08:	cf 93       	push	r28
    2b0a:	00 d0       	rcall	.+0      	; 0x2b0c <vTaskDelay+0x6>
    2b0c:	00 d0       	rcall	.+0      	; 0x2b0e <vTaskDelay+0x8>
    2b0e:	0f 92       	push	r0
    2b10:	cd b7       	in	r28, 0x3d	; 61
    2b12:	de b7       	in	r29, 0x3e	; 62
    2b14:	9d 83       	std	Y+5, r25	; 0x05
    2b16:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2b18:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2b1a:	8c 81       	ldd	r24, Y+4	; 0x04
    2b1c:	9d 81       	ldd	r25, Y+5	; 0x05
    2b1e:	00 97       	sbiw	r24, 0x00	; 0
    2b20:	d1 f0       	breq	.+52     	; 0x2b56 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    2b22:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2b26:	20 91 00 03 	lds	r18, 0x0300
    2b2a:	30 91 01 03 	lds	r19, 0x0301
    2b2e:	8c 81       	ldd	r24, Y+4	; 0x04
    2b30:	9d 81       	ldd	r25, Y+5	; 0x05
    2b32:	82 0f       	add	r24, r18
    2b34:	93 1f       	adc	r25, r19
    2b36:	9b 83       	std	Y+3, r25	; 0x03
    2b38:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2b3a:	80 91 fc 02 	lds	r24, 0x02FC
    2b3e:	90 91 fd 02 	lds	r25, 0x02FD
    2b42:	02 96       	adiw	r24, 0x02	; 2
    2b44:	0e 94 a1 0b 	call	0x1742	; 0x1742 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2b48:	8a 81       	ldd	r24, Y+2	; 0x02
    2b4a:	9b 81       	ldd	r25, Y+3	; 0x03
    2b4c:	0e 94 fb 19 	call	0x33f6	; 0x33f6 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2b50:	0e 94 07 16 	call	0x2c0e	; 0x2c0e <xTaskResumeAll>
    2b54:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2b56:	89 81       	ldd	r24, Y+1	; 0x01
    2b58:	88 23       	and	r24, r24
    2b5a:	11 f4       	brne	.+4      	; 0x2b60 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    2b5c:	0e 94 2b 0e 	call	0x1c56	; 0x1c56 <vPortYield>
		}
	}
    2b60:	0f 90       	pop	r0
    2b62:	0f 90       	pop	r0
    2b64:	0f 90       	pop	r0
    2b66:	0f 90       	pop	r0
    2b68:	0f 90       	pop	r0
    2b6a:	cf 91       	pop	r28
    2b6c:	df 91       	pop	r29
    2b6e:	08 95       	ret

00002b70 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    2b70:	af 92       	push	r10
    2b72:	bf 92       	push	r11
    2b74:	cf 92       	push	r12
    2b76:	df 92       	push	r13
    2b78:	ef 92       	push	r14
    2b7a:	ff 92       	push	r15
    2b7c:	0f 93       	push	r16
    2b7e:	df 93       	push	r29
    2b80:	cf 93       	push	r28
    2b82:	0f 92       	push	r0
    2b84:	cd b7       	in	r28, 0x3d	; 61
    2b86:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    2b88:	20 e6       	ldi	r18, 0x60	; 96
    2b8a:	30 e0       	ldi	r19, 0x00	; 0
    2b8c:	8f e1       	ldi	r24, 0x1F	; 31
    2b8e:	99 e1       	ldi	r25, 0x19	; 25
    2b90:	b9 01       	movw	r22, r18
    2b92:	45 e5       	ldi	r20, 0x55	; 85
    2b94:	50 e0       	ldi	r21, 0x00	; 0
    2b96:	20 e0       	ldi	r18, 0x00	; 0
    2b98:	30 e0       	ldi	r19, 0x00	; 0
    2b9a:	00 e0       	ldi	r16, 0x00	; 0
    2b9c:	ee 24       	eor	r14, r14
    2b9e:	ff 24       	eor	r15, r15
    2ba0:	cc 24       	eor	r12, r12
    2ba2:	dd 24       	eor	r13, r13
    2ba4:	aa 24       	eor	r10, r10
    2ba6:	bb 24       	eor	r11, r11
    2ba8:	0e 94 bf 13 	call	0x277e	; 0x277e <xTaskGenericCreate>
    2bac:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    2bae:	89 81       	ldd	r24, Y+1	; 0x01
    2bb0:	81 30       	cpi	r24, 0x01	; 1
    2bb2:	51 f4       	brne	.+20     	; 0x2bc8 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    2bb4:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    2bb6:	81 e0       	ldi	r24, 0x01	; 1
    2bb8:	80 93 04 03 	sts	0x0304, r24
		xTickCount = ( portTickType ) 0U;
    2bbc:	10 92 01 03 	sts	0x0301, r1
    2bc0:	10 92 00 03 	sts	0x0300, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    2bc4:	0e 94 ef 0d 	call	0x1bde	; 0x1bde <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    2bc8:	0f 90       	pop	r0
    2bca:	cf 91       	pop	r28
    2bcc:	df 91       	pop	r29
    2bce:	0f 91       	pop	r16
    2bd0:	ff 90       	pop	r15
    2bd2:	ef 90       	pop	r14
    2bd4:	df 90       	pop	r13
    2bd6:	cf 90       	pop	r12
    2bd8:	bf 90       	pop	r11
    2bda:	af 90       	pop	r10
    2bdc:	08 95       	ret

00002bde <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    2bde:	df 93       	push	r29
    2be0:	cf 93       	push	r28
    2be2:	cd b7       	in	r28, 0x3d	; 61
    2be4:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2be6:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2be8:	10 92 04 03 	sts	0x0304, r1
	vPortEndScheduler();
    2bec:	0e 94 24 0e 	call	0x1c48	; 0x1c48 <vPortEndScheduler>
}
    2bf0:	cf 91       	pop	r28
    2bf2:	df 91       	pop	r29
    2bf4:	08 95       	ret

00002bf6 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    2bf6:	df 93       	push	r29
    2bf8:	cf 93       	push	r28
    2bfa:	cd b7       	in	r28, 0x3d	; 61
    2bfc:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2bfe:	80 91 05 03 	lds	r24, 0x0305
    2c02:	8f 5f       	subi	r24, 0xFF	; 255
    2c04:	80 93 05 03 	sts	0x0305, r24
}
    2c08:	cf 91       	pop	r28
    2c0a:	df 91       	pop	r29
    2c0c:	08 95       	ret

00002c0e <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2c0e:	df 93       	push	r29
    2c10:	cf 93       	push	r28
    2c12:	00 d0       	rcall	.+0      	; 0x2c14 <xTaskResumeAll+0x6>
    2c14:	00 d0       	rcall	.+0      	; 0x2c16 <xTaskResumeAll+0x8>
    2c16:	cd b7       	in	r28, 0x3d	; 61
    2c18:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2c1a:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2c1c:	0f b6       	in	r0, 0x3f	; 63
    2c1e:	f8 94       	cli
    2c20:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2c22:	80 91 05 03 	lds	r24, 0x0305
    2c26:	81 50       	subi	r24, 0x01	; 1
    2c28:	80 93 05 03 	sts	0x0305, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2c2c:	80 91 05 03 	lds	r24, 0x0305
    2c30:	88 23       	and	r24, r24
    2c32:	09 f0       	breq	.+2      	; 0x2c36 <xTaskResumeAll+0x28>
    2c34:	6c c0       	rjmp	.+216    	; 0x2d0e <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2c36:	80 91 ff 02 	lds	r24, 0x02FF
    2c3a:	88 23       	and	r24, r24
    2c3c:	09 f4       	brne	.+2      	; 0x2c40 <xTaskResumeAll+0x32>
    2c3e:	67 c0       	rjmp	.+206    	; 0x2d0e <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    2c40:	19 82       	std	Y+1, r1	; 0x01
    2c42:	41 c0       	rjmp	.+130    	; 0x2cc6 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    2c44:	e0 91 76 03 	lds	r30, 0x0376
    2c48:	f0 91 77 03 	lds	r31, 0x0377
    2c4c:	86 81       	ldd	r24, Z+6	; 0x06
    2c4e:	97 81       	ldd	r25, Z+7	; 0x07
    2c50:	9c 83       	std	Y+4, r25	; 0x04
    2c52:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    2c54:	8b 81       	ldd	r24, Y+3	; 0x03
    2c56:	9c 81       	ldd	r25, Y+4	; 0x04
    2c58:	0c 96       	adiw	r24, 0x0c	; 12
    2c5a:	0e 94 a1 0b 	call	0x1742	; 0x1742 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2c5e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c60:	9c 81       	ldd	r25, Y+4	; 0x04
    2c62:	02 96       	adiw	r24, 0x02	; 2
    2c64:	0e 94 a1 0b 	call	0x1742	; 0x1742 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2c68:	eb 81       	ldd	r30, Y+3	; 0x03
    2c6a:	fc 81       	ldd	r31, Y+4	; 0x04
    2c6c:	96 89       	ldd	r25, Z+22	; 0x16
    2c6e:	80 91 03 03 	lds	r24, 0x0303
    2c72:	89 17       	cp	r24, r25
    2c74:	28 f4       	brcc	.+10     	; 0x2c80 <xTaskResumeAll+0x72>
    2c76:	eb 81       	ldd	r30, Y+3	; 0x03
    2c78:	fc 81       	ldd	r31, Y+4	; 0x04
    2c7a:	86 89       	ldd	r24, Z+22	; 0x16
    2c7c:	80 93 03 03 	sts	0x0303, r24
    2c80:	eb 81       	ldd	r30, Y+3	; 0x03
    2c82:	fc 81       	ldd	r31, Y+4	; 0x04
    2c84:	86 89       	ldd	r24, Z+22	; 0x16
    2c86:	28 2f       	mov	r18, r24
    2c88:	30 e0       	ldi	r19, 0x00	; 0
    2c8a:	c9 01       	movw	r24, r18
    2c8c:	88 0f       	add	r24, r24
    2c8e:	99 1f       	adc	r25, r25
    2c90:	88 0f       	add	r24, r24
    2c92:	99 1f       	adc	r25, r25
    2c94:	88 0f       	add	r24, r24
    2c96:	99 1f       	adc	r25, r25
    2c98:	82 0f       	add	r24, r18
    2c9a:	93 1f       	adc	r25, r19
    2c9c:	86 5f       	subi	r24, 0xF6	; 246
    2c9e:	9c 4f       	sbci	r25, 0xFC	; 252
    2ca0:	2b 81       	ldd	r18, Y+3	; 0x03
    2ca2:	3c 81       	ldd	r19, Y+4	; 0x04
    2ca4:	2e 5f       	subi	r18, 0xFE	; 254
    2ca6:	3f 4f       	sbci	r19, 0xFF	; 255
    2ca8:	b9 01       	movw	r22, r18
    2caa:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2cae:	eb 81       	ldd	r30, Y+3	; 0x03
    2cb0:	fc 81       	ldd	r31, Y+4	; 0x04
    2cb2:	96 89       	ldd	r25, Z+22	; 0x16
    2cb4:	e0 91 fc 02 	lds	r30, 0x02FC
    2cb8:	f0 91 fd 02 	lds	r31, 0x02FD
    2cbc:	86 89       	ldd	r24, Z+22	; 0x16
    2cbe:	98 17       	cp	r25, r24
    2cc0:	10 f0       	brcs	.+4      	; 0x2cc6 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    2cc2:	81 e0       	ldi	r24, 0x01	; 1
    2cc4:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2cc6:	80 91 71 03 	lds	r24, 0x0371
    2cca:	88 23       	and	r24, r24
    2ccc:	09 f0       	breq	.+2      	; 0x2cd0 <xTaskResumeAll+0xc2>
    2cce:	ba cf       	rjmp	.-140    	; 0x2c44 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2cd0:	80 91 06 03 	lds	r24, 0x0306
    2cd4:	88 23       	and	r24, r24
    2cd6:	71 f0       	breq	.+28     	; 0x2cf4 <xTaskResumeAll+0xe6>
    2cd8:	07 c0       	rjmp	.+14     	; 0x2ce8 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    2cda:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <vTaskIncrementTick>
						--uxMissedTicks;
    2cde:	80 91 06 03 	lds	r24, 0x0306
    2ce2:	81 50       	subi	r24, 0x01	; 1
    2ce4:	80 93 06 03 	sts	0x0306, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2ce8:	80 91 06 03 	lds	r24, 0x0306
    2cec:	88 23       	and	r24, r24
    2cee:	a9 f7       	brne	.-22     	; 0x2cda <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    2cf0:	81 e0       	ldi	r24, 0x01	; 1
    2cf2:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    2cf4:	89 81       	ldd	r24, Y+1	; 0x01
    2cf6:	81 30       	cpi	r24, 0x01	; 1
    2cf8:	21 f0       	breq	.+8      	; 0x2d02 <xTaskResumeAll+0xf4>
    2cfa:	80 91 07 03 	lds	r24, 0x0307
    2cfe:	81 30       	cpi	r24, 0x01	; 1
    2d00:	31 f4       	brne	.+12     	; 0x2d0e <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    2d02:	81 e0       	ldi	r24, 0x01	; 1
    2d04:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    2d06:	10 92 07 03 	sts	0x0307, r1
					portYIELD_WITHIN_API();
    2d0a:	0e 94 2b 0e 	call	0x1c56	; 0x1c56 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    2d0e:	0f 90       	pop	r0
    2d10:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    2d12:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2d14:	0f 90       	pop	r0
    2d16:	0f 90       	pop	r0
    2d18:	0f 90       	pop	r0
    2d1a:	0f 90       	pop	r0
    2d1c:	cf 91       	pop	r28
    2d1e:	df 91       	pop	r29
    2d20:	08 95       	ret

00002d22 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    2d22:	df 93       	push	r29
    2d24:	cf 93       	push	r28
    2d26:	00 d0       	rcall	.+0      	; 0x2d28 <xTaskGetTickCount+0x6>
    2d28:	cd b7       	in	r28, 0x3d	; 61
    2d2a:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    2d2c:	0f b6       	in	r0, 0x3f	; 63
    2d2e:	f8 94       	cli
    2d30:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    2d32:	80 91 00 03 	lds	r24, 0x0300
    2d36:	90 91 01 03 	lds	r25, 0x0301
    2d3a:	9a 83       	std	Y+2, r25	; 0x02
    2d3c:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2d3e:	0f 90       	pop	r0
    2d40:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    2d42:	89 81       	ldd	r24, Y+1	; 0x01
    2d44:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2d46:	0f 90       	pop	r0
    2d48:	0f 90       	pop	r0
    2d4a:	cf 91       	pop	r28
    2d4c:	df 91       	pop	r29
    2d4e:	08 95       	ret

00002d50 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    2d50:	df 93       	push	r29
    2d52:	cf 93       	push	r28
    2d54:	00 d0       	rcall	.+0      	; 0x2d56 <xTaskGetTickCountFromISR+0x6>
    2d56:	0f 92       	push	r0
    2d58:	cd b7       	in	r28, 0x3d	; 61
    2d5a:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2d5c:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    2d5e:	80 91 00 03 	lds	r24, 0x0300
    2d62:	90 91 01 03 	lds	r25, 0x0301
    2d66:	9b 83       	std	Y+3, r25	; 0x03
    2d68:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2d6a:	8a 81       	ldd	r24, Y+2	; 0x02
    2d6c:	9b 81       	ldd	r25, Y+3	; 0x03
}
    2d6e:	0f 90       	pop	r0
    2d70:	0f 90       	pop	r0
    2d72:	0f 90       	pop	r0
    2d74:	cf 91       	pop	r28
    2d76:	df 91       	pop	r29
    2d78:	08 95       	ret

00002d7a <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    2d7a:	df 93       	push	r29
    2d7c:	cf 93       	push	r28
    2d7e:	cd b7       	in	r28, 0x3d	; 61
    2d80:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    2d82:	80 91 ff 02 	lds	r24, 0x02FF
}
    2d86:	cf 91       	pop	r28
    2d88:	df 91       	pop	r29
    2d8a:	08 95       	ret

00002d8c <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    2d8c:	df 93       	push	r29
    2d8e:	cf 93       	push	r28
    2d90:	00 d0       	rcall	.+0      	; 0x2d92 <vTaskIncrementTick+0x6>
    2d92:	00 d0       	rcall	.+0      	; 0x2d94 <vTaskIncrementTick+0x8>
    2d94:	00 d0       	rcall	.+0      	; 0x2d96 <vTaskIncrementTick+0xa>
    2d96:	cd b7       	in	r28, 0x3d	; 61
    2d98:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2d9a:	80 91 05 03 	lds	r24, 0x0305
    2d9e:	88 23       	and	r24, r24
    2da0:	09 f0       	breq	.+2      	; 0x2da4 <vTaskIncrementTick+0x18>
    2da2:	bb c0       	rjmp	.+374    	; 0x2f1a <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    2da4:	80 91 00 03 	lds	r24, 0x0300
    2da8:	90 91 01 03 	lds	r25, 0x0301
    2dac:	01 96       	adiw	r24, 0x01	; 1
    2dae:	90 93 01 03 	sts	0x0301, r25
    2db2:	80 93 00 03 	sts	0x0300, r24
		if( xTickCount == ( portTickType ) 0U )
    2db6:	80 91 00 03 	lds	r24, 0x0300
    2dba:	90 91 01 03 	lds	r25, 0x0301
    2dbe:	00 97       	sbiw	r24, 0x00	; 0
    2dc0:	d1 f5       	brne	.+116    	; 0x2e36 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    2dc2:	80 91 6d 03 	lds	r24, 0x036D
    2dc6:	90 91 6e 03 	lds	r25, 0x036E
    2dca:	9c 83       	std	Y+4, r25	; 0x04
    2dcc:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    2dce:	80 91 6f 03 	lds	r24, 0x036F
    2dd2:	90 91 70 03 	lds	r25, 0x0370
    2dd6:	90 93 6e 03 	sts	0x036E, r25
    2dda:	80 93 6d 03 	sts	0x036D, r24
			pxOverflowDelayedTaskList = pxTemp;
    2dde:	8b 81       	ldd	r24, Y+3	; 0x03
    2de0:	9c 81       	ldd	r25, Y+4	; 0x04
    2de2:	90 93 70 03 	sts	0x0370, r25
    2de6:	80 93 6f 03 	sts	0x036F, r24
			xNumOfOverflows++;
    2dea:	80 91 08 03 	lds	r24, 0x0308
    2dee:	8f 5f       	subi	r24, 0xFF	; 255
    2df0:	80 93 08 03 	sts	0x0308, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2df4:	e0 91 6d 03 	lds	r30, 0x036D
    2df8:	f0 91 6e 03 	lds	r31, 0x036E
    2dfc:	80 81       	ld	r24, Z
    2dfe:	88 23       	and	r24, r24
    2e00:	39 f4       	brne	.+14     	; 0x2e10 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    2e02:	8f ef       	ldi	r24, 0xFF	; 255
    2e04:	9f ef       	ldi	r25, 0xFF	; 255
    2e06:	90 93 66 00 	sts	0x0066, r25
    2e0a:	80 93 65 00 	sts	0x0065, r24
    2e0e:	13 c0       	rjmp	.+38     	; 0x2e36 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2e10:	e0 91 6d 03 	lds	r30, 0x036D
    2e14:	f0 91 6e 03 	lds	r31, 0x036E
    2e18:	05 80       	ldd	r0, Z+5	; 0x05
    2e1a:	f6 81       	ldd	r31, Z+6	; 0x06
    2e1c:	e0 2d       	mov	r30, r0
    2e1e:	86 81       	ldd	r24, Z+6	; 0x06
    2e20:	97 81       	ldd	r25, Z+7	; 0x07
    2e22:	9e 83       	std	Y+6, r25	; 0x06
    2e24:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2e26:	ed 81       	ldd	r30, Y+5	; 0x05
    2e28:	fe 81       	ldd	r31, Y+6	; 0x06
    2e2a:	82 81       	ldd	r24, Z+2	; 0x02
    2e2c:	93 81       	ldd	r25, Z+3	; 0x03
    2e2e:	90 93 66 00 	sts	0x0066, r25
    2e32:	80 93 65 00 	sts	0x0065, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2e36:	20 91 00 03 	lds	r18, 0x0300
    2e3a:	30 91 01 03 	lds	r19, 0x0301
    2e3e:	80 91 65 00 	lds	r24, 0x0065
    2e42:	90 91 66 00 	lds	r25, 0x0066
    2e46:	28 17       	cp	r18, r24
    2e48:	39 07       	cpc	r19, r25
    2e4a:	08 f4       	brcc	.+2      	; 0x2e4e <vTaskIncrementTick+0xc2>
    2e4c:	6b c0       	rjmp	.+214    	; 0x2f24 <vTaskIncrementTick+0x198>
    2e4e:	e0 91 6d 03 	lds	r30, 0x036D
    2e52:	f0 91 6e 03 	lds	r31, 0x036E
    2e56:	80 81       	ld	r24, Z
    2e58:	88 23       	and	r24, r24
    2e5a:	39 f4       	brne	.+14     	; 0x2e6a <vTaskIncrementTick+0xde>
    2e5c:	8f ef       	ldi	r24, 0xFF	; 255
    2e5e:	9f ef       	ldi	r25, 0xFF	; 255
    2e60:	90 93 66 00 	sts	0x0066, r25
    2e64:	80 93 65 00 	sts	0x0065, r24
    2e68:	5d c0       	rjmp	.+186    	; 0x2f24 <vTaskIncrementTick+0x198>
    2e6a:	e0 91 6d 03 	lds	r30, 0x036D
    2e6e:	f0 91 6e 03 	lds	r31, 0x036E
    2e72:	05 80       	ldd	r0, Z+5	; 0x05
    2e74:	f6 81       	ldd	r31, Z+6	; 0x06
    2e76:	e0 2d       	mov	r30, r0
    2e78:	86 81       	ldd	r24, Z+6	; 0x06
    2e7a:	97 81       	ldd	r25, Z+7	; 0x07
    2e7c:	9e 83       	std	Y+6, r25	; 0x06
    2e7e:	8d 83       	std	Y+5, r24	; 0x05
    2e80:	ed 81       	ldd	r30, Y+5	; 0x05
    2e82:	fe 81       	ldd	r31, Y+6	; 0x06
    2e84:	82 81       	ldd	r24, Z+2	; 0x02
    2e86:	93 81       	ldd	r25, Z+3	; 0x03
    2e88:	9a 83       	std	Y+2, r25	; 0x02
    2e8a:	89 83       	std	Y+1, r24	; 0x01
    2e8c:	20 91 00 03 	lds	r18, 0x0300
    2e90:	30 91 01 03 	lds	r19, 0x0301
    2e94:	89 81       	ldd	r24, Y+1	; 0x01
    2e96:	9a 81       	ldd	r25, Y+2	; 0x02
    2e98:	28 17       	cp	r18, r24
    2e9a:	39 07       	cpc	r19, r25
    2e9c:	38 f4       	brcc	.+14     	; 0x2eac <vTaskIncrementTick+0x120>
    2e9e:	89 81       	ldd	r24, Y+1	; 0x01
    2ea0:	9a 81       	ldd	r25, Y+2	; 0x02
    2ea2:	90 93 66 00 	sts	0x0066, r25
    2ea6:	80 93 65 00 	sts	0x0065, r24
    2eaa:	3c c0       	rjmp	.+120    	; 0x2f24 <vTaskIncrementTick+0x198>
    2eac:	8d 81       	ldd	r24, Y+5	; 0x05
    2eae:	9e 81       	ldd	r25, Y+6	; 0x06
    2eb0:	02 96       	adiw	r24, 0x02	; 2
    2eb2:	0e 94 a1 0b 	call	0x1742	; 0x1742 <vListRemove>
    2eb6:	ed 81       	ldd	r30, Y+5	; 0x05
    2eb8:	fe 81       	ldd	r31, Y+6	; 0x06
    2eba:	84 89       	ldd	r24, Z+20	; 0x14
    2ebc:	95 89       	ldd	r25, Z+21	; 0x15
    2ebe:	00 97       	sbiw	r24, 0x00	; 0
    2ec0:	29 f0       	breq	.+10     	; 0x2ecc <vTaskIncrementTick+0x140>
    2ec2:	8d 81       	ldd	r24, Y+5	; 0x05
    2ec4:	9e 81       	ldd	r25, Y+6	; 0x06
    2ec6:	0c 96       	adiw	r24, 0x0c	; 12
    2ec8:	0e 94 a1 0b 	call	0x1742	; 0x1742 <vListRemove>
    2ecc:	ed 81       	ldd	r30, Y+5	; 0x05
    2ece:	fe 81       	ldd	r31, Y+6	; 0x06
    2ed0:	96 89       	ldd	r25, Z+22	; 0x16
    2ed2:	80 91 03 03 	lds	r24, 0x0303
    2ed6:	89 17       	cp	r24, r25
    2ed8:	28 f4       	brcc	.+10     	; 0x2ee4 <vTaskIncrementTick+0x158>
    2eda:	ed 81       	ldd	r30, Y+5	; 0x05
    2edc:	fe 81       	ldd	r31, Y+6	; 0x06
    2ede:	86 89       	ldd	r24, Z+22	; 0x16
    2ee0:	80 93 03 03 	sts	0x0303, r24
    2ee4:	ed 81       	ldd	r30, Y+5	; 0x05
    2ee6:	fe 81       	ldd	r31, Y+6	; 0x06
    2ee8:	86 89       	ldd	r24, Z+22	; 0x16
    2eea:	28 2f       	mov	r18, r24
    2eec:	30 e0       	ldi	r19, 0x00	; 0
    2eee:	c9 01       	movw	r24, r18
    2ef0:	88 0f       	add	r24, r24
    2ef2:	99 1f       	adc	r25, r25
    2ef4:	88 0f       	add	r24, r24
    2ef6:	99 1f       	adc	r25, r25
    2ef8:	88 0f       	add	r24, r24
    2efa:	99 1f       	adc	r25, r25
    2efc:	82 0f       	add	r24, r18
    2efe:	93 1f       	adc	r25, r19
    2f00:	ac 01       	movw	r20, r24
    2f02:	46 5f       	subi	r20, 0xF6	; 246
    2f04:	5c 4f       	sbci	r21, 0xFC	; 252
    2f06:	8d 81       	ldd	r24, Y+5	; 0x05
    2f08:	9e 81       	ldd	r25, Y+6	; 0x06
    2f0a:	9c 01       	movw	r18, r24
    2f0c:	2e 5f       	subi	r18, 0xFE	; 254
    2f0e:	3f 4f       	sbci	r19, 0xFF	; 255
    2f10:	ca 01       	movw	r24, r20
    2f12:	b9 01       	movw	r22, r18
    2f14:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <vListInsertEnd>
    2f18:	9a cf       	rjmp	.-204    	; 0x2e4e <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    2f1a:	80 91 06 03 	lds	r24, 0x0306
    2f1e:	8f 5f       	subi	r24, 0xFF	; 255
    2f20:	80 93 06 03 	sts	0x0306, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2f24:	26 96       	adiw	r28, 0x06	; 6
    2f26:	0f b6       	in	r0, 0x3f	; 63
    2f28:	f8 94       	cli
    2f2a:	de bf       	out	0x3e, r29	; 62
    2f2c:	0f be       	out	0x3f, r0	; 63
    2f2e:	cd bf       	out	0x3d, r28	; 61
    2f30:	cf 91       	pop	r28
    2f32:	df 91       	pop	r29
    2f34:	08 95       	ret

00002f36 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    2f36:	df 93       	push	r29
    2f38:	cf 93       	push	r28
    2f3a:	00 d0       	rcall	.+0      	; 0x2f3c <vTaskSwitchContext+0x6>
    2f3c:	cd b7       	in	r28, 0x3d	; 61
    2f3e:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2f40:	80 91 05 03 	lds	r24, 0x0305
    2f44:	88 23       	and	r24, r24
    2f46:	49 f0       	breq	.+18     	; 0x2f5a <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2f48:	81 e0       	ldi	r24, 0x01	; 1
    2f4a:	80 93 07 03 	sts	0x0307, r24
    2f4e:	54 c0       	rjmp	.+168    	; 0x2ff8 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2f50:	80 91 03 03 	lds	r24, 0x0303
    2f54:	81 50       	subi	r24, 0x01	; 1
    2f56:	80 93 03 03 	sts	0x0303, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2f5a:	80 91 03 03 	lds	r24, 0x0303
    2f5e:	28 2f       	mov	r18, r24
    2f60:	30 e0       	ldi	r19, 0x00	; 0
    2f62:	c9 01       	movw	r24, r18
    2f64:	88 0f       	add	r24, r24
    2f66:	99 1f       	adc	r25, r25
    2f68:	88 0f       	add	r24, r24
    2f6a:	99 1f       	adc	r25, r25
    2f6c:	88 0f       	add	r24, r24
    2f6e:	99 1f       	adc	r25, r25
    2f70:	82 0f       	add	r24, r18
    2f72:	93 1f       	adc	r25, r19
    2f74:	fc 01       	movw	r30, r24
    2f76:	e6 5f       	subi	r30, 0xF6	; 246
    2f78:	fc 4f       	sbci	r31, 0xFC	; 252
    2f7a:	80 81       	ld	r24, Z
    2f7c:	88 23       	and	r24, r24
    2f7e:	41 f3       	breq	.-48     	; 0x2f50 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2f80:	80 91 03 03 	lds	r24, 0x0303
    2f84:	28 2f       	mov	r18, r24
    2f86:	30 e0       	ldi	r19, 0x00	; 0
    2f88:	c9 01       	movw	r24, r18
    2f8a:	88 0f       	add	r24, r24
    2f8c:	99 1f       	adc	r25, r25
    2f8e:	88 0f       	add	r24, r24
    2f90:	99 1f       	adc	r25, r25
    2f92:	88 0f       	add	r24, r24
    2f94:	99 1f       	adc	r25, r25
    2f96:	82 0f       	add	r24, r18
    2f98:	93 1f       	adc	r25, r19
    2f9a:	86 5f       	subi	r24, 0xF6	; 246
    2f9c:	9c 4f       	sbci	r25, 0xFC	; 252
    2f9e:	9a 83       	std	Y+2, r25	; 0x02
    2fa0:	89 83       	std	Y+1, r24	; 0x01
    2fa2:	e9 81       	ldd	r30, Y+1	; 0x01
    2fa4:	fa 81       	ldd	r31, Y+2	; 0x02
    2fa6:	01 80       	ldd	r0, Z+1	; 0x01
    2fa8:	f2 81       	ldd	r31, Z+2	; 0x02
    2faa:	e0 2d       	mov	r30, r0
    2fac:	82 81       	ldd	r24, Z+2	; 0x02
    2fae:	93 81       	ldd	r25, Z+3	; 0x03
    2fb0:	e9 81       	ldd	r30, Y+1	; 0x01
    2fb2:	fa 81       	ldd	r31, Y+2	; 0x02
    2fb4:	92 83       	std	Z+2, r25	; 0x02
    2fb6:	81 83       	std	Z+1, r24	; 0x01
    2fb8:	e9 81       	ldd	r30, Y+1	; 0x01
    2fba:	fa 81       	ldd	r31, Y+2	; 0x02
    2fbc:	21 81       	ldd	r18, Z+1	; 0x01
    2fbe:	32 81       	ldd	r19, Z+2	; 0x02
    2fc0:	89 81       	ldd	r24, Y+1	; 0x01
    2fc2:	9a 81       	ldd	r25, Y+2	; 0x02
    2fc4:	03 96       	adiw	r24, 0x03	; 3
    2fc6:	28 17       	cp	r18, r24
    2fc8:	39 07       	cpc	r19, r25
    2fca:	59 f4       	brne	.+22     	; 0x2fe2 <vTaskSwitchContext+0xac>
    2fcc:	e9 81       	ldd	r30, Y+1	; 0x01
    2fce:	fa 81       	ldd	r31, Y+2	; 0x02
    2fd0:	01 80       	ldd	r0, Z+1	; 0x01
    2fd2:	f2 81       	ldd	r31, Z+2	; 0x02
    2fd4:	e0 2d       	mov	r30, r0
    2fd6:	82 81       	ldd	r24, Z+2	; 0x02
    2fd8:	93 81       	ldd	r25, Z+3	; 0x03
    2fda:	e9 81       	ldd	r30, Y+1	; 0x01
    2fdc:	fa 81       	ldd	r31, Y+2	; 0x02
    2fde:	92 83       	std	Z+2, r25	; 0x02
    2fe0:	81 83       	std	Z+1, r24	; 0x01
    2fe2:	e9 81       	ldd	r30, Y+1	; 0x01
    2fe4:	fa 81       	ldd	r31, Y+2	; 0x02
    2fe6:	01 80       	ldd	r0, Z+1	; 0x01
    2fe8:	f2 81       	ldd	r31, Z+2	; 0x02
    2fea:	e0 2d       	mov	r30, r0
    2fec:	86 81       	ldd	r24, Z+6	; 0x06
    2fee:	97 81       	ldd	r25, Z+7	; 0x07
    2ff0:	90 93 fd 02 	sts	0x02FD, r25
    2ff4:	80 93 fc 02 	sts	0x02FC, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    2ff8:	0f 90       	pop	r0
    2ffa:	0f 90       	pop	r0
    2ffc:	cf 91       	pop	r28
    2ffe:	df 91       	pop	r29
    3000:	08 95       	ret

00003002 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    3002:	df 93       	push	r29
    3004:	cf 93       	push	r28
    3006:	00 d0       	rcall	.+0      	; 0x3008 <vTaskPlaceOnEventList+0x6>
    3008:	00 d0       	rcall	.+0      	; 0x300a <vTaskPlaceOnEventList+0x8>
    300a:	00 d0       	rcall	.+0      	; 0x300c <vTaskPlaceOnEventList+0xa>
    300c:	cd b7       	in	r28, 0x3d	; 61
    300e:	de b7       	in	r29, 0x3e	; 62
    3010:	9c 83       	std	Y+4, r25	; 0x04
    3012:	8b 83       	std	Y+3, r24	; 0x03
    3014:	7e 83       	std	Y+6, r23	; 0x06
    3016:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    3018:	4b 81       	ldd	r20, Y+3	; 0x03
    301a:	5c 81       	ldd	r21, Y+4	; 0x04
    301c:	80 91 fc 02 	lds	r24, 0x02FC
    3020:	90 91 fd 02 	lds	r25, 0x02FD
    3024:	9c 01       	movw	r18, r24
    3026:	24 5f       	subi	r18, 0xF4	; 244
    3028:	3f 4f       	sbci	r19, 0xFF	; 255
    302a:	ca 01       	movw	r24, r20
    302c:	b9 01       	movw	r22, r18
    302e:	0e 94 35 0b 	call	0x166a	; 0x166a <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3032:	80 91 fc 02 	lds	r24, 0x02FC
    3036:	90 91 fd 02 	lds	r25, 0x02FD
    303a:	02 96       	adiw	r24, 0x02	; 2
    303c:	0e 94 a1 0b 	call	0x1742	; 0x1742 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    3040:	20 91 00 03 	lds	r18, 0x0300
    3044:	30 91 01 03 	lds	r19, 0x0301
    3048:	8d 81       	ldd	r24, Y+5	; 0x05
    304a:	9e 81       	ldd	r25, Y+6	; 0x06
    304c:	82 0f       	add	r24, r18
    304e:	93 1f       	adc	r25, r19
    3050:	9a 83       	std	Y+2, r25	; 0x02
    3052:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    3054:	89 81       	ldd	r24, Y+1	; 0x01
    3056:	9a 81       	ldd	r25, Y+2	; 0x02
    3058:	0e 94 fb 19 	call	0x33f6	; 0x33f6 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    305c:	26 96       	adiw	r28, 0x06	; 6
    305e:	0f b6       	in	r0, 0x3f	; 63
    3060:	f8 94       	cli
    3062:	de bf       	out	0x3e, r29	; 62
    3064:	0f be       	out	0x3f, r0	; 63
    3066:	cd bf       	out	0x3d, r28	; 61
    3068:	cf 91       	pop	r28
    306a:	df 91       	pop	r29
    306c:	08 95       	ret

0000306e <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    306e:	df 93       	push	r29
    3070:	cf 93       	push	r28
    3072:	00 d0       	rcall	.+0      	; 0x3074 <xTaskRemoveFromEventList+0x6>
    3074:	00 d0       	rcall	.+0      	; 0x3076 <xTaskRemoveFromEventList+0x8>
    3076:	0f 92       	push	r0
    3078:	cd b7       	in	r28, 0x3d	; 61
    307a:	de b7       	in	r29, 0x3e	; 62
    307c:	9d 83       	std	Y+5, r25	; 0x05
    307e:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    3080:	ec 81       	ldd	r30, Y+4	; 0x04
    3082:	fd 81       	ldd	r31, Y+5	; 0x05
    3084:	05 80       	ldd	r0, Z+5	; 0x05
    3086:	f6 81       	ldd	r31, Z+6	; 0x06
    3088:	e0 2d       	mov	r30, r0
    308a:	86 81       	ldd	r24, Z+6	; 0x06
    308c:	97 81       	ldd	r25, Z+7	; 0x07
    308e:	9b 83       	std	Y+3, r25	; 0x03
    3090:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3092:	8a 81       	ldd	r24, Y+2	; 0x02
    3094:	9b 81       	ldd	r25, Y+3	; 0x03
    3096:	0c 96       	adiw	r24, 0x0c	; 12
    3098:	0e 94 a1 0b 	call	0x1742	; 0x1742 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    309c:	80 91 05 03 	lds	r24, 0x0305
    30a0:	88 23       	and	r24, r24
    30a2:	61 f5       	brne	.+88     	; 0x30fc <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    30a4:	8a 81       	ldd	r24, Y+2	; 0x02
    30a6:	9b 81       	ldd	r25, Y+3	; 0x03
    30a8:	02 96       	adiw	r24, 0x02	; 2
    30aa:	0e 94 a1 0b 	call	0x1742	; 0x1742 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    30ae:	ea 81       	ldd	r30, Y+2	; 0x02
    30b0:	fb 81       	ldd	r31, Y+3	; 0x03
    30b2:	96 89       	ldd	r25, Z+22	; 0x16
    30b4:	80 91 03 03 	lds	r24, 0x0303
    30b8:	89 17       	cp	r24, r25
    30ba:	28 f4       	brcc	.+10     	; 0x30c6 <xTaskRemoveFromEventList+0x58>
    30bc:	ea 81       	ldd	r30, Y+2	; 0x02
    30be:	fb 81       	ldd	r31, Y+3	; 0x03
    30c0:	86 89       	ldd	r24, Z+22	; 0x16
    30c2:	80 93 03 03 	sts	0x0303, r24
    30c6:	ea 81       	ldd	r30, Y+2	; 0x02
    30c8:	fb 81       	ldd	r31, Y+3	; 0x03
    30ca:	86 89       	ldd	r24, Z+22	; 0x16
    30cc:	28 2f       	mov	r18, r24
    30ce:	30 e0       	ldi	r19, 0x00	; 0
    30d0:	c9 01       	movw	r24, r18
    30d2:	88 0f       	add	r24, r24
    30d4:	99 1f       	adc	r25, r25
    30d6:	88 0f       	add	r24, r24
    30d8:	99 1f       	adc	r25, r25
    30da:	88 0f       	add	r24, r24
    30dc:	99 1f       	adc	r25, r25
    30de:	82 0f       	add	r24, r18
    30e0:	93 1f       	adc	r25, r19
    30e2:	ac 01       	movw	r20, r24
    30e4:	46 5f       	subi	r20, 0xF6	; 246
    30e6:	5c 4f       	sbci	r21, 0xFC	; 252
    30e8:	8a 81       	ldd	r24, Y+2	; 0x02
    30ea:	9b 81       	ldd	r25, Y+3	; 0x03
    30ec:	9c 01       	movw	r18, r24
    30ee:	2e 5f       	subi	r18, 0xFE	; 254
    30f0:	3f 4f       	sbci	r19, 0xFF	; 255
    30f2:	ca 01       	movw	r24, r20
    30f4:	b9 01       	movw	r22, r18
    30f6:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <vListInsertEnd>
    30fa:	0a c0       	rjmp	.+20     	; 0x3110 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    30fc:	8a 81       	ldd	r24, Y+2	; 0x02
    30fe:	9b 81       	ldd	r25, Y+3	; 0x03
    3100:	9c 01       	movw	r18, r24
    3102:	24 5f       	subi	r18, 0xF4	; 244
    3104:	3f 4f       	sbci	r19, 0xFF	; 255
    3106:	81 e7       	ldi	r24, 0x71	; 113
    3108:	93 e0       	ldi	r25, 0x03	; 3
    310a:	b9 01       	movw	r22, r18
    310c:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3110:	ea 81       	ldd	r30, Y+2	; 0x02
    3112:	fb 81       	ldd	r31, Y+3	; 0x03
    3114:	96 89       	ldd	r25, Z+22	; 0x16
    3116:	e0 91 fc 02 	lds	r30, 0x02FC
    311a:	f0 91 fd 02 	lds	r31, 0x02FD
    311e:	86 89       	ldd	r24, Z+22	; 0x16
    3120:	98 17       	cp	r25, r24
    3122:	18 f0       	brcs	.+6      	; 0x312a <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    3124:	81 e0       	ldi	r24, 0x01	; 1
    3126:	89 83       	std	Y+1, r24	; 0x01
    3128:	01 c0       	rjmp	.+2      	; 0x312c <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    312a:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    312c:	89 81       	ldd	r24, Y+1	; 0x01
}
    312e:	0f 90       	pop	r0
    3130:	0f 90       	pop	r0
    3132:	0f 90       	pop	r0
    3134:	0f 90       	pop	r0
    3136:	0f 90       	pop	r0
    3138:	cf 91       	pop	r28
    313a:	df 91       	pop	r29
    313c:	08 95       	ret

0000313e <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    313e:	df 93       	push	r29
    3140:	cf 93       	push	r28
    3142:	00 d0       	rcall	.+0      	; 0x3144 <vTaskSetTimeOutState+0x6>
    3144:	cd b7       	in	r28, 0x3d	; 61
    3146:	de b7       	in	r29, 0x3e	; 62
    3148:	9a 83       	std	Y+2, r25	; 0x02
    314a:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    314c:	80 91 08 03 	lds	r24, 0x0308
    3150:	e9 81       	ldd	r30, Y+1	; 0x01
    3152:	fa 81       	ldd	r31, Y+2	; 0x02
    3154:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    3156:	80 91 00 03 	lds	r24, 0x0300
    315a:	90 91 01 03 	lds	r25, 0x0301
    315e:	e9 81       	ldd	r30, Y+1	; 0x01
    3160:	fa 81       	ldd	r31, Y+2	; 0x02
    3162:	92 83       	std	Z+2, r25	; 0x02
    3164:	81 83       	std	Z+1, r24	; 0x01
}
    3166:	0f 90       	pop	r0
    3168:	0f 90       	pop	r0
    316a:	cf 91       	pop	r28
    316c:	df 91       	pop	r29
    316e:	08 95       	ret

00003170 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    3170:	df 93       	push	r29
    3172:	cf 93       	push	r28
    3174:	00 d0       	rcall	.+0      	; 0x3176 <xTaskCheckForTimeOut+0x6>
    3176:	00 d0       	rcall	.+0      	; 0x3178 <xTaskCheckForTimeOut+0x8>
    3178:	0f 92       	push	r0
    317a:	cd b7       	in	r28, 0x3d	; 61
    317c:	de b7       	in	r29, 0x3e	; 62
    317e:	9b 83       	std	Y+3, r25	; 0x03
    3180:	8a 83       	std	Y+2, r24	; 0x02
    3182:	7d 83       	std	Y+5, r23	; 0x05
    3184:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    3186:	0f b6       	in	r0, 0x3f	; 63
    3188:	f8 94       	cli
    318a:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    318c:	ea 81       	ldd	r30, Y+2	; 0x02
    318e:	fb 81       	ldd	r31, Y+3	; 0x03
    3190:	90 81       	ld	r25, Z
    3192:	80 91 08 03 	lds	r24, 0x0308
    3196:	98 17       	cp	r25, r24
    3198:	71 f0       	breq	.+28     	; 0x31b6 <xTaskCheckForTimeOut+0x46>
    319a:	ea 81       	ldd	r30, Y+2	; 0x02
    319c:	fb 81       	ldd	r31, Y+3	; 0x03
    319e:	21 81       	ldd	r18, Z+1	; 0x01
    31a0:	32 81       	ldd	r19, Z+2	; 0x02
    31a2:	80 91 00 03 	lds	r24, 0x0300
    31a6:	90 91 01 03 	lds	r25, 0x0301
    31aa:	82 17       	cp	r24, r18
    31ac:	93 07       	cpc	r25, r19
    31ae:	18 f0       	brcs	.+6      	; 0x31b6 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    31b0:	81 e0       	ldi	r24, 0x01	; 1
    31b2:	89 83       	std	Y+1, r24	; 0x01
    31b4:	2f c0       	rjmp	.+94     	; 0x3214 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    31b6:	20 91 00 03 	lds	r18, 0x0300
    31ba:	30 91 01 03 	lds	r19, 0x0301
    31be:	ea 81       	ldd	r30, Y+2	; 0x02
    31c0:	fb 81       	ldd	r31, Y+3	; 0x03
    31c2:	81 81       	ldd	r24, Z+1	; 0x01
    31c4:	92 81       	ldd	r25, Z+2	; 0x02
    31c6:	28 1b       	sub	r18, r24
    31c8:	39 0b       	sbc	r19, r25
    31ca:	ec 81       	ldd	r30, Y+4	; 0x04
    31cc:	fd 81       	ldd	r31, Y+5	; 0x05
    31ce:	80 81       	ld	r24, Z
    31d0:	91 81       	ldd	r25, Z+1	; 0x01
    31d2:	28 17       	cp	r18, r24
    31d4:	39 07       	cpc	r19, r25
    31d6:	e0 f4       	brcc	.+56     	; 0x3210 <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    31d8:	ec 81       	ldd	r30, Y+4	; 0x04
    31da:	fd 81       	ldd	r31, Y+5	; 0x05
    31dc:	40 81       	ld	r20, Z
    31de:	51 81       	ldd	r21, Z+1	; 0x01
    31e0:	ea 81       	ldd	r30, Y+2	; 0x02
    31e2:	fb 81       	ldd	r31, Y+3	; 0x03
    31e4:	21 81       	ldd	r18, Z+1	; 0x01
    31e6:	32 81       	ldd	r19, Z+2	; 0x02
    31e8:	80 91 00 03 	lds	r24, 0x0300
    31ec:	90 91 01 03 	lds	r25, 0x0301
    31f0:	b9 01       	movw	r22, r18
    31f2:	68 1b       	sub	r22, r24
    31f4:	79 0b       	sbc	r23, r25
    31f6:	cb 01       	movw	r24, r22
    31f8:	84 0f       	add	r24, r20
    31fa:	95 1f       	adc	r25, r21
    31fc:	ec 81       	ldd	r30, Y+4	; 0x04
    31fe:	fd 81       	ldd	r31, Y+5	; 0x05
    3200:	91 83       	std	Z+1, r25	; 0x01
    3202:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    3204:	8a 81       	ldd	r24, Y+2	; 0x02
    3206:	9b 81       	ldd	r25, Y+3	; 0x03
    3208:	0e 94 9f 18 	call	0x313e	; 0x313e <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    320c:	19 82       	std	Y+1, r1	; 0x01
    320e:	02 c0       	rjmp	.+4      	; 0x3214 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    3210:	81 e0       	ldi	r24, 0x01	; 1
    3212:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3214:	0f 90       	pop	r0
    3216:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3218:	89 81       	ldd	r24, Y+1	; 0x01
}
    321a:	0f 90       	pop	r0
    321c:	0f 90       	pop	r0
    321e:	0f 90       	pop	r0
    3220:	0f 90       	pop	r0
    3222:	0f 90       	pop	r0
    3224:	cf 91       	pop	r28
    3226:	df 91       	pop	r29
    3228:	08 95       	ret

0000322a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    322a:	df 93       	push	r29
    322c:	cf 93       	push	r28
    322e:	cd b7       	in	r28, 0x3d	; 61
    3230:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    3232:	81 e0       	ldi	r24, 0x01	; 1
    3234:	80 93 07 03 	sts	0x0307, r24
}
    3238:	cf 91       	pop	r28
    323a:	df 91       	pop	r29
    323c:	08 95       	ret

0000323e <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    323e:	df 93       	push	r29
    3240:	cf 93       	push	r28
    3242:	00 d0       	rcall	.+0      	; 0x3244 <prvIdleTask+0x6>
    3244:	cd b7       	in	r28, 0x3d	; 61
    3246:	de b7       	in	r29, 0x3e	; 62
    3248:	9a 83       	std	Y+2, r25	; 0x02
    324a:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    324c:	0e 94 bd 19 	call	0x337a	; 0x337a <prvCheckTasksWaitingTermination>
    3250:	fd cf       	rjmp	.-6      	; 0x324c <prvIdleTask+0xe>

00003252 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    3252:	0f 93       	push	r16
    3254:	1f 93       	push	r17
    3256:	df 93       	push	r29
    3258:	cf 93       	push	r28
    325a:	cd b7       	in	r28, 0x3d	; 61
    325c:	de b7       	in	r29, 0x3e	; 62
    325e:	29 97       	sbiw	r28, 0x09	; 9
    3260:	0f b6       	in	r0, 0x3f	; 63
    3262:	f8 94       	cli
    3264:	de bf       	out	0x3e, r29	; 62
    3266:	0f be       	out	0x3f, r0	; 63
    3268:	cd bf       	out	0x3d, r28	; 61
    326a:	9a 83       	std	Y+2, r25	; 0x02
    326c:	89 83       	std	Y+1, r24	; 0x01
    326e:	7c 83       	std	Y+4, r23	; 0x04
    3270:	6b 83       	std	Y+3, r22	; 0x03
    3272:	4d 83       	std	Y+5, r20	; 0x05
    3274:	3f 83       	std	Y+7, r19	; 0x07
    3276:	2e 83       	std	Y+6, r18	; 0x06
    3278:	19 87       	std	Y+9, r17	; 0x09
    327a:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    327c:	89 81       	ldd	r24, Y+1	; 0x01
    327e:	9a 81       	ldd	r25, Y+2	; 0x02
    3280:	49 96       	adiw	r24, 0x19	; 25
    3282:	2b 81       	ldd	r18, Y+3	; 0x03
    3284:	3c 81       	ldd	r19, Y+4	; 0x04
    3286:	b9 01       	movw	r22, r18
    3288:	48 e0       	ldi	r20, 0x08	; 8
    328a:	50 e0       	ldi	r21, 0x00	; 0
    328c:	0e 94 ba 1a 	call	0x3574	; 0x3574 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    3290:	e9 81       	ldd	r30, Y+1	; 0x01
    3292:	fa 81       	ldd	r31, Y+2	; 0x02
    3294:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    3296:	8d 81       	ldd	r24, Y+5	; 0x05
    3298:	89 30       	cpi	r24, 0x09	; 9
    329a:	10 f0       	brcs	.+4      	; 0x32a0 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    329c:	88 e0       	ldi	r24, 0x08	; 8
    329e:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    32a0:	e9 81       	ldd	r30, Y+1	; 0x01
    32a2:	fa 81       	ldd	r31, Y+2	; 0x02
    32a4:	8d 81       	ldd	r24, Y+5	; 0x05
    32a6:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    32a8:	89 81       	ldd	r24, Y+1	; 0x01
    32aa:	9a 81       	ldd	r25, Y+2	; 0x02
    32ac:	02 96       	adiw	r24, 0x02	; 2
    32ae:	0e 94 d9 0a 	call	0x15b2	; 0x15b2 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    32b2:	89 81       	ldd	r24, Y+1	; 0x01
    32b4:	9a 81       	ldd	r25, Y+2	; 0x02
    32b6:	0c 96       	adiw	r24, 0x0c	; 12
    32b8:	0e 94 d9 0a 	call	0x15b2	; 0x15b2 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    32bc:	e9 81       	ldd	r30, Y+1	; 0x01
    32be:	fa 81       	ldd	r31, Y+2	; 0x02
    32c0:	89 81       	ldd	r24, Y+1	; 0x01
    32c2:	9a 81       	ldd	r25, Y+2	; 0x02
    32c4:	91 87       	std	Z+9, r25	; 0x09
    32c6:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    32c8:	8d 81       	ldd	r24, Y+5	; 0x05
    32ca:	28 2f       	mov	r18, r24
    32cc:	30 e0       	ldi	r19, 0x00	; 0
    32ce:	89 e0       	ldi	r24, 0x09	; 9
    32d0:	90 e0       	ldi	r25, 0x00	; 0
    32d2:	82 1b       	sub	r24, r18
    32d4:	93 0b       	sbc	r25, r19
    32d6:	e9 81       	ldd	r30, Y+1	; 0x01
    32d8:	fa 81       	ldd	r31, Y+2	; 0x02
    32da:	95 87       	std	Z+13, r25	; 0x0d
    32dc:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    32de:	e9 81       	ldd	r30, Y+1	; 0x01
    32e0:	fa 81       	ldd	r31, Y+2	; 0x02
    32e2:	89 81       	ldd	r24, Y+1	; 0x01
    32e4:	9a 81       	ldd	r25, Y+2	; 0x02
    32e6:	93 8b       	std	Z+19, r25	; 0x13
    32e8:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    32ea:	29 96       	adiw	r28, 0x09	; 9
    32ec:	0f b6       	in	r0, 0x3f	; 63
    32ee:	f8 94       	cli
    32f0:	de bf       	out	0x3e, r29	; 62
    32f2:	0f be       	out	0x3f, r0	; 63
    32f4:	cd bf       	out	0x3d, r28	; 61
    32f6:	cf 91       	pop	r28
    32f8:	df 91       	pop	r29
    32fa:	1f 91       	pop	r17
    32fc:	0f 91       	pop	r16
    32fe:	08 95       	ret

00003300 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    3300:	df 93       	push	r29
    3302:	cf 93       	push	r28
    3304:	0f 92       	push	r0
    3306:	cd b7       	in	r28, 0x3d	; 61
    3308:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    330a:	19 82       	std	Y+1, r1	; 0x01
    330c:	13 c0       	rjmp	.+38     	; 0x3334 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    330e:	89 81       	ldd	r24, Y+1	; 0x01
    3310:	28 2f       	mov	r18, r24
    3312:	30 e0       	ldi	r19, 0x00	; 0
    3314:	c9 01       	movw	r24, r18
    3316:	88 0f       	add	r24, r24
    3318:	99 1f       	adc	r25, r25
    331a:	88 0f       	add	r24, r24
    331c:	99 1f       	adc	r25, r25
    331e:	88 0f       	add	r24, r24
    3320:	99 1f       	adc	r25, r25
    3322:	82 0f       	add	r24, r18
    3324:	93 1f       	adc	r25, r19
    3326:	86 5f       	subi	r24, 0xF6	; 246
    3328:	9c 4f       	sbci	r25, 0xFC	; 252
    332a:	0e 94 af 0a 	call	0x155e	; 0x155e <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    332e:	89 81       	ldd	r24, Y+1	; 0x01
    3330:	8f 5f       	subi	r24, 0xFF	; 255
    3332:	89 83       	std	Y+1, r24	; 0x01
    3334:	89 81       	ldd	r24, Y+1	; 0x01
    3336:	89 30       	cpi	r24, 0x09	; 9
    3338:	50 f3       	brcs	.-44     	; 0x330e <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    333a:	8b e5       	ldi	r24, 0x5B	; 91
    333c:	93 e0       	ldi	r25, 0x03	; 3
    333e:	0e 94 af 0a 	call	0x155e	; 0x155e <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    3342:	84 e6       	ldi	r24, 0x64	; 100
    3344:	93 e0       	ldi	r25, 0x03	; 3
    3346:	0e 94 af 0a 	call	0x155e	; 0x155e <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    334a:	81 e7       	ldi	r24, 0x71	; 113
    334c:	93 e0       	ldi	r25, 0x03	; 3
    334e:	0e 94 af 0a 	call	0x155e	; 0x155e <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    3352:	8a e7       	ldi	r24, 0x7A	; 122
    3354:	93 e0       	ldi	r25, 0x03	; 3
    3356:	0e 94 af 0a 	call	0x155e	; 0x155e <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    335a:	8b e5       	ldi	r24, 0x5B	; 91
    335c:	93 e0       	ldi	r25, 0x03	; 3
    335e:	90 93 6e 03 	sts	0x036E, r25
    3362:	80 93 6d 03 	sts	0x036D, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    3366:	84 e6       	ldi	r24, 0x64	; 100
    3368:	93 e0       	ldi	r25, 0x03	; 3
    336a:	90 93 70 03 	sts	0x0370, r25
    336e:	80 93 6f 03 	sts	0x036F, r24
}
    3372:	0f 90       	pop	r0
    3374:	cf 91       	pop	r28
    3376:	df 91       	pop	r29
    3378:	08 95       	ret

0000337a <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    337a:	df 93       	push	r29
    337c:	cf 93       	push	r28
    337e:	00 d0       	rcall	.+0      	; 0x3380 <prvCheckTasksWaitingTermination+0x6>
    3380:	0f 92       	push	r0
    3382:	cd b7       	in	r28, 0x3d	; 61
    3384:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    3386:	80 91 fe 02 	lds	r24, 0x02FE
    338a:	88 23       	and	r24, r24
    338c:	71 f1       	breq	.+92     	; 0x33ea <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    338e:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    3392:	80 91 7a 03 	lds	r24, 0x037A
    3396:	1b 82       	std	Y+3, r1	; 0x03
    3398:	88 23       	and	r24, r24
    339a:	11 f4       	brne	.+4      	; 0x33a0 <prvCheckTasksWaitingTermination+0x26>
    339c:	81 e0       	ldi	r24, 0x01	; 1
    339e:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    33a0:	0e 94 07 16 	call	0x2c0e	; 0x2c0e <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    33a4:	8b 81       	ldd	r24, Y+3	; 0x03
    33a6:	88 23       	and	r24, r24
    33a8:	01 f5       	brne	.+64     	; 0x33ea <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    33aa:	0f b6       	in	r0, 0x3f	; 63
    33ac:	f8 94       	cli
    33ae:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    33b0:	e0 91 7f 03 	lds	r30, 0x037F
    33b4:	f0 91 80 03 	lds	r31, 0x0380
    33b8:	86 81       	ldd	r24, Z+6	; 0x06
    33ba:	97 81       	ldd	r25, Z+7	; 0x07
    33bc:	9a 83       	std	Y+2, r25	; 0x02
    33be:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    33c0:	89 81       	ldd	r24, Y+1	; 0x01
    33c2:	9a 81       	ldd	r25, Y+2	; 0x02
    33c4:	02 96       	adiw	r24, 0x02	; 2
    33c6:	0e 94 a1 0b 	call	0x1742	; 0x1742 <vListRemove>
					--uxCurrentNumberOfTasks;
    33ca:	80 91 ff 02 	lds	r24, 0x02FF
    33ce:	81 50       	subi	r24, 0x01	; 1
    33d0:	80 93 ff 02 	sts	0x02FF, r24
					--uxTasksDeleted;
    33d4:	80 91 fe 02 	lds	r24, 0x02FE
    33d8:	81 50       	subi	r24, 0x01	; 1
    33da:	80 93 fe 02 	sts	0x02FE, r24
				}
				taskEXIT_CRITICAL();
    33de:	0f 90       	pop	r0
    33e0:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    33e2:	89 81       	ldd	r24, Y+1	; 0x01
    33e4:	9a 81       	ldd	r25, Y+2	; 0x02
    33e6:	0e 94 94 1a 	call	0x3528	; 0x3528 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    33ea:	0f 90       	pop	r0
    33ec:	0f 90       	pop	r0
    33ee:	0f 90       	pop	r0
    33f0:	cf 91       	pop	r28
    33f2:	df 91       	pop	r29
    33f4:	08 95       	ret

000033f6 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    33f6:	df 93       	push	r29
    33f8:	cf 93       	push	r28
    33fa:	00 d0       	rcall	.+0      	; 0x33fc <prvAddCurrentTaskToDelayedList+0x6>
    33fc:	cd b7       	in	r28, 0x3d	; 61
    33fe:	de b7       	in	r29, 0x3e	; 62
    3400:	9a 83       	std	Y+2, r25	; 0x02
    3402:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    3404:	e0 91 fc 02 	lds	r30, 0x02FC
    3408:	f0 91 fd 02 	lds	r31, 0x02FD
    340c:	89 81       	ldd	r24, Y+1	; 0x01
    340e:	9a 81       	ldd	r25, Y+2	; 0x02
    3410:	93 83       	std	Z+3, r25	; 0x03
    3412:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    3414:	20 91 00 03 	lds	r18, 0x0300
    3418:	30 91 01 03 	lds	r19, 0x0301
    341c:	89 81       	ldd	r24, Y+1	; 0x01
    341e:	9a 81       	ldd	r25, Y+2	; 0x02
    3420:	82 17       	cp	r24, r18
    3422:	93 07       	cpc	r25, r19
    3424:	70 f4       	brcc	.+28     	; 0x3442 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3426:	80 91 6f 03 	lds	r24, 0x036F
    342a:	90 91 70 03 	lds	r25, 0x0370
    342e:	20 91 fc 02 	lds	r18, 0x02FC
    3432:	30 91 fd 02 	lds	r19, 0x02FD
    3436:	2e 5f       	subi	r18, 0xFE	; 254
    3438:	3f 4f       	sbci	r19, 0xFF	; 255
    343a:	b9 01       	movw	r22, r18
    343c:	0e 94 35 0b 	call	0x166a	; 0x166a <vListInsert>
    3440:	1e c0       	rjmp	.+60     	; 0x347e <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3442:	40 91 6d 03 	lds	r20, 0x036D
    3446:	50 91 6e 03 	lds	r21, 0x036E
    344a:	80 91 fc 02 	lds	r24, 0x02FC
    344e:	90 91 fd 02 	lds	r25, 0x02FD
    3452:	9c 01       	movw	r18, r24
    3454:	2e 5f       	subi	r18, 0xFE	; 254
    3456:	3f 4f       	sbci	r19, 0xFF	; 255
    3458:	ca 01       	movw	r24, r20
    345a:	b9 01       	movw	r22, r18
    345c:	0e 94 35 0b 	call	0x166a	; 0x166a <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    3460:	20 91 65 00 	lds	r18, 0x0065
    3464:	30 91 66 00 	lds	r19, 0x0066
    3468:	89 81       	ldd	r24, Y+1	; 0x01
    346a:	9a 81       	ldd	r25, Y+2	; 0x02
    346c:	82 17       	cp	r24, r18
    346e:	93 07       	cpc	r25, r19
    3470:	30 f4       	brcc	.+12     	; 0x347e <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    3472:	89 81       	ldd	r24, Y+1	; 0x01
    3474:	9a 81       	ldd	r25, Y+2	; 0x02
    3476:	90 93 66 00 	sts	0x0066, r25
    347a:	80 93 65 00 	sts	0x0065, r24
		}
	}
}
    347e:	0f 90       	pop	r0
    3480:	0f 90       	pop	r0
    3482:	cf 91       	pop	r28
    3484:	df 91       	pop	r29
    3486:	08 95       	ret

00003488 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    3488:	df 93       	push	r29
    348a:	cf 93       	push	r28
    348c:	cd b7       	in	r28, 0x3d	; 61
    348e:	de b7       	in	r29, 0x3e	; 62
    3490:	28 97       	sbiw	r28, 0x08	; 8
    3492:	0f b6       	in	r0, 0x3f	; 63
    3494:	f8 94       	cli
    3496:	de bf       	out	0x3e, r29	; 62
    3498:	0f be       	out	0x3f, r0	; 63
    349a:	cd bf       	out	0x3d, r28	; 61
    349c:	9c 83       	std	Y+4, r25	; 0x04
    349e:	8b 83       	std	Y+3, r24	; 0x03
    34a0:	7e 83       	std	Y+6, r23	; 0x06
    34a2:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    34a4:	81 e2       	ldi	r24, 0x21	; 33
    34a6:	90 e0       	ldi	r25, 0x00	; 0
    34a8:	0e 94 43 0a 	call	0x1486	; 0x1486 <pvPortMalloc>
    34ac:	9a 83       	std	Y+2, r25	; 0x02
    34ae:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    34b0:	89 81       	ldd	r24, Y+1	; 0x01
    34b2:	9a 81       	ldd	r25, Y+2	; 0x02
    34b4:	00 97       	sbiw	r24, 0x00	; 0
    34b6:	69 f1       	breq	.+90     	; 0x3512 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    34b8:	8d 81       	ldd	r24, Y+5	; 0x05
    34ba:	9e 81       	ldd	r25, Y+6	; 0x06
    34bc:	00 97       	sbiw	r24, 0x00	; 0
    34be:	39 f4       	brne	.+14     	; 0x34ce <prvAllocateTCBAndStack+0x46>
    34c0:	8b 81       	ldd	r24, Y+3	; 0x03
    34c2:	9c 81       	ldd	r25, Y+4	; 0x04
    34c4:	0e 94 43 0a 	call	0x1486	; 0x1486 <pvPortMalloc>
    34c8:	98 87       	std	Y+8, r25	; 0x08
    34ca:	8f 83       	std	Y+7, r24	; 0x07
    34cc:	04 c0       	rjmp	.+8      	; 0x34d6 <prvAllocateTCBAndStack+0x4e>
    34ce:	8d 81       	ldd	r24, Y+5	; 0x05
    34d0:	9e 81       	ldd	r25, Y+6	; 0x06
    34d2:	98 87       	std	Y+8, r25	; 0x08
    34d4:	8f 83       	std	Y+7, r24	; 0x07
    34d6:	e9 81       	ldd	r30, Y+1	; 0x01
    34d8:	fa 81       	ldd	r31, Y+2	; 0x02
    34da:	8f 81       	ldd	r24, Y+7	; 0x07
    34dc:	98 85       	ldd	r25, Y+8	; 0x08
    34de:	90 8f       	std	Z+24, r25	; 0x18
    34e0:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    34e2:	e9 81       	ldd	r30, Y+1	; 0x01
    34e4:	fa 81       	ldd	r31, Y+2	; 0x02
    34e6:	87 89       	ldd	r24, Z+23	; 0x17
    34e8:	90 8d       	ldd	r25, Z+24	; 0x18
    34ea:	00 97       	sbiw	r24, 0x00	; 0
    34ec:	39 f4       	brne	.+14     	; 0x34fc <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    34ee:	89 81       	ldd	r24, Y+1	; 0x01
    34f0:	9a 81       	ldd	r25, Y+2	; 0x02
    34f2:	0e 94 89 0a 	call	0x1512	; 0x1512 <vPortFree>
			pxNewTCB = NULL;
    34f6:	1a 82       	std	Y+2, r1	; 0x02
    34f8:	19 82       	std	Y+1, r1	; 0x01
    34fa:	0b c0       	rjmp	.+22     	; 0x3512 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    34fc:	e9 81       	ldd	r30, Y+1	; 0x01
    34fe:	fa 81       	ldd	r31, Y+2	; 0x02
    3500:	87 89       	ldd	r24, Z+23	; 0x17
    3502:	90 8d       	ldd	r25, Z+24	; 0x18
    3504:	2b 81       	ldd	r18, Y+3	; 0x03
    3506:	3c 81       	ldd	r19, Y+4	; 0x04
    3508:	65 ea       	ldi	r22, 0xA5	; 165
    350a:	70 e0       	ldi	r23, 0x00	; 0
    350c:	a9 01       	movw	r20, r18
    350e:	0e 94 b3 1a 	call	0x3566	; 0x3566 <memset>
		}
	}

	return pxNewTCB;
    3512:	89 81       	ldd	r24, Y+1	; 0x01
    3514:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3516:	28 96       	adiw	r28, 0x08	; 8
    3518:	0f b6       	in	r0, 0x3f	; 63
    351a:	f8 94       	cli
    351c:	de bf       	out	0x3e, r29	; 62
    351e:	0f be       	out	0x3f, r0	; 63
    3520:	cd bf       	out	0x3d, r28	; 61
    3522:	cf 91       	pop	r28
    3524:	df 91       	pop	r29
    3526:	08 95       	ret

00003528 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    3528:	df 93       	push	r29
    352a:	cf 93       	push	r28
    352c:	00 d0       	rcall	.+0      	; 0x352e <prvDeleteTCB+0x6>
    352e:	cd b7       	in	r28, 0x3d	; 61
    3530:	de b7       	in	r29, 0x3e	; 62
    3532:	9a 83       	std	Y+2, r25	; 0x02
    3534:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    3536:	e9 81       	ldd	r30, Y+1	; 0x01
    3538:	fa 81       	ldd	r31, Y+2	; 0x02
    353a:	87 89       	ldd	r24, Z+23	; 0x17
    353c:	90 8d       	ldd	r25, Z+24	; 0x18
    353e:	0e 94 89 0a 	call	0x1512	; 0x1512 <vPortFree>
		vPortFree( pxTCB );
    3542:	89 81       	ldd	r24, Y+1	; 0x01
    3544:	9a 81       	ldd	r25, Y+2	; 0x02
    3546:	0e 94 89 0a 	call	0x1512	; 0x1512 <vPortFree>
	}
    354a:	0f 90       	pop	r0
    354c:	0f 90       	pop	r0
    354e:	cf 91       	pop	r28
    3550:	df 91       	pop	r29
    3552:	08 95       	ret

00003554 <memcpy>:
    3554:	fb 01       	movw	r30, r22
    3556:	dc 01       	movw	r26, r24
    3558:	02 c0       	rjmp	.+4      	; 0x355e <memcpy+0xa>
    355a:	01 90       	ld	r0, Z+
    355c:	0d 92       	st	X+, r0
    355e:	41 50       	subi	r20, 0x01	; 1
    3560:	50 40       	sbci	r21, 0x00	; 0
    3562:	d8 f7       	brcc	.-10     	; 0x355a <memcpy+0x6>
    3564:	08 95       	ret

00003566 <memset>:
    3566:	dc 01       	movw	r26, r24
    3568:	01 c0       	rjmp	.+2      	; 0x356c <memset+0x6>
    356a:	6d 93       	st	X+, r22
    356c:	41 50       	subi	r20, 0x01	; 1
    356e:	50 40       	sbci	r21, 0x00	; 0
    3570:	e0 f7       	brcc	.-8      	; 0x356a <memset+0x4>
    3572:	08 95       	ret

00003574 <strncpy>:
    3574:	fb 01       	movw	r30, r22
    3576:	dc 01       	movw	r26, r24
    3578:	41 50       	subi	r20, 0x01	; 1
    357a:	50 40       	sbci	r21, 0x00	; 0
    357c:	48 f0       	brcs	.+18     	; 0x3590 <strncpy+0x1c>
    357e:	01 90       	ld	r0, Z+
    3580:	0d 92       	st	X+, r0
    3582:	00 20       	and	r0, r0
    3584:	c9 f7       	brne	.-14     	; 0x3578 <strncpy+0x4>
    3586:	01 c0       	rjmp	.+2      	; 0x358a <strncpy+0x16>
    3588:	1d 92       	st	X+, r1
    358a:	41 50       	subi	r20, 0x01	; 1
    358c:	50 40       	sbci	r21, 0x00	; 0
    358e:	e0 f7       	brcc	.-8      	; 0x3588 <strncpy+0x14>
    3590:	08 95       	ret

00003592 <_exit>:
    3592:	f8 94       	cli

00003594 <__stop_program>:
    3594:	ff cf       	rjmp	.-2      	; 0x3594 <__stop_program>
